<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>引用（References） - 《Move Book 中文版》</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">引言（Introduction）</a></li><li class="chapter-item expanded "><a href="modules-and-scripts.html"><strong aria-hidden="true">1.</strong> 模块和脚本（Modules and Scripts）</a></li><li class="chapter-item expanded "><a href="move-tutorial.html"><strong aria-hidden="true">2.</strong> Move 教程（Move Tutorial）</a></li><li class="chapter-item expanded "><a href="integers.html"><strong aria-hidden="true">3.</strong> 整数（Integers）</a></li><li class="chapter-item expanded "><a href="bool.html"><strong aria-hidden="true">4.</strong> 布尔类型（Bool）</a></li><li class="chapter-item expanded "><a href="address.html"><strong aria-hidden="true">5.</strong> 地址（Address）</a></li><li class="chapter-item expanded "><a href="vector.html"><strong aria-hidden="true">6.</strong> 向量（Vector）</a></li><li class="chapter-item expanded "><a href="signer.html"><strong aria-hidden="true">7.</strong> 签名（Signer）</a></li><li class="chapter-item expanded "><a href="references.html" class="active"><strong aria-hidden="true">8.</strong> 引用（References）</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">9.</strong> 元组和单值（Tuples and Unit）</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">10.</strong> 局部变量和作用域（Local Variables and Scopes）</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">11.</strong> 等式（Equality）</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">12.</strong> 中止和断言（Abort and Assert）</a></li><li class="chapter-item expanded "><a href="conditionals.html"><strong aria-hidden="true">13.</strong> 条件语句（Conditionals）</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">14.</strong> 循环（While and Loop）</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">15.</strong> 函数（Functions）</a></li><li class="chapter-item expanded "><a href="structs-and-resources.html"><strong aria-hidden="true">16.</strong> 结构体和资源（Structs and Resources）</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">17.</strong> 常量（Constants）</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">18.</strong> 泛型（Generics）</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">19.</strong> 类型能力（Type Abilities）</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">20.</strong> 导入和别名（Uses and Aliases）</a></li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">21.</strong> 友元函数（Friends）</a></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">22.</strong> 程序包（Packages）</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">23.</strong> 单元测试（Unit Tests）</a></li><li class="chapter-item expanded "><a href="global-storage-structure.html"><strong aria-hidden="true">24.</strong> 全局存储结构（Global Storage Structure）</a></li><li class="chapter-item expanded "><a href="global-storage-operators.html"><strong aria-hidden="true">25.</strong> 全局存储操作（Global Storage Operators）</a></li><li class="chapter-item expanded "><a href="standard-library.html"><strong aria-hidden="true">26.</strong> 标准库（Standard Library）</a></li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">27.</strong> Move 编码约定（Coding Conventions）</a></li><li class="chapter-item expanded "><a href="contribute.html"><strong aria-hidden="true">28.</strong> 中文版贡献指南</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">《Move Book 中文版》</h1>

                    <div class="right-buttons">
                        <button id="lang-toggle" class="icon-button" type="button" title="Change language" aria-label="Change language" aria-haspopup="true" aria-expanded="false" aria-controls="lang-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="lang-list" class="theme-popup" style="left: auto;" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="en">English</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="zh">Chinese</button></li>
                        </ul>
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="引用references"><a class="header" href="#引用references">引用(references)</a></h1>
<p>Move has two types of references: immutable <code>&amp;</code> and mutable <code>&amp;mut</code>. Immutable references are read
only, and cannot modify the underlying value (or any of its fields). Mutable references allow for
modifications via a write through that reference. Move's type system enforces an ownership
discipline that prevents reference errors.</p>
<p>Move 支持两种类型的引用：不可变引用 <code>&amp;</code> 和可变引用 <code>&amp;mut</code>。不可变引用是只读的，不能修改相关值(或其任何字段)。可变引用通过写入该引用进行修改。Move的类型系统强制执行所有权规则，以避免引用错误。</p>
<p>For more details on the rules of references, see <a href="structs-and-resources.html">Structs and Resources</a></p>
<p>更多有关引用规则的详细信息，请参阅：<a href="./structs-and-resources.html">结构和资源</a>.</p>
<h2 id="引用运算符-reference-operators"><a class="header" href="#引用运算符-reference-operators">引用运算符 (Reference Operators)</a></h2>
<p>Move provides operators for creating and extending references as well as converting a mutable
reference to an immutable one. Here and elsewhere, we use the notation <code>e: T</code> for &quot;expression <code>e</code>
has type <code>T</code>&quot;.</p>
<p>Move 提供了用于创建和扩展引用以及将可变引用转换为不可变引用的运算符。在这里和其他地方，我们使用符号 <code>e: T</code> 来表示“表达式 <code>e</code> 的类型是 <code>T</code> ”</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&amp;e</code></td><td><code>&amp;T</code> where <code>e: T</code> and <code>T</code> is a non-reference type</td><td>Create an immutable reference to <code>e</code></td></tr>
<tr><td><code>&amp;mut e</code></td><td><code>&amp;mut T</code> where <code>e: T</code> and <code>T</code> is a non-reference type</td><td>Create a mutable reference to <code>e</code>.</td></tr>
<tr><td><code>&amp;e.f</code></td><td><code>&amp;T</code> where <code>e.f: T</code></td><td>Create an immutable reference to field <code>f</code> of struct <code>e</code>.</td></tr>
<tr><td><code>&amp;mut e.f</code></td><td><code>&amp;mut T</code> where <code>e.f: T</code></td><td>Create a mutable reference to field <code>f</code> of struct<code>e</code>.</td></tr>
<tr><td><code>freeze(e)</code></td><td><code>&amp;T</code> where <code>e: &amp;mut T</code></td><td>Convert the mutable reference <code>e</code> into an immutable reference.</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>语法</th><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td><code>&amp;e</code></td><td><code>&amp;T</code> 其中 <code>e: T</code> 和 <code>T</code> 是非引用类型</td><td>创建一个不可变的引用 <code>e</code></td></tr>
<tr><td><code>&amp;mut e</code></td><td><code>&amp;mut T</code> 其中 <code>e: T</code> 和 <code>T</code> 是非引用类型</td><td>创建一个可变的引用 <code>e</code></td></tr>
<tr><td><code>&amp;e.f</code></td><td><code>&amp;T</code> 其中 <code>e.f: T</code></td><td>创建结构 <code>e</code> 的字段 <code>f</code> 的不可变引用</td></tr>
<tr><td><code>&amp;mut e.f</code></td><td><code>&amp;mut T</code> 其中<code>e.f: T</code></td><td>创建结构 <code>e</code> 的字段 <code>f</code> 的可变引用</td></tr>
<tr><td><code>freeze(e)</code></td><td><code>&amp;T</code> 其中<code>e: &amp;mut T</code></td><td>将可变引用 <code>e</code> 转换为不可变引用</td></tr>
</tbody></table>
</div>
<p>The <code>&amp;e.f</code> and <code>&amp;mut e.f</code> operators can be used both to create a new reference into a struct or to extend an existing reference:</p>
<p><code>&amp;e.f</code>和<code>&amp;mut e.f</code>运算符既可以用于在结构中创建新引用，也可以用于扩展现有引用：</p>
<pre><code class="language-move">let s = S { f: 10 };
let f_ref1: &amp;u64 = &amp;s.f; // works
let s_ref: &amp;S = &amp;s;
let f_ref2: &amp;u64 = &amp;s_ref.f // also works
</code></pre>
<p>A reference expression with multiple fields works as long as both structs are in the same module:</p>
<p>只要两个结构都在同一个模块中，具有多个字段的引用表达式就可以工作：</p>
<pre><code class="language-move">struct A { b: B }
struct B { c : u64 }
fun f(a: &amp;A): &amp;u64 {
  &amp;a.b.c
}
</code></pre>
<p>Finally, note that references to references are not allowed:</p>
<p>最后，请注意，不允许引用&quot;引用&quot;(Move不支持多重引用, 但Rust可以，译者注)：</p>
<pre><code class="language-move">let x = 7;
let y: &amp;u64 = &amp;x;
let z: &amp;&amp;u64 = &amp;y; // will not compile
</code></pre>
<h2 id="通过引用读取和写入"><a class="header" href="#通过引用读取和写入">通过引用读取和写入</a></h2>
<p>Both mutable and immutable references can be read to produce a copy of the referenced value.</p>
<p>Only mutable references can be written. A write <code>*x = v</code> discards the value previously stored in <code>x</code>
and updates it with <code>v</code>.</p>
<p>可以读取可变和不可变引用以生成引用值的副本。</p>
<p>只能写入可变引用。写入表达式 <code>*x = v</code> 会丢弃先前存储在x中的值，并用 <code>v</code> 更新。</p>
<p>Both operations use the C-like <code>*</code> syntax. However, note that a read is an expression, whereas a
write is a mutation that must occur on the left hand side of an equals.</p>
<p>两种操作都使用类 C <code>*</code> 语法。但是请注意，读取是一个表达式，而写入是一个必须发生在等号左侧的改动。</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>*e</code></td><td><code>T</code> where <code>e</code> is <code>&amp;T</code> or <code>&amp;mut T</code></td><td>Read the value pointed to by <code>e</code></td></tr>
<tr><td><code>*e1 = e2</code></td><td><code>()</code> where <code>e1: &amp;mut T</code> and <code>e2: T</code></td><td>Update the value in <code>e1</code> with <code>e2</code>.</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>语法</th><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td><code>&amp;e</code></td><td><code>T</code> 其中 <code>e</code> 为 <code>&amp;T</code> 或 <code>&amp;mut T</code></td><td>读取 <code>e</code> 所指向的值</td></tr>
<tr><td><code>*e1 = e2</code></td><td>() 其中 <code>e1: &amp;mut T</code> 和 <code>e2: T</code></td><td>用 <code>e2</code> 更新 <code>e1</code> 中的值</td></tr>
</tbody></table>
</div>
<p>In order for a reference to be read, the underlying type must have the
<a href="abilities.html"><code>copy</code> ability</a> as reading the reference creates a new copy of the value. This rule
prevents the copying of resource values:</p>
<p>为了读取引用，相关类型必须具备<a href="./abilities.html"><code>copy</code> 能力</a>，因为读取引用会创建值的新副本。此规则防止复制资源值：</p>
<pre><code class="language-move=">fun copy_resource_via_ref_bad(c: Coin) {
    let c_ref = &amp;c;
    let counterfeit: Coin = *c_ref; // not allowed!
    pay(c);
    pay(counterfeit);
}
</code></pre>
<p>Dually: in order for a reference to be written to, the underlying type must have the
<a href="abilities.html"><code>drop</code> ability</a> as writing to the reference will discard (or &quot;drop&quot;) the old value.
This rule prevents the destruction of resource values:</p>
<p>双重性：为了写入引用，相关类型必须具备<a href="./abilities.html"><code>drop</code> 能力</a>，因为写入引用将丢弃(或“删除”)旧值。此规则可防止破坏资源值：</p>
<pre><code class="language-move=">fun destroy_resource_via_ref_bad(ten_coins: Coin, c: Coin) {
    let ref = &amp;mut ten_coins;
    *ref = c; // not allowed--would destroy 10 coins!
}
</code></pre>
<h2 id="freeze-推断-freeze-inference"><a class="header" href="#freeze-推断-freeze-inference"><code>freeze</code> 推断 (<code>freeze</code> inference)</a></h2>
<p>A mutable reference can be used in a context where an immutable reference is expected:</p>
<p>可变引用可以在预期不可变引用的上下文中使用：</p>
<pre><code class="language-move">let x = 7;
let y: &amp;mut u64 = &amp;mut x;
</code></pre>
<p>This works because the under the hood, the compiler inserts <code>freeze</code> instructions where they are
needed. Here are a few more examples of <code>freeze</code> inference in action:</p>
<p>这是因为编译器会在底层需要的地方插入 <code>freeze</code> 指令。以下是更多 <code>freeze</code> 实际推断行为的示例：</p>
<pre><code class="language-move=">fun takes_immut_returns_immut(x: &amp;u64): &amp;u64 { x }

// freeze inference on return value
fun takes_mut_returns_immut(x: &amp;mut u64): &amp;u64 { x }

fun expression_examples() {
    let x = 0;
    let y = 0;
    takes_immut_returns_immut(&amp;x); // no inference
    takes_immut_returns_immut(&amp;mut x); // inferred freeze(&amp;mut x)
    takes_mut_returns_immut(&amp;mut x); // no inference

    assert!(&amp;x == &amp;mut y, 42); // inferred freeze(&amp;mut y)
}

fun assignment_examples() {
    let x = 0;
    let y = 0;
    let imm_ref: &amp;u64 = &amp;x;

    imm_ref = &amp;x; // no inference
    imm_ref = &amp;mut y; // inferred freeze(&amp;mut y)
}
</code></pre>
<h3 id="子类型化-subtyping"><a class="header" href="#子类型化-subtyping">子类型化 (Subtyping)</a></h3>
<p>With this <code>freeze</code> inference, the Move type checker can view <code>&amp;mut T</code> as a subtype of <code>&amp;T</code>. As shown
above, this means that anywhere for any expression where a <code>&amp;T</code> value is used, a <code>&amp;mut T</code> value can
also be used. This terminology is used in error messages to concisely indicate that a <code>&amp;mut T</code> was
needed where a <code>&amp;T</code> was supplied. For example</p>
<p>通过freeze推断，Move 类型检查器可以将 <code>&amp;mut T</code> 视为 <code>&amp;T</code> 的子类型。 如上所示，这意味着对于使用 <code>&amp;T</code> 值的任何表达式，也可以使用 <code>&amp;mut T</code> 值。此术语用于错误消息中，以简明扼要地表明在提供 <code>&amp;T</code> 的地方需要 <code>&amp;mut T</code> 。例如:</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {
            *store = *new_value
        }

        fun subtype_examples() {
            let x: &amp;u64 = &amp;0;
            let y: &amp;mut u64 = &amp;mut 1;

            x = &amp;mut 1; // valid
            y = &amp;2; // invalid!

            read_and_assign(y, x); // valid
            read_and_assign(x, y); // invalid!
        }
    }
}
</code></pre>
<p>will yield the following error messages</p>
<p>将产生以下错误消息</p>
<pre><code class="language-text">error:
    ┌── example.move:12:9 ───
    │
 12 │         y = &amp;2; // invalid!
    │         ^ Invalid assignment to local 'y'
    ·
 12 │         y = &amp;2; // invalid!
    │             -- The type: '&amp;{integer}'
    ·
  9 │         let y: &amp;mut u64 = &amp;mut 1;
    │                -------- Is not a subtype of: '&amp;mut u64'
    │

error:
    ┌── example.move:15:9 ───
    │
 15 │         read_and_assign(x, y); // invalid!
    │         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of '0x42::example::read_and_assign'. Invalid argument for parameter 'store'
    ·
  8 │         let x: &amp;u64 = &amp;0;
    │                ---- The type: '&amp;u64'
    ·
  3 │     fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {
    │                                -------- Is not a subtype of: '&amp;mut u64'
    │
</code></pre>
<p>The only other types currently that has subtyping are <a href="tuples.html">tuples</a></p>
<p>当前唯一具有子类型的其他类型是<a href="./tuples.html">tuple(元组)</a></p>
<h2 id="所有权-ownership"><a class="header" href="#所有权-ownership">所有权 (Ownership)</a></h2>
<p>Both mutable and immutable references can always be copied and extended <em>even if there are existing
copies or extensions of the same reference</em>:</p>
<p><em>即使同一引用存在现有副本或扩展</em>，可变引用和不可变引用始终可以被复制和扩展：</p>
<pre><code class="language-move">fun reference_copies(s: &amp;mut S) {
  let s_copy1 = s; // ok
  let s_extension = &amp;mut s.f; // also ok
  let s_copy2 = s; // still ok
  ...
}
</code></pre>
<p>This might be surprising for programmers familiar with Rust's ownership system, which would reject
the code above. Move's type system is more permissive in its treatment of
<a href="variables.html#move-and-copy">copies</a>, but equally strict in ensuring unique ownership of mutable
references before writes.</p>
<p>对于熟悉 Rust 所有权系统的程序员来说，这可能会令人惊讶，因为他们会拒绝上面的代码。Move 的类型系统在处理<a href="./variables.html#move-and-copy">副本</a>方面更加宽松 ，但在写入前确保可变引用的唯一所有权方面同样严格。</p>
<h3 id="无法存储引用-references-cannot-be-stored"><a class="header" href="#无法存储引用-references-cannot-be-stored">无法存储引用 (References Cannot Be Stored)</a></h3>
<p>References and tuples are the <em>only</em> types that cannot be stored as a field value of structs, which
also means that they cannot exist in global storage. All references created during program execution
will be destroyed when a Move program terminates; they are entirely ephemeral. This invariant is
also true for values of types without the <code>store</code> <a href="abilities.html">ability</a>, but note that
references and tuples go a step further by never being allowed in structs in the first place.</p>
<p>This is another difference between Move and Rust, which allows references to be stored inside of
structs.</p>
<p>引用和元组是唯一不能存储为结构的字段值的类型，这也意味着它们不能存在于全局存储中。当 Move 程序终止时，程序执行期间创建的所有引用都将被销毁；它们完全是短暂的。这种不变式也适用于没有<a href="./chatper_19_abilities.html"><code>store</code> 能力</a>的类型的值，但请注意，引用和元组更进一步，从一开始就不允许出现在结构中。</p>
<p>这是 Move 和 Rust 之间的另一个区别，后者允许将引用存储在结构内。</p>
<p>Currently, Move cannot support this because references cannot be
<a href="https://en.wikipedia.org/wiki/Serialization">serialized</a>, but <em>every Move value must be
serializable</em>. This requirement comes from Move's
<a href="global-storage-structure.html">persistent global storage</a>, which needs to serialize values to
persist them across program executions. Structs can be written to global storage, and thus they must
be serializable.</p>
<p>One could imagine a fancier, more expressive, type system that would allow references to be stored
in structs <em>and</em> ban those structs from existing in global storage. We could perhaps allow
references inside of structs that do not have the <code>store</code> <a href="abilities.html">ability</a>, but that would
not completely solve the problem: Move has a fairly complex system for tracking static reference
safety, and this aspect of the type system would also have to be extended to support storing
references inside of structs. In short, Move's type system (particularly the aspects around
reference safety) would have to expand to support stored references. But it is something we are
keeping an eye on as the language evolves.</p>
<p>目前，Move 无法支持这一点，因为引用无法被<a href="https://en.wikipedia.org/wiki/Serialization">序列化</a>，但 <em>每个 Move 值都必须是可序列化的</em>。这个要求来自于 Move 的 <a href="./global-storage-structure.html">持久化全局存储</a>，它需要在程序执行期间序列化值以持久化它们。结构体可以写入全局存储，因此它们必须是可序列化的。</p>
<p>可以想象一种更奇特、更有表现力的类型系统，它允许将引用存储在结构中，并禁止这些结构存在于全局存储中。我们也许可以允许在没有<a href="./abilities.html"><code>store</code> 能力</a>的结构内部使用引用，但这并不能完全解决问题：Move 有一个相当复杂的系统来跟踪静态引用安全性，并且类型系统的这一方面也必须扩展以支持在结构内部存储引用。简而言之，Move 的类型系统(尤其是与引用安全相关的方面)需要扩展以支持存储的引用。随着语言的发展，我们正在关注这一点。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="signer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="tuples.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="signer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="tuples.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>

        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->


        <script type="text/javascript">
        var langs = [
            'en',
            'zh'
        ];

        (function langs() {
            var html = document.querySelector('html');
            var langToggleButton = document.getElementById('lang-toggle');
            var langPopup = document.getElementById('lang-list');

            function showLangs() {
                langPopup.style.display = 'block';
                langToggleButton.setAttribute('aria-expanded', true);
            }

            function hideLangs() {
                langPopup.style.display = 'none';
                langToggleButton.setAttribute('aria-expanded', false);
                langToggleButton.focus();
            }

            langToggleButton.addEventListener('click', function () {
                if (langPopup.style.display === 'block') {
                    hideLangs();
                } else {
                    showLangs();
                }
            });

            langPopup.addEventListener('click', function (e) {
                var lang = e.target.id || e.target.parentElement.id;
                window.location.pathname = window.location.pathname
                    .split('/')
                    .map((s, idx) => {
                        return idx == 2 ? lang : s;
                    })
                    .join('/');
            });

            langPopup.addEventListener('focusout', function(e) {
                // e.relatedTarget is null in Safari and Firefox on macOS (see workaround below)
                if (!!e.relatedTarget && !langToggleButton.contains(e.relatedTarget) && !langPopup.contains(e.relatedTarget)) {
                    hideLangs();
                }
            });

            // Should not be needed, but it works around an issue on macOS & iOS: https://github.com/rust-lang-nursery/mdBook/issues/628
            document.addEventListener('click', function(e) {
                if (langPopup.style.display === 'block' && !langToggleButton.contains(e.target) && !langPopup.contains(e.target)) {
                    hideLangs();
                }
            });

        })();
        </script>


    </body>
</html>
