<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>局部变量和作用域（Local Variables and Scopes） - 《Move Book 中文版》</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">引言（Introduction）</a></li><li class="chapter-item expanded "><a href="modules-and-scripts.html"><strong aria-hidden="true">1.</strong> 模块和脚本（Modules and Scripts）</a></li><li class="chapter-item expanded "><a href="move-tutorial.html"><strong aria-hidden="true">2.</strong> Move 教程（Move Tutorial）</a></li><li class="chapter-item expanded "><a href="integers.html"><strong aria-hidden="true">3.</strong> 整数（Integers）</a></li><li class="chapter-item expanded "><a href="bool.html"><strong aria-hidden="true">4.</strong> 布尔类型（Bool）</a></li><li class="chapter-item expanded "><a href="address.html"><strong aria-hidden="true">5.</strong> 地址（Address）</a></li><li class="chapter-item expanded "><a href="vector.html"><strong aria-hidden="true">6.</strong> 向量（Vector）</a></li><li class="chapter-item expanded "><a href="signer.html"><strong aria-hidden="true">7.</strong> 签名（Signer）</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">8.</strong> 引用（References）</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">9.</strong> 元组和单值（Tuples and Unit）</a></li><li class="chapter-item expanded "><a href="variables.html" class="active"><strong aria-hidden="true">10.</strong> 局部变量和作用域（Local Variables and Scopes）</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">11.</strong> 等式（Equality）</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">12.</strong> 中止和断言（Abort and Assert）</a></li><li class="chapter-item expanded "><a href="conditionals.html"><strong aria-hidden="true">13.</strong> 条件语句（Conditionals）</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">14.</strong> 循环（While and Loop）</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">15.</strong> 函数（Functions）</a></li><li class="chapter-item expanded "><a href="structs-and-resources.html"><strong aria-hidden="true">16.</strong> 结构体和资源（Structs and Resources）</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">17.</strong> 常量（Constants）</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">18.</strong> 泛型（Generics）</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">19.</strong> 类型能力（Type Abilities）</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">20.</strong> 导入和别名（Uses and Aliases）</a></li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">21.</strong> 友元函数（Friends）</a></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">22.</strong> 程序包（Packages）</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">23.</strong> 单元测试（Unit Tests）</a></li><li class="chapter-item expanded "><a href="global-storage-structure.html"><strong aria-hidden="true">24.</strong> 全局存储结构（Global Storage Structure）</a></li><li class="chapter-item expanded "><a href="global-storage-operators.html"><strong aria-hidden="true">25.</strong> 全局存储操作（Global Storage Operators）</a></li><li class="chapter-item expanded "><a href="standard-library.html"><strong aria-hidden="true">26.</strong> 标准库（Standard Library）</a></li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">27.</strong> Move 编码约定（Coding Conventions）</a></li><li class="chapter-item expanded "><a href="contribute.html"><strong aria-hidden="true">28.</strong> 中文版贡献指南</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">《Move Book 中文版》</h1>

                    <div class="right-buttons">
                        <button id="lang-toggle" class="icon-button" type="button" title="Change language" aria-label="Change language" aria-haspopup="true" aria-expanded="false" aria-controls="lang-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="lang-list" class="theme-popup" style="left: auto;" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="en">English</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="zh">Chinese</button></li>
                        </ul>
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="局部变量和作用域local-variables-and-scopes"><a class="header" href="#局部变量和作用域local-variables-and-scopes">局部变量和作用域（Local Variables and Scopes）</a></h1>
<p>Local variables in Move are lexically (statically) scoped. New variables are introduced with the
keyword <code>let</code>, which will shadow any previous local with the same name. Locals are mutable and can
be updated both directly and via a mutable reference.</p>
<p>在 Move 语言中，局部变量的解析依赖于词法作用域（lexically scoped）或静态作用域（statically scoped）。使用关键字 <code>let</code> 引入新的变量，它将隐藏任何以前的同名局部变量。局部变量是可变的（Rust 中的变量默认不可变，译者注），可以直接更新，也可以通过可变引用更新。</p>
<h2 id="声明局部变量declaring-local-variables"><a class="header" href="#声明局部变量declaring-local-variables">声明局部变量（Declaring Local Variables）</a></h2>
<h3 id="let-绑定let-bindings"><a class="header" href="#let-绑定let-bindings"><code>let</code> 绑定（<code>let</code> bindings）</a></h3>
<p>Move programs use <code>let</code> to bind variable names to values:</p>
<p>Move 程序使用 <code>let</code> 给变量名绑定一个值：</p>
<pre><code class="language-move">let x = 1;
let y = x + x:
</code></pre>
<p><code>let</code> can also be used without binding a value to the local.</p>
<p><code>let</code> 使用时也可以不绑定任何数值给局部变量。</p>
<pre><code class="language-move">let x;
</code></pre>
<p>The local can then be assigned a value later.</p>
<p>然后可以稍后为局部变量赋一个值。</p>
<pre><code class="language-move">let x;
if (cond) {
  x = 1
} else {
  x = 0
}
</code></pre>
<p>This can be very helpful when trying to extract a value from a loop when a default value cannot be provided.</p>
<p>当无法提供默认值时，这在尝试从循环中提取值时非常有用。</p>
<pre><code class="language-move">let x;
let cond = true;
let i = 0;
loop {
    (x, cond) = foo(i);
    if (!cond) break;
    i = i + 1;
}
</code></pre>
<h3 id="变量必须在使用前赋值variables-must-be-assigned-before-use"><a class="header" href="#变量必须在使用前赋值variables-must-be-assigned-before-use">变量必须在使用前赋值（Variables must be assigned before use）</a></h3>
<p>Move's type system prevents a local variable from being used before it has been assigned.</p>
<p>Move 的类型系统防止在赋值之前使用局部变量。</p>
<pre><code class="language-move">let x;
x + x // ERROR!
</code></pre>
<pre><code class="language-move">let x;
if (cond) x = 0;
x + x // ERROR!
</code></pre>
<pre><code class="language-move">let x;
while (cond) x = 0;
x + x // ERROR!
</code></pre>
<h3 id="有效的变量名valid-variable-names"><a class="header" href="#有效的变量名valid-variable-names">有效的变量名（Valid variable names）</a></h3>
<p>Variable names can contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, and digits <code>0</code>
to <code>9</code>. Variable names must start with either an underscore <code>_</code> or a letter <code>a</code> through <code>z</code>. They
<em>cannot</em> start with uppercase letters.</p>
<p>变量名可以包含下划线 <code>_</code>、小写字母 <code>a</code> 到 <code>z</code>、大写字母 <code>A</code> 到 <code>Z</code>、和数字 <code>0</code> 到 <code>9</code>。变量名必须以下划线 <code>_</code> 或者以小写字母<code>a</code>到<code>z</code>开头。它们<em>不能</em>以大写字母开头。</p>
<pre><code class="language-move">// 全部有效
let x = e;
let _x = e;
let _A = e;
let x0 = e;
let xA = e;
let foobar_123 = e;

// 全部无效
let X = e; // ERROR!
let Foo = e; // ERROR!
</code></pre>
<h3 id="类型标注type-annotations"><a class="header" href="#类型标注type-annotations">类型标注（Type annotations）</a></h3>
<p>The type of a local variable can almost always be inferred by Move's type system. However, Move
allows explicit type annotations that can be useful for readability, clarity, or debuggability. The
syntax for adding a type annotation is:</p>
<p>局部变量的类型几乎总是可以通过 Move 的类型系统推断出来。但是，Move 允许显式类型标注，这对可读性、清晰性或可调试性很有用。添加类型标注的语法如下：</p>
<pre><code class="language-move">let x: T = e; // “T 类型的变量 x 被初始化为表达式 e”
</code></pre>
<p>Some examples of explicit type annotations:</p>
<p>一些显式类型标注的示例：</p>
<pre><code class="language-move">address 0x42 {
module example {

    struct S { f: u64, g: u64 }

    fun annotated() {
        let u: u8 = 0;
        let b: vector&lt;u8&gt; = b&quot;hello&quot;;
        let a: address = @0x0;
        let (x, y): (&amp;u64, &amp;mut u64) = (&amp;0, &amp;mut 1);
        let S { f, g: f2 }: S = S { f: 0, g: 1 };
    }
}
}
</code></pre>
<p>Note that the type annotations must always be to the right of the pattern:</p>
<p>请注意，类型标注必须始终位于变量模式的右侧：</p>
<pre><code class="language-move">let (x: &amp;u64, y: &amp;mut u64) = (&amp;0, &amp;mut 1); // 错误！正确写法是 let (x, y): ... =
</code></pre>
<h3 id="何时需要类型标注when-annotations-are-necessary"><a class="header" href="#何时需要类型标注when-annotations-are-necessary">何时需要类型标注（When annotations are necessary）</a></h3>
<p>In some cases, a local type annotation is required if the type system cannot infer the type. This
commonly occurs when the type argument for a generic type cannot be inferred. For example:</p>
<p>在某些情况下，如果类型系统无法推断类型，则需要局部类型标注。这通常发生在无法推断某个泛型（generic type）的类型参数时，比如：</p>
<pre><code class="language-move">let _v1 = vector::empty(); // 错误！
//        ^^^^^^^^^^^^^^^ Could not infer this type. Try adding an annotation （无法推断此类型。尝试添加标注）
let v2: vector&lt;u64&gt; = vector::empty(); // 没有错误
</code></pre>
<p>In a rarer case, the type system might not be able to infer a type for divergent code (where all the
following code is unreachable). Both <code>return</code> and <a href="abort-and-assert.html"><code>abort</code></a> are expressions
and can have any type. A <a href="loops.html"><code>loop</code></a> has type <code>()</code> if it has a <code>break</code>, but if there is no
break out of the <code>loop</code>, it could have any type. If these types cannot be inferred, a type
annotation is required. For example, this code:</p>
<p>在极少数情况下，Move 的类型系统可能无法推断出一段发散式代码（divergent code）的类型（后面所有代码无法访问）。在 Move 语言中，<code>return</code> 和 <a href="abort-and-assert.html"><code>abort</code></a> 都属于表达式，它们可以返回任何类型。如果一段 <a href="loops.html"><code>loop</code></a> 有 <code>break</code>，那么它的返回类型是 <code>()</code>，但是如果它不包含 <code>break</code>，它的返回类型可以是任何类型。如果无法推断出这些类型，那么类型标注是必须的。例如，这段代码：</p>
<pre><code class="language-move">let a: u8 = return ();
let b: bool = abort 0;
let c: signer = loop ();

let x = return (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let y = abort 0; // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let z = loop (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
</code></pre>
<p>Adding type annotations to this code will expose other errors about dead code or unused local
variables, but the example is still helpful for understanding this problem.</p>
<p>在这段代码中添加类型标注会暴露其他关于死代码或未使用的局部变量的错误，但该示例仍然有助于理解这个问题。</p>
<h3 id="元组式的多个变量声明multiple-declarations-with-tuples"><a class="header" href="#元组式的多个变量声明multiple-declarations-with-tuples">元组式的多个变量声明（Multiple declarations with tuples）</a></h3>
<p><code>let</code> can introduce more than one local at a time using tuples. The locals declared inside the
parenthesis are initialized to the corresponding values from the tuple.</p>
<p><code>let</code> 可以使用元组一次引入多个局部变量。在括号内声明的局部变量会被初始化为元组中的对应值。</p>
<pre><code class="language-move">let () = ();
let (x0, x1) = (0, 1);
let (y0, y1, y2) = (0, 1, 2);
let (z0, z1, z2, z3) = (0, 1, 2, 3);
</code></pre>
<p>The type of the expression must match the arity of the tuple pattern exactly.</p>
<p>表达式的类型必须与元组模式的数量完全匹配。</p>
<pre><code class="language-move">let (x, y) = (0, 1, 2); // 错误！
let (x, y, z, q) = (0, 1, 2); // 错误！
</code></pre>
<p>You cannot declare more than one local with the same name in a single <code>let</code>.</p>
<p>你不能在单个 <code>let</code> 中声明多个具有相同名称的局部变量。</p>
<pre><code class="language-move">let (x, x) = 0; // 错误！
</code></pre>
<h3 id="结构体式的多个变量声明multiple-declarations-with-structs"><a class="header" href="#结构体式的多个变量声明multiple-declarations-with-structs">结构体式的多个变量声明（Multiple declarations with structs）</a></h3>
<p><code>let</code> can also introduce more than one local at a time when destructuring (or matching against) a
struct. In this form, the <code>let</code> creates a set of local variables that are initialized to the values
of the fields from a struct. The syntax looks like this:</p>
<p><code>let</code> 还可以在解构（或匹配）结构体时一次引入多个局部变量。在这种形式中，<code>let</code> 创建了一组局部变量，这些变量被初始化为结构体中字段的值。语法如下所示：</p>
<pre><code class="language-move">struct T { f1: u64, f2: u64 }
</code></pre>
<pre><code class="language-move">let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
</code></pre>
<p>Here is a more complicated example:</p>
<p>这是一个更复杂的示例：</p>
<pre><code class="language-move">address 0x42 {
    module example {
        struct X { f: u64 }
        struct Y { x1: X, x2: X }

        fun new_x(): X {
            X { f: 1 }
        }

        fun example() {
            let Y { x1: X { f }, x2 } = Y { x1: new_x(), x2: new_x() };
            assert!(f + x2.f == 2, 42);

            let Y { x1: X { f: f1 }, x2: X { f: f2 } } = Y { x1: new_x(), x2: new_x() };
            assert!(f1 + f2 == 2, 42);
        }
    }
}
</code></pre>
<p>Fields of structs can serve double duty, identifying the field to bind <em>and</em> the name of the
variable. This is sometimes referred to as punning.</p>
<p>结构体的字段可以起到双重作用：识别要绑定的字段<em>和</em>命名变量。这有时被称为双关语。</p>
<pre><code class="language-move">let X { f } = e;
</code></pre>
<p>is equivalent to:</p>
<p>等价于：</p>
<pre><code class="language-move">let X { f: f } = e;
</code></pre>
<p>As shown with tuples, you cannot declare more than one local with the same name in a single <code>let</code>.</p>
<p>如元组所示，您不能在单个 <code>let</code> 中声明多个具有相同名称的局部变量。</p>
<pre><code class="language-move">let Y { x1: x, x2: x } = e; // 错误！（两个 x 同名了）
</code></pre>
<h3 id="针对引用进行解构destructuring-against-references"><a class="header" href="#针对引用进行解构destructuring-against-references">针对引用进行解构（Destructuring against references）</a></h3>
<p>In the examples above for structs, the bound value in the let was moved, destroying the struct value
and binding its fields.</p>
<p>在上面的结构体示例中，<code>let</code> 中绑定的值被移动了，这销毁了结构体的值并同时绑定了它的字段（到变量）。</p>
<pre><code class="language-move">struct T { f1: u64, f2: u64 }
</code></pre>
<pre><code class="language-move">let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
</code></pre>
<p>In this scenario the struct value <code>T { f1: 1, f2: 2 }</code> no longer exists after the <code>let</code>.</p>
<p>If you wish instead to not move and destroy the struct value, you can borrow each of its fields. For
example:</p>
<p>在这种场景下结构体的值 <code>T { f1: 1, f2: 2 }</code> 会在 <code>let</code> 后消失。</p>
<p>如果您希望不移动和销毁结构体的值，则可以借用其中的每个字段。例如：</p>
<pre><code class="language-move">let t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &amp;t;
// local1: &amp;u64
// local2: &amp;u64
</code></pre>
<p>And similarly with mutable references:</p>
<p>可变引用也类似：</p>
<pre><code class="language-move">let t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &amp;mut t;
// local1: &amp;mut u64
// local2: &amp;mut u64
</code></pre>
<p>This behavior can also work with nested structs.</p>
<p>此行为也适用于嵌套结构体。</p>
<pre><code class="language-move">address 0x42 {
    module example {
        struct X { f: u64 }
        struct Y { x1: X, x2: X }

        fun new_x(): X {
            X { f: 1 }
        }

        fun example() {
            let y = Y { x1: new_x(), x2: new_x() };

            let Y { x1: X { f }, x2 } = &amp;y;
            assert!(*f + x2.f == 2, 42);

            let Y { x1: X { f: f1 }, x2: X { f: f2 } } = &amp;mut y;
            *f1 = *f1 + 1;
            *f2 = *f2 + 1;
            assert!(*f1 + *f2 == 4, 42);
        }
    }
}
</code></pre>
<h3 id="忽略值ignoring-values"><a class="header" href="#忽略值ignoring-values">忽略值（Ignoring Values）</a></h3>
<p>In <code>let</code> bindings, it is often helpful to ignore some values. Local variables that start with <code>_</code>
will be ignored and not introduce a new variable</p>
<p>在 <code>let</code> 绑定中，忽略某些值通常很有帮助。以 <code>_</code> 开头的局部变量将被忽略并且不会引入新变量。</p>
<pre><code class="language-move">fun three(): (u64, u64, u64) {
    (0, 1, 2)
}
</code></pre>
<pre><code class="language-move">let (x1, _, z1) = three();
let (x2, _y, z2) = three();
assert!(x1 + z1 == x2 + z2, 42);
</code></pre>
<p>This can be necessary at times as the compiler will error on unused local variables。</p>
<p>这有时是必要的，因为编译器会在未使用的局部变量上报错。</p>
<pre><code class="language-move">let (x1, y, z1) = three(); // 错误！
//       ^ 未被使用的局部变量 'y'
</code></pre>
<h3 id="通用的-let-语法general-let-grammar"><a class="header" href="#通用的-let-语法general-let-grammar">通用的 <code>let</code> 语法（General <code>let</code> grammar）</a></h3>
<p>All of the different structures in <code>let</code> can be combined! With that we arrive at this general
grammar for <code>let</code> statements:</p>
<p><code>let</code> 中所有不同的结构体都可以组合！这样，我们就得出了 <code>let</code> 语句的通用语法：</p>
<blockquote>
<p><em>let-binding</em> → <strong>let</strong> <em>pattern-or-list</em> <em>type-annotation</em><sub><em>opt</em></sub>
<em>initializer</em><sub><em>opt</em></sub> &gt; <em>pattern-or-list</em> → <em>pattern</em> | <strong>(</strong> <em>pattern-list</em> <strong>)</strong> &gt;
<em>pattern-list</em> → <em>pattern</em> <strong>,</strong><sub><em>opt</em></sub> | <em>pattern</em> <strong>,</strong> <em>pattern-list</em> &gt;
<em>type-annotation</em> → <strong>:</strong> <em>type</em> <em>initializer</em> → <strong>=</strong> <em>expression</em></p>
</blockquote>
<p>The general term for the item that introduces the bindings is a <em>pattern</em>. The pattern serves to
both destructure data (possibly recursively) and introduce the bindings. The pattern grammar is as
follows:</p>
<p>引入绑定的项的通用术语是 <em>模式（pattern）</em>。该模式用于解构数据（可能是递归的）并引入绑定。模式语法如下：</p>
<blockquote>
<p><em>pattern</em> → <em>local-variable</em> | <em>struct-type</em> <strong>{</strong> <em>field-binding-list</em> <strong>}</strong> &gt;
<em>field-binding-list</em> → <em>field-binding</em> <strong>,</strong><sub><em>opt</em></sub> | <em>field-binding</em> <strong>,</strong>
<em>field-binding-list</em> &gt; <em>field-binding</em> → <em>field</em> | <em>field</em> <strong>:</strong> <em>pattern</em></p>
</blockquote>
<p>A few concrete examples with this grammar applied:</p>
<p>应用此语法的一些具体示例：</p>
<pre><code class="language-move">    let (x, y): (u64, u64) = (0, 1);
//       ^                           local-variable（局部变量）
//       ^                           pattern（模式）
//          ^                        local-variable（局部变量）
//          ^                        pattern（模式）
//          ^                        pattern-list（模式列表）
//       ^^^^                        pattern-list（模式列表）
//      ^^^^^^                       pattern-or-list（模式或列表）
//            ^^^^^^^^^^^^           type-annotation（类型标注）
//                         ^^^^^^^^  initializer（初始化器）
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding（let 绑定）

    let Foo { f, g: x } = Foo { f: 0, g: 1 };
//      ^^^                                    struct-type（结构类型）
//            ^                                field（字段）
//            ^                                field-binding（字段绑定）
//               ^                             field（字段）
//                  ^                          local-variable（局部变量）
//                  ^                          pattern（模式）
//               ^^^^                          field-binding（字段绑定）
//            ^^^^^^^                          field-binding-list（字段绑定列表）
//      ^^^^^^^^^^^^^^^                        pattern（模式）
//      ^^^^^^^^^^^^^^^                        pattern-or-list（模式或列表）
//                      ^^^^^^^^^^^^^^^^^^^^   initializer（初始化器）
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding（let 绑定）
</code></pre>
<h2 id="变更mutations"><a class="header" href="#变更mutations">变更（Mutations）</a></h2>
<h3 id="赋值assignments"><a class="header" href="#赋值assignments">赋值（Assignments）</a></h3>
<p>After the local is introduced (either by <code>let</code> or as a function parameter), the local can be
modified via an assignment:</p>
<p>在引入局部变量后（通过 <code>let</code> 或作为函数参数），可以通过赋值来修改局部变量：</p>
<pre><code class="language-move">x = e
</code></pre>
<p>Unlike <code>let</code> bindings, assignments are expressions. In some languages, assignments return the value
that was assigned, but in Move, the type of any assignment is always <code>()</code>.</p>
<p>与 <code>let</code> 绑定不同，赋值是表达式。在某些语言中，赋值会返回被赋予的值，但在 Move 语言中，任何赋值的返回类型始终是 <code>()</code>。</p>
<pre><code class="language-move">(x = e: ())
</code></pre>
<p>Practically, assignments being expressions means that they can be used without adding a new
expression block with braces (<code>{</code>...<code>}</code>).</p>
<p>实际上，赋值作为表达式意味着它们可以在不添加带有大括号（<code>{</code>...<code>}</code>）的新表达式块（expression block）的情况下使用。</p>
<pre><code class="language-move">let x = 0;
if (cond) x = 1 else x = 2;
</code></pre>
<p>The assignment uses the same pattern syntax scheme as <code>let</code> bindings:</p>
<p>赋值使用与 <code>let</code> 绑定相同的模式语法方案：</p>
<pre><code class="language-move">address 0x42 {
module example {
    struct X { f: u64 }

    fun new_x(): X {
        X { f: 1 }
    }

    // 这个例子会因为存在未使用的变量和赋值而报错。
    fun example() {
       let (x, _, z) = (0, 1, 3);
       let (x, y, f, g);

       (X { f }, X { f: x }) = (new_x(), new_x());
       assert!(f + x == 2, 42);

       (x, y, z, f, _, g) = (0, 0, 0, 0, 0, 0);
    }
}
}
</code></pre>
<p>Note that a local variable can only have one type, so the type of the local cannot change between
assignments.</p>
<p>注意，一个局部变量只能有一种类型，所以局部变量的类型不能在赋值之间（多次赋值）改变。</p>
<pre><code class="language-move">let x;
x = 0;
x = false; // 错误！
</code></pre>
<h3 id="通过引用进行变更mutating-through-a-reference"><a class="header" href="#通过引用进行变更mutating-through-a-reference">通过引用进行变更（Mutating through a reference）</a></h3>
<p>In addition to directly modifying a local with assignment, a local can be modified via a mutable
reference <code>&amp;mut</code>.</p>
<p>除了通过赋值直接修改局部变量外，还可以通过可变引用 <code>&amp;mut</code> 的方式修改局部变量。</p>
<pre><code class="language-move">let x = 0;
let r = &amp;mut x;
*r = 1;
assert!(x == 1, 42);
</code></pre>
<p>This is particularly useful if either:</p>
<p>(1) You want to modify different variables depending on some condition.</p>
<p>这在以下情况下特别有用：</p>
<p>(1) 你想根据某些条件修改不同的变量。</p>
<pre><code class="language-move">let x = 0;
let y = 1;
let r = if (cond) &amp;mut x else &amp;mut y;
*r = *r + 1;
</code></pre>
<p>(2) You want another function to modify your local value.</p>
<p>(2) 你想要另一个函数来修改你的局部变量值。</p>
<pre><code class="language-move">let x = 0;
modify_ref(&amp;mut x);
</code></pre>
<p>This sort of modification is how you modify structs and vectors!</p>
<p>这种修改方法就是你修改结构体和向量的方式！</p>
<pre><code class="language-move">let v = vector::empty();
vector::push_back(&amp;mut v, 100);
assert!(*vector::borrow(&amp;v, 0) == 100, 42);
</code></pre>
<p>For more details, see <a href="references.html">Move references</a>.</p>
<p>有关更多详细信息，请参阅 <a href="references.html">Move 引用</a>。</p>
<h2 id="作用域scopes"><a class="header" href="#作用域scopes">作用域（Scopes）</a></h2>
<p>Any local declared with <code>let</code> is available for any subsequent expression, <em>within that scope</em>.
Scopes are declared with expression blocks, <code>{</code>...<code>}</code>.</p>
<p>Locals cannot be used outside of the declared scope.</p>
<p>使用 <code>let</code> 声明的任何局部变量都可用于<em>该作用域内</em>的任何后续表达式。作用域用表达式块（expression blocks）声明，<code>{</code>...<code>}</code>。</p>
<p>局部变量不能在声明的作用域之外使用。</p>
<pre><code class="language-move">let x = 0;
{
    let y = 1;
};
x + y // 错误！
//  ^ unbound local 'y'（未绑定的局部变量“y”）
</code></pre>
<p>But, locals from an outer scope <em>can</em> be used in a nested scope.</p>
<p>但是，来自外部作用域的本地变量<em>可以</em>在嵌套作用域中使用。</p>
<pre><code class="language-move">{
    let x = 0;
    {
        let y = x + 1; // 有效的
    }
}
</code></pre>
<p>Locals can be mutated in any scope where they are accessible. That mutation survives with the local,
regardless of the scope that performed the mutation.</p>
<p>局部变量可以在允许访问的任何作用域内进行变更。无论执行变更的作用域如何，这种变更会跟随局部变量的生命周期。</p>
<pre><code class="language-move">let x = 0;
x = x + 1;
assert!(x == 1, 42);
{
    x = x + 1;
    assert!(x == 2, 42);
};
assert!(x == 2, 42);
</code></pre>
<h3 id="表达式块expression-blocks"><a class="header" href="#表达式块expression-blocks">表达式块（Expression Blocks）</a></h3>
<p>An expression block is a series of statements separated by semicolons (<code>;</code>). The resulting value of
an expression block is the value of the last expression in the block.</p>
<p>表达式块是由分号（<code>;</code>）分隔的一系列语句。表达式块的结果值是块中最后一个表达式的值。</p>
<pre><code class="language-move">{ let x = 1; let y = 1; x + y }
</code></pre>
<p>In this example, the result of the block is <code>x + y</code>.</p>
<p>A statement can be either a <code>let</code> declaration or an expression. Remember that assignments (<code>x = e</code>)
are expressions of type <code>()</code>.</p>
<p>在此示例中, 此区块的结果是 <code>x + y</code>.</p>
<p>语句可以是 <code>let</code> 声明或表达式。请记住，赋值（<code>x = e</code>）是 <code>()</code> 类型的表达式。</p>
<pre><code class="language-move">{ let x; let y = 1; x = 1; x + y }
</code></pre>
<p>Function calls are another common expression of type <code>()</code>. Function calls that modify data are
commonly used as statements.</p>
<p>函数调用是 <code>()</code> 类型的另一种常见表达方式。修改数据的函数调用通常被用作语句。</p>
<pre><code class="language-move">{ let v = vector::empty(); vector::push_back(&amp;mut v, 1); v }
</code></pre>
<p>This is not just limited to <code>()</code> types---any expression can be used as a statement in a sequence!</p>
<p>这不仅限于 <code>()</code> 类型 —— 任何表达式都可以用作序列中的语句！</p>
<pre><code class="language-move">{
    let x = 0;
    x + 1; // 值会被丢弃
    x + 2; // 值会被丢弃
    b&quot;hello&quot;; // 值会被丢弃
}
</code></pre>
<p>But! If the expression contains a resource (a value without the <code>drop</code> <a href="abilities.html">ability</a>),
you will get an error. This is because Move's type system guarantees that any value that is dropped
has the <code>drop</code> <a href="abilities.html">ability</a>. (Ownership must be transferred or the value must be
explicitly destroyed within its declaring module.)</p>
<p>但是！如果表达式包含资源（没有 <code>drop</code> <a href="abilities.html">能力</a>的值），你将收到错误消息。这是因为 Move 的类型系统保证任何被删除的值都具有 <code>drop</code> <a href="abilities.html">能力</a>。（必须转移所有权，或者必须在其声明模块中显式销毁该值。）</p>
<pre><code class="language-move">{
    let x = 0;
    Coin { value: x }; // 错误！
//  ^^^^^^^^^^^^^^^^^ unused value without the `drop` ability（未使用没有 `drop` 能力的值）
    x
}
</code></pre>
<p>If a final expression is not present in a block---that is, if there is a trailing semicolon <code>;</code>,
there is an implicit unit <code>()</code> value. Similarly, if the expression block is empty, there is an
implicit unit <code>()</code> value.</p>
<p>如果块中不存在最终表达式 —— 也就是说，如果有一个尾随分号 <code>;</code>，则含有一个隐式的<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%80%BC%E7%B1%BB%E5%9E%8B">单值（unit）<code>()</code></a>。同样，如果表达式块为空，那么也存在隐式的单值 <code>()</code>。</p>
<pre><code class="language-move">// 两者是等价的
{ x = x + 1; 1 / x; }
{ x = x + 1; 1 / x; () }
</code></pre>
<pre><code class="language-move">// 两者是等价的
{ }
{ () }
</code></pre>
<p>An expression block is itself an expression and can be used anyplace an expression is used. (Note:
The body of a function is also an expression block, but the function body cannot be replaced by
another expression.)</p>
<p>表达式块本身就是一个表达式，可以在任何使用表达式的地方使用。（注意：函数体也是一个表达式块，但函数体不能被另一个表达式替换。）</p>
<pre><code class="language-move">let my_vector: vector&lt;vector&lt;u8&gt;&gt; = {
    let v = vector::empty();
    vector::push_back(&amp;mut v, b&quot;hello&quot;);
    vector::push_back(&amp;mut v, b&quot;goodbye&quot;);
    v
};
</code></pre>
<p>(The type annotation is not needed in this example and only added for clarity.)</p>
<p>（此示例中不需要类型标注，只是为了清楚起见而添加。）</p>
<h3 id="遮蔽shadowing"><a class="header" href="#遮蔽shadowing">遮蔽（Shadowing）</a></h3>
<p>If a <code>let</code> introduces a local variable with a name already in scope, that previous variable can no
longer be accessed for the rest of this scope. This is called <em>shadowing</em>.</p>
<p>如果一个 <code>let</code> 引入了一个名称已经在作用域中的局部变量，则该作用域的剩余部分将无法再访问先前的变量。这称为<em>遮蔽（shadowing）</em>。</p>
<pre><code class="language-move">let x = 0;
assert!(x == 0, 42);

let x = 1; // x 被遮蔽了
assert!(x == 1, 42);
</code></pre>
<p>When a local is shadowed, it does not need to retain the same type as before.</p>
<p>当局部变量被遮蔽时，它不需要保留与以前相同的类型。</p>
<pre><code class="language-move">let x = 0;
assert!(x == 0, 42);

let x = b&quot;hello&quot;; // x 被遮蔽了
assert!(x == b&quot;hello&quot;, 42);
</code></pre>
<p>After a local is shadowed, the value stored in the local still exists, but will no longer be
accessible. This is important to keep in mind with values of types without the
<a href="abilities.html"><code>drop</code> ability</a>, as ownership of the value must be transferred by the end of the
function.</p>
<p>在局部变量被遮蔽后，存储在局部变量的值仍然存在，但是将不再可访问。对于没有 <a href="abilities.html"><code>drop</code> 能力</a>的类型的值，请记住这一点很重要，因为值的所有权必须在函数结束时转移。</p>
<pre><code class="language-move">address 0x42 {
    module example {
        struct Coin has store { value: u64 }

        fun unused_resource(): Coin {
            let x = Coin { value: 0 }; // ERROR!
//              ^ This local still contains a value without the `drop` ability（这个局部变量仍然包含一个没有 `drop` 能力的值）
            x.value = 1;
            let x = Coin { value: 10 };
            x
//          ^ Invalid return（无效的返回）
        }
    }
}
</code></pre>
<p>When a local is shadowed inside a scope, the shadowing only remains for that scope. The shadowing is
gone once that scope ends.</p>
<p>当局部变量在作用域内被遮蔽时，该遮蔽作用仅保留在该作用域内。一旦该作用域结束，遮蔽作用就消失了。</p>
<pre><code class="language-move">let x = 0;
{
    let x = 1;
    assert!(x == 1, 42);
};
assert!(x == 0, 42);
</code></pre>
<p>Remember, locals can change type when they are shadowed.</p>
<p>请记住，局部变量在被遮蔽时可以更改类型。</p>
<pre><code class="language-move">let x = 0;
{
    let x = b&quot;hello&quot;;
    assert!(x = b&quot;hello&quot;, 42);
};
assert!(x == 0, 42);
</code></pre>
<h2 id="移动和复制move-and-copy"><a class="header" href="#移动和复制move-and-copy">移动和复制（Move and Copy）</a></h2>
<p>All local variables in Move can be used in two ways, either by <code>move</code> or <code>copy</code>. If one or the other
is not specified, the Move compiler is able to infer whether a <code>copy</code> or a <code>move</code> should be used.
This means that in all of the examples above, a <code>move</code> or a <code>copy</code> would be inserted by the
compiler. A local variable cannot be used without the use of <code>move</code> or <code>copy</code>.</p>
<p><code>copy</code> will likely feel the most familiar coming from other programming languages, as it creates a
new copy of the value inside of the variable to use in that expression. With <code>copy</code>, the local
variable can be used more than once.</p>
<p>Move 中的所有局部变量都可以通过两种方式使用，通过 <code>move</code> 或 <code>copy</code>。如果未指定其中之一，则 Move 编译器能够推断应该使用 <code>copy</code> 还是 <code>move</code>。这意味着在上述所有示例中，编译器将插入 <code>move</code> 或 <code>copy</code>。如果不使用 <code>move</code> 或 <code>copy</code>，就不能使用局部变量。</p>
<p><code>copy</code> 对来自其他编程语言的开发者来说可能会觉得最熟悉，因为它会在变量内部创建一个新的副本值以在该表达式中使用。使用 <code>copy</code>，局部变量可以被多次使用。</p>
<pre><code class="language-move">let x = 0;
let y = copy x + 1;
let z = copy x + 2;
</code></pre>
<p>Any value with the <code>copy</code> <a href="abilities.html">ability</a> can be copied in this way.</p>
<p><code>move</code> takes the value out of the local variable <em>without</em> copying the data. After a <code>move</code> occurs,
the local variable is unavailable.</p>
<p>任何具有 <code>copy</code> <a href="abilities.html">能力</a>的值都可以通过这种方式复制。</p>
<p><code>move</code> 从局部变量中取出值<em>而不是</em>复制数据。<code>移动（move）</code>发生后，局部变量将不可用。</p>
<pre><code class="language-move">let x = 1;
let y = move x + 1;
//      ------ Local was moved here（局部变量被移动到这里了）
let z = move x + 2; // 错误！
//      ^^^^^^ Invalid usage of local 'x'（局部变量“x”的无效使用方式）
y + z
</code></pre>
<h3 id="安全性safety"><a class="header" href="#安全性safety">安全性（Safety）</a></h3>
<p>Move's type system will prevent a value from being used after it is moved. This is the same safety
check described in <a href="#let-bindings"><code>let</code> declaration</a> that prevents local variables from being used
before it is assigned a value.</p>
<p>Move 的类型系统会阻止一个值在移动后被使用。这与 <a href="#let-%E7%BB%91%E5%AE%9Alet-bindings"><code>let</code> 声明</a>中描述的防止在局部变量被赋值之前使用的安全检查相同。</p>
<!-- For more information, see TODO future section on ownership and move semantics. -->
<!-- 如了解更多信息, 参阅未来所有权和移动语义的部分 (TODO )。 -->
<h3 id="推断inference"><a class="header" href="#推断inference">推断（Inference）</a></h3>
<p>As mentioned above, the Move compiler will infer a <code>copy</code> or <code>move</code> if one is not indicated. The
algorithm for doing so is quite simple:</p>
<ul>
<li>Any scalar value with the <code>copy</code> <a href="abilities.html">ability</a> is given a <code>copy</code>.</li>
<li>Any reference (both mutable <code>&amp;mut</code> and immutable <code>&amp;</code>) is given a <code>copy</code>.
<ul>
<li>Except under special circumstances where it is made a <code>move</code> for predictable borrow checker errors.</li>
</ul>
</li>
<li>Any other value is given a <code>move</code>.
<ul>
<li>This means that even though other values might be have the <code>copy</code> <a href="abilities.html">ability</a>, it must be done <em>explicitly</em> by the programmer.</li>
<li>This is to prevent accidental copies of large data structures.</li>
</ul>
</li>
</ul>
<p>如上所述，如果未指明，Move 编译器将推断出 <code>copy</code> 还是 <code>move</code>。这样做的算法非常简单：</p>
<ul>
<li>任何带有 <code>copy</code> <a href="abilities.html">能力</a>的标量值都被赋予了 <code>copy</code>。</li>
<li>任何引用（可变的 <code>&amp;mut</code> 和不可变的 <code>&amp;</code>）都被赋予 <code>copy</code>。
<ul>
<li>除非在可预测的借用检查器错误的特殊情况下，会进行 <code>move</code> 操作。</li>
</ul>
</li>
<li>任何其他值都被赋予 <code>move</code>。
<ul>
<li>这意味着即使其他值可能具有 <code>copy</code> <a href="abilities.html">能力</a>，它也必须由程序员<em>显式</em>声明。</li>
<li>这是为了防止意外地复制很大的数据结构。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<pre><code class="language-move">let s = b&quot;hello&quot;;
let foo = Foo { f: 0 };
let coin = Coin { value: 0 };

let s2 = s; // 移动
let foo2 = foo; // 移动
let coin2 = coin; // 移动

let x = 0;
let b = false;
let addr = @0x42;
let x_ref = &amp;x;
let coin_ref = &amp;mut coin2;

let x2 = x; // 复制
let b2 = b; // 复制
let addr2 = @0x42; // 复制
let x_ref2 = x_ref; // 复制
let coin_ref2 = coin_ref; // 复制
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="tuples.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="equality.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="tuples.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="equality.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>

        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->


        <script type="text/javascript">
        var langs = [
            'en',
            'zh'
        ];

        (function langs() {
            var html = document.querySelector('html');
            var langToggleButton = document.getElementById('lang-toggle');
            var langPopup = document.getElementById('lang-list');

            function showLangs() {
                langPopup.style.display = 'block';
                langToggleButton.setAttribute('aria-expanded', true);
            }

            function hideLangs() {
                langPopup.style.display = 'none';
                langToggleButton.setAttribute('aria-expanded', false);
                langToggleButton.focus();
            }

            langToggleButton.addEventListener('click', function () {
                if (langPopup.style.display === 'block') {
                    hideLangs();
                } else {
                    showLangs();
                }
            });

            langPopup.addEventListener('click', function (e) {
                var lang = e.target.id || e.target.parentElement.id;
                window.location.pathname = window.location.pathname
                    .split('/')
                    .map((s, idx) => {
                        return idx == 2 ? lang : s;
                    })
                    .join('/');
            });

            langPopup.addEventListener('focusout', function(e) {
                // e.relatedTarget is null in Safari and Firefox on macOS (see workaround below)
                if (!!e.relatedTarget && !langToggleButton.contains(e.relatedTarget) && !langPopup.contains(e.relatedTarget)) {
                    hideLangs();
                }
            });

            // Should not be needed, but it works around an issue on macOS & iOS: https://github.com/rust-lang-nursery/mdBook/issues/628
            document.addEventListener('click', function(e) {
                if (langPopup.style.display === 'block' && !langToggleButton.contains(e.target) && !langPopup.contains(e.target)) {
                    hideLangs();
                }
            });

        })();
        </script>


    </body>
</html>