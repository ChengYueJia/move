<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>类型能力（Type Abilities） - 《Move Book 中文版》</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">引言（Introduction）</a></li><li class="chapter-item expanded "><a href="modules-and-scripts.html"><strong aria-hidden="true">1.</strong> 模块和脚本（Modules and Scripts）</a></li><li class="chapter-item expanded "><a href="move-tutorial.html"><strong aria-hidden="true">2.</strong> Move 教程（Move Tutorial）</a></li><li class="chapter-item expanded "><a href="integers.html"><strong aria-hidden="true">3.</strong> 整数（Integers）</a></li><li class="chapter-item expanded "><a href="bool.html"><strong aria-hidden="true">4.</strong> 布尔类型（Bool）</a></li><li class="chapter-item expanded "><a href="address.html"><strong aria-hidden="true">5.</strong> 地址（Address）</a></li><li class="chapter-item expanded "><a href="vector.html"><strong aria-hidden="true">6.</strong> 向量（Vector）</a></li><li class="chapter-item expanded "><a href="signer.html"><strong aria-hidden="true">7.</strong> 签名（Signer）</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">8.</strong> 引用（References）</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">9.</strong> 元组和单值（Tuples and Unit）</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">10.</strong> 局部变量和作用域（Local Variables and Scopes）</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">11.</strong> 等式（Equality）</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">12.</strong> 中止和断言（Abort and Assert）</a></li><li class="chapter-item expanded "><a href="conditionals.html"><strong aria-hidden="true">13.</strong> 条件语句（Conditionals）</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">14.</strong> 循环（While and Loop）</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">15.</strong> 函数（Functions）</a></li><li class="chapter-item expanded "><a href="structs-and-resources.html"><strong aria-hidden="true">16.</strong> 结构体和资源（Structs and Resources）</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">17.</strong> 常量（Constants）</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">18.</strong> 泛型（Generics）</a></li><li class="chapter-item expanded "><a href="abilities.html" class="active"><strong aria-hidden="true">19.</strong> 类型能力（Type Abilities）</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">20.</strong> 导入和别名（Uses and Aliases）</a></li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">21.</strong> 友元函数（Friends）</a></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">22.</strong> 程序包（Packages）</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">23.</strong> 单元测试（Unit Tests）</a></li><li class="chapter-item expanded "><a href="global-storage-structure.html"><strong aria-hidden="true">24.</strong> 全局存储结构（Global Storage Structure）</a></li><li class="chapter-item expanded "><a href="global-storage-operators.html"><strong aria-hidden="true">25.</strong> 全局存储操作（Global Storage Operators）</a></li><li class="chapter-item expanded "><a href="standard-library.html"><strong aria-hidden="true">26.</strong> 标准库（Standard Library）</a></li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">27.</strong> Move 编码约定（Coding Conventions）</a></li><li class="chapter-item expanded "><a href="contribute.html"><strong aria-hidden="true">28.</strong> 中文版贡献指南</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">《Move Book 中文版》</h1>

                    <div class="right-buttons">
                        <button id="lang-toggle" class="icon-button" type="button" title="Change language" aria-label="Change language" aria-haspopup="true" aria-expanded="false" aria-controls="lang-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="lang-list" class="theme-popup" style="left: auto;" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="en">English</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="zh">Chinese</button></li>
                        </ul>
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="能力-abilities"><a class="header" href="#能力-abilities">能力 (abilities)</a></h1>
<p>Abilities are a typing feature in Move that control what actions are permissible for values of a given type. This system grants fine grained control over the &quot;linear&quot; typing behavior of values, as well as if and how values are used in global storage. This is implemented by gating access to certain bytecode instructions so that for a value to be used with the bytecode instruction, it must have the ability required (if one is required at all—not every instruction is gated by an ability).</p>
<p>能力是 Move 语言中的一种类型特性，用于控制对给定类型的值允许哪些操作。 该系统对值的“线性”类型行为以及值如何在全局存储中使用提供细粒度控制。这是通过对某些字节码指令的进行访问控制来实现的，因此对于要与字节码指令一起使用的值，它必须具有所需的能力(如果需要的话，并非每条指令都由能力控制)</p>
<h2 id="四种能力-the-four-abilities"><a class="header" href="#四种能力-the-four-abilities">四种能力 (The Four Abilities)</a></h2>
<p>The four abilities are:</p>
<ul>
<li><a href="#copy"><code>copy</code></a>
<ul>
<li>Allows values of types with this ability to be copied.</li>
</ul>
</li>
<li><a href="#drop"><code>drop</code></a>
<ul>
<li>Allows values of types with this ability to be popped/dropped.</li>
</ul>
</li>
<li><a href="#store"><code>store</code></a>
<ul>
<li>Allows values of types with this ability to exist inside a struct in global storage.</li>
</ul>
</li>
<li><a href="#key"><code>key</code></a>
<ul>
<li>Allows the type to serve as a key for global storage operations.</li>
</ul>
</li>
</ul>
<p>这四种能力分别是：</p>
<ul>
<li>
<p><a href="#copy"><code>copy</code></a> 复制</p>
<ul>
<li>允许此类型的值被复制</li>
</ul>
</li>
<li>
<p><a href="#drop"><code>drop</code></a> 丢弃</p>
<ul>
<li>允许此类型的值被弹出/丢弃</li>
</ul>
</li>
<li>
<p><a href="#store"><code>store</code></a> 存储</p>
<ul>
<li>允许此类型的值存在于全局存储的某个结构体中</li>
</ul>
</li>
<li>
<p><a href="#key"><code>key</code></a> 键值</p>
<ul>
<li>允许此类型作为全局存储中的键(具有 <code>key</code> 能力的类型才能保存到全局存储中)</li>
</ul>
</li>
</ul>
<h3 id="copy"><a class="header" href="#copy"><code>copy</code></a></h3>
<p>The <code>copy</code> ability allows values of types with that ability to be copied. It gates the ability to copy values out of local variables with the <a href="./variables.html#move-and-copy"><code>copy</code></a> operator and to copy values via references with <a href="./references.html#%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5">dereference <code>*e</code></a>.</p>
<p>If a value has <code>copy</code>, all values contained inside of that value have <code>copy</code>.</p>
<p><code>copy</code> 能力允许具有此能力的类型的值被复制。 它限制了从本地变量通过 <a href="./variables.html#.move-and-copy"><code>copy</code></a>能力复制值以及通过 <a href="./references.html#%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5"><code>dereference *e</code></a>复制值这两种情况之外的复制操作。</p>
<p>如果一个值具有 <code>copy</code> 能力，那么这个值内部的所有值都有 <code>copy</code> 能力。</p>
<h3 id="drop"><a class="header" href="#drop"><code>drop</code></a></h3>
<p>The <code>drop</code> ability allows values of types with that ability to be dropped. By dropped, we mean that value is not transferred and is effectively destroyed as the Move program executes. As such, this ability gates the ability to ignore values in a multitude of locations, including:</p>
<ul>
<li>not using the value in a local variable or parameter</li>
<li>not using the value in a <a href="./variables.html#expression-blocks">sequence via <code>;</code></a></li>
<li>overwriting values in variables in <a href="./variables.html#assignments">assignments</a></li>
<li>overwriting values via references when <a href="./references.html#reading-and-writing-through-references">writing <code>*e1 = e2</code></a>.</li>
</ul>
<p>If a value has <code>drop</code>, all values contained inside of that value have <code>drop</code>.</p>
<p><code>drop</code> 能力允许类型的值被丢弃。丢弃的意思程序执行后值会被有效的销毁而不必被转移。因此，这个能力限制在多个位置忽略使用值的可能性，包括：</p>
<ul>
<li>未被使用的局部变量或者参数</li>
<li>未被使用的 <a href="./variables.html#expression-blocks"><code>sequence</code> via <code>;</code></a>中的值</li>
<li>覆盖<a href="./variables.html#assignments">赋值(assignments)</a>变量中的值</li>
<li><a href="https://move-language.github.io/move/references.html#reading-and-writing-through-references">写入(writing) <code>*e1 = e2</code></a> 时通过引用覆盖的值。</li>
</ul>
<p>如果一个值具有 <code>drop</code> 能力，那么这个值内部的所有值都有 <code>drop</code> 能力。</p>
<h3 id="store"><a class="header" href="#store"><code>store</code></a></h3>
<p>The <code>store</code> ability allows values of types with this ability to exist inside of a struct (resource) in global storage, <em>but</em> not necessarily as a top-level resource in global storage. This is the only ability that does not directly gate an operation. Instead it gates the existence in global storage when used in tandem with <code>key</code>.</p>
<p>If a value has <code>store</code>, all values contained inside of that value have <code>store</code></p>
<p><code>store</code> 能力允许具有这种能力的类型的值位于<a href="./global-storage-operators.html">全局存储</a>中的结构体(资源)内, <em>但不一定是</em> 全局存储中的顶级资源。这是唯一不直接限制操作的能力。相反，当(<code>store</code>)与 <code>key</code> 一起使用时，它对全局存储中的可行性进行把关。。</p>
<p>如果一个值具有 <code>store</code> 能力，那么这个值内部的所有值都有 <code>store</code> 能力。</p>
<h3 id="key"><a class="header" href="#key"><code>key</code></a></h3>
<p>The <code>key</code> ability allows the type to serve as a key for <a href="./global-storage-operators.html">global storage operations</a>. It gates all global storage operations, so in order for a type to be used with <code>move_to</code>, <code>borrow_global</code>, <code>move_from</code>, etc., the type must have the <code>key</code> ability. Note that the operations still must be used in the module where the <code>key</code> type is defined (in a sense, the operations are private to the defining module).</p>
<p>If a value has <code>key</code>, all values contained inside of that value have <code>store</code>. This is the only ability with this sort of asymmetry.</p>
<p><code>key</code> 能力允许此类型作为<a href="./global-storage-operators.html">全局存储</a>中的键。它会限制所有<a href="./global-storage-operators.html">全局存储</a>中的操作，因此一个类型如果与 <code>move_to</code>, <code>borrow_global</code>, <code>move_from</code> 等一起使用，那么这个类型必须具备 <code>key</code> 能力。请注意，这些操作仍然必须在定义 <code>key</code> 类型的模块中使用(从某种意义上说，这些操作是此模块的私有操作)。</p>
<p>如果有一个值有 <code>key</code> 能力，那么这个值包含的所有字段值也都具有 <code>store</code> 能力，<code>key</code> 能力是唯一一个具有非对称的能力。</p>
<h2 id="builtin-types-内置类型"><a class="header" href="#builtin-types-内置类型">Builtin Types (内置类型)</a></h2>
<p>Most primitive, builtin types have <code>copy</code>, <code>drop</code>, and <code>store</code> with the exception of <code>signer</code>, which just has <code>store</code></p>
<ul>
<li><code>bool</code>, <code>u8</code>, <code>u64</code>, <code>u128</code>, and <code>address</code> all have <code>copy</code>, <code>drop</code>, and <code>store</code>.</li>
<li><code>signer</code> has <code>drop</code>
<ul>
<li>Cannot be copied and cannot be put into global storage</li>
</ul>
</li>
<li><code>vector&lt;T&gt;</code> may have <code>copy</code>, <code>drop</code>, and <code>store</code> depending on the abilities of <code>T</code>.
<ul>
<li>See <a href="#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a> for more details.</li>
</ul>
</li>
<li>Immutable references <code>&amp;</code> and mutable references <code>&amp;mut</code> both have <code>copy</code> and <code>drop</code>.
<ul>
<li>This refers to copying and dropping the reference itself, not what they refer to.</li>
<li>References cannot appear in global storage, hence they do not have <code>store</code>.</li>
</ul>
</li>
</ul>
<p>None of the primitive types have <code>key</code>, meaning none of them can be used directly with the <a href="./global-storage-operators.html">global storage operations</a>.</p>
<p>几乎所有内置的基本类型具都有 <code>copy</code>，<code>drop</code>，以及 <code>store</code> 能力，<code>singer</code> 除外，它只有 <code>drop</code> 能力(原文是 <code>store</code> 有误，译者注)</p>
<ul>
<li><code>bool</code>, <code>u8</code>, <code>u64</code>, <code>u128</code>, <code>address</code> 都具有 <code>copy</code>, <code>drop</code>, 以及 <code>store</code> 能力。</li>
<li><code>signer</code> 具有 <code>drop</code> 能力。 不能被复制以及不能被存放在全局存储中</li>
<li><code>vector&lt;T&gt;</code> 可能具有 <code>copy</code>，<code>drop</code>，以及<code>store</code> 能力，这依赖于 <code>T</code> 具有的能力。 查看 <a href="#conditional-abilities-and-generic-types">条件能力与泛型类型</a>获取详情</li>
<li>不可变引用 <code>&amp;</code> 和可变引用 <code>&amp;mut</code> 都具有 <code>copy</code> 和 <code>drop</code> 能力。
<ul>
<li>这是指复制和删除引用本身，而不是它们所引用的内容。</li>
<li>引用不能出现在全局存储中，因此它们没有 <code>store</code> 能力。</li>
</ul>
</li>
</ul>
<p>所有基本类型都没有 <code>key</code>，这意味着它们都不能直接用于<a href="./global-storage-operators.html">全局存储操作</a>。</p>
<h2 id="annotating-structs-标注结构体"><a class="header" href="#annotating-structs-标注结构体">Annotating Structs (标注结构体)</a></h2>
<p>To declare that a <code>struct</code> has an ability, it is declared with <code>has &lt;ability&gt;</code> after the struct name but before the fields. For example:</p>
<p>要声明一个 <code>struct</code> 具有某个能力，它在结构体名称之后, 在字段之前用 <code>has &lt;ability&gt;</code> 声明。例如：</p>
<pre><code class="language-move">struct Ignorable has drop { f: u64 }
struct Pair has copy, drop, store { x: u64, y: u64 }
</code></pre>
<p>In this case: <code>Ignorable</code> has the <code>drop</code> ability. <code>Pair</code> has <code>copy</code>, <code>drop</code>, and <code>store</code>.</p>
<p>在这个例子中：<code>Ignorable</code> 具有 <code>drop</code> 能力。 <code>Pair</code> 具有 <code>copy</code>、<code>drop</code> 和 <code>store</code> 能力。</p>
<p>All of these abilities have strong guarantees over these gated operations. The operation can be performed on the value only if it has that ability; even if the value is deeply nested inside of some other collection!</p>
<p>所有这些能力对这些访问操作都有强有力的保证。只有具有该能力，才能对值执行对应的操作；即使该值深层嵌套在其他集合中！</p>
<p>As such: when declaring a struct’s abilities, certain requirements are placed on the fields. All fields must satisfy these constraints. These rules are necessary so that structs satisfy the reachability rules for the abilities given above. If a struct is declared with the ability...</p>
<ul>
<li><code>copy</code>, all fields must have <code>copy</code>.</li>
<li><code>drop</code>, all fields must have <code>drop</code>.</li>
<li><code>store</code>, all fields must have <code>store</code>.</li>
<li><code>key</code>, all fields must have <code>store</code>.
<ul>
<li><code>key</code> is the only ability currently that doesn’t require itself.</li>
</ul>
</li>
</ul>
<p>因此：在声明结构体的能力时，对字段提出了某些要求。所有字段都必须满足这些约束。这些规则是必要的，以便结构体满足上述功能的可达性规则。如果一个结构被声明为具有某能力：</p>
<ul>
<li><code>copy</code>， 所有的字段必须具有 <code>copy</code> 能力。</li>
<li><code>drop</code>，所有的字段必须具有 <code>drop</code> 能力。</li>
<li><code>store</code>，所有的字段必须具有 <code>store</code> 能力。</li>
<li><code>key</code>，所有的字段必须具有 <code>store</code> 能力。<code>key</code> 是目前唯一不需要包含自身的能力。</li>
</ul>
<p>例如:</p>
<pre><code class="language-move">// A struct without any abilities
struct NoAbilities {}

struct WantsCopy has copy {
    f: NoAbilities, // ERROR 'NoAbilities' does not have 'copy'
}
</code></pre>
<p>and similarly:</p>
<p>类似的：</p>
<pre><code class="language-move">// A struct without any abilities
struct NoAbilities {}

struct MyResource has key {
    f: NoAbilities, // Error 'NoAbilities' does not have 'store'
}
</code></pre>
<h2 id="conditional-abilities-and-generic-types-条件能力与泛型类型"><a class="header" href="#conditional-abilities-and-generic-types-条件能力与泛型类型">Conditional Abilities and Generic Types (条件能力与泛型类型)</a></h2>
<p>When abilities are annotated on a generic type, not all instances of that type are guaranteed to have that ability. Consider this struct declaration:</p>
<p>在泛型类型上标注能力时，并非该类型的所有实例都保证具有该能力。考虑这个结构体声明：</p>
<pre><code class="language-move">struct Cup&lt;T&gt; has copy, drop, store, key { item: T }
</code></pre>
<p>It might be very helpful if <code>Cup</code> could hold any type, regardless of its abilities. The type system can <em>see</em> the type parameter, so it should be able to remove abilities from <code>Cup</code> if it <em>sees</em> a type parameter that would violate the guarantees for that ability.</p>
<p>This behavior might sound a bit confusing at first, but it might be more understandable if we think about collection types. We could consider the builtin type <code>vector</code> to have the following type declaration:</p>
<p>如果 <code>Cup</code> 可以容纳任何类型，可能会很有帮助，不管它的能力如何。类型系统可以 <em>看到</em> 类型参数，因此，如果它 <em>发现</em> 一个类型参数违反了对该能力的保证，它应该能够从 <code>Cup</code> 中删除能力。</p>
<p>这种行为一开始可能听起来有点令人困惑，但如果我们考虑一下集合类型，它可能会更容易理解。我们可以认为内置类型 <code>Vector</code> 具有以下类型声明：</p>
<pre><code class="language-move">vector&lt;T&gt; has copy, drop, store;
</code></pre>
<p>We want <code>vector</code>s to work with any type. We don't want separate <code>vector</code> types for different abilities. So what are the rules we would want? Precisely the same that we would want with the field rules above.  So, it would be safe to copy a <code>vector</code> value only if the inner elements can be copied. It would be safe to ignore a <code>vector</code> value only if the inner elements can be ignored/dropped. And, it would be safe to put a <code>vector</code> in global storage only if the inner elements can be in global storage.</p>
<p>To have this extra expressiveness, a type might not have all the abilities it was declared with depending on the instantiation of that type; instead, the abilities a type will have depends on both its declaration <strong>and</strong> its type arguments. For any type, type parameters are pessimistically assumed to be used inside of the struct, so the abilities are only granted if the type parameters meet the requirements described above for fields. Taking <code>Cup</code> from above as an example:</p>
<ul>
<li><code>Cup</code> has the ability <code>copy</code> only if <code>T</code> has <code>copy</code>.</li>
<li>It has <code>drop</code> only if <code>T</code> has <code>drop</code>.</li>
<li>It has <code>store</code> only if <code>T</code> has <code>store</code>.</li>
<li>It has <code>key</code> only if <code>T</code> has <code>store</code>.</li>
</ul>
<p>我们希望 <code>vector</code> 适用于任何类型。我们不希望针对不同的能力使用不同的 <code>vector</code> 类型。那么我们想要的规则是什么？与上面的字段规则完全相同。因此，仅当可以复制内部元素时，复制<code>vector</code> 值才是安全的。仅当可以忽略/丢弃内部元素时，忽略 <code>vector</code> 值才是安全的。而且，仅当内部元素可以在全局存储中时，将向量放入全局存储中才是安全的。</p>
<p>为了具有这种额外的表现力，一个类型可能不具备它声明的所有能力，具体取决于该类型的实例化；相反，一个类型的能力取决于它的声明 <strong>和</strong> 它的类型参数。对于任何类型，类型参数都被悲观地假定为在结构体内部使用，因此只有在类型参数满足上述字段要求时才授予这些能力。以上面的 <code>Cup</code> 为例：</p>
<ul>
<li><code>Cup</code> 拥有 <code>copy</code> 能力 仅当 <code>T</code> 拥有 <code>copy</code> 能力时。</li>
<li><code>Cup</code> 拥有 <code>drop</code> 能力 仅当 <code>T</code> 拥有 <code>drop</code> 能力时。</li>
<li><code>Cup</code> 拥有 <code>store</code> 能力 仅当 <code>T</code> 拥有 <code>store</code> 能力时。</li>
<li><code>Cup</code> 拥有 <code>key</code> 能力 仅当 <code>T</code> 拥有 <code>store</code> 能力时。</li>
</ul>
<p>Here are examples for this conditional system for each ability:</p>
<p>以下是每个能力的条件系统的示例：</p>
<h3 id="example-conditional-copy"><a class="header" href="#example-conditional-copy">Example: conditional <code>copy</code></a></h3>
<pre><code class="language-move">struct NoAbilities {}
struct S has copy, drop { f: bool }
struct Cup&lt;T&gt; has copy, drop, store { item: T }

fun example(c_x: Cup&lt;u64&gt;, c_s: Cup&lt;S&gt;) {
    // Valid, 'Cup&lt;u64&gt;' has 'copy' because 'u64' has 'copy'
    let c_x2 = copy c_x;
    // Valid, 'Cup&lt;S&gt;' has 'copy' because 'S' has 'copy'
    let c_s2 = copy c_s;
}

fun invalid(c_account: Cup&lt;signer&gt;, c_n: Cup&lt;NoAbilities&gt;) {
    // Invalid, 'Cup&lt;signer&gt;' does not have 'copy'.
    // Even though 'Cup' was declared with copy, the instance does not have 'copy'
    // because 'signer' does not have 'copy'
    let c_account2 = copy c_account;
    // Invalid, 'Cup&lt;NoAbilities&gt;' does not have 'copy'
    // because 'NoAbilities' does not have 'copy'
    let c_n2 = copy c_n;
}
</code></pre>
<h3 id="example-conditional-drop"><a class="header" href="#example-conditional-drop">Example: conditional <code>drop</code></a></h3>
<pre><code class="language-move">struct NoAbilities {}
struct S has copy, drop { f: bool }
struct Cup&lt;T&gt; has copy, drop, store { item: T }

fun unused() {
    Cup&lt;bool&gt; { item: true }; // Valid, 'Cup&lt;bool&gt;' has 'drop'
    Cup&lt;S&gt; { item: S { f: false }}; // Valid, 'Cup&lt;S&gt;' has 'drop'
}

fun left_in_local(c_account: Cup&lt;signer&gt;): u64 {
    let c_b = Cup&lt;bool&gt; { item: true };
    let c_s = Cup&lt;S&gt; { item: S { f: false }};
    // Valid return: 'c_account', 'c_b', and 'c_s' have values
    // but 'Cup&lt;signer&gt;', 'Cup&lt;bool&gt;', and 'Cup&lt;S&gt;' have 'drop'
    0
}

fun invalid_unused() {
    // Invalid, Cannot ignore 'Cup&lt;NoAbilities&gt;' because it does not have 'drop'.
    // Even though 'Cup' was declared with 'drop', the instance does not have 'drop'
    // because 'NoAbilities' does not have 'drop'
    Cup&lt;NoAbilities&gt; { item: NoAbilities {}};
}

fun invalid_left_in_local(): u64 {
    let n = Cup&lt;NoAbilities&gt; { item: NoAbilities {}};
    // Invalid return: 'c_n' has a value
    // and 'Cup&lt;NoAbilities&gt;' does not have 'drop'
    0
}
</code></pre>
<h3 id="example-conditional-store"><a class="header" href="#example-conditional-store">Example: conditional <code>store</code></a></h3>
<pre><code class="language-move">struct Cup&lt;T&gt; has copy, drop, store { item: T }

// 'MyInnerResource' is declared with 'store' so all fields need 'store'
struct MyInnerResource has store {
    yes: Cup&lt;u64&gt;, // Valid, 'Cup&lt;u64&gt;' has 'store'
    // no: Cup&lt;signer&gt;, Invalid, 'Cup&lt;signer&gt;' does not have 'store'
}

// 'MyResource' is declared with 'key' so all fields need 'store'
struct MyResource has key {
    yes: Cup&lt;u64&gt;, // Valid, 'Cup&lt;u64&gt;' has 'store'
    inner: Cup&lt;MyInnerResource&gt;, // Valid, 'Cup&lt;MyInnerResource&gt;' has 'store'
    // no: Cup&lt;signer&gt;, Invalid, 'Cup&lt;signer&gt;' does not have 'store'
}
</code></pre>
<h3 id="example-conditional-key"><a class="header" href="#example-conditional-key">Example: conditional <code>key</code></a></h3>
<pre><code class="language-move">struct NoAbilities {}
struct MyResource&lt;T&gt; has key { f: T }

fun valid(account: &amp;signer) acquires MyResource {
    let addr = signer::address_of(account);
     // Valid, 'MyResource&lt;u64&gt;' has 'key'
    let has_resource = exists&lt;MyResource&lt;u64&gt;&gt;(addr);
    if (!has_resource) {
         // Valid, 'MyResource&lt;u64&gt;' has 'key'
        move_to(account, MyResource&lt;u64&gt; { f: 0 })
    };
    // Valid, 'MyResource&lt;u64&gt;' has 'key'
    let r = borrow_global_mut&lt;MyResource&lt;u64&gt;&gt;(addr)
    r.f = r.f + 1;
}

fun invalid(account: &amp;signer) {
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   let has_it = exists&lt;MyResource&lt;NoAbilities&gt;&gt;(addr);
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   let NoAbilities {} = move_from&lt;NoAbilities&gt;(addr);
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   move_to(account, NoAbilities {});
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   borrow_global&lt;NoAbilities&gt;(addr);
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="uses.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="uses.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>

        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->


        <script type="text/javascript">
        var langs = [
            'en',
            'zh'
        ];

        (function langs() {
            var html = document.querySelector('html');
            var langToggleButton = document.getElementById('lang-toggle');
            var langPopup = document.getElementById('lang-list');

            function showLangs() {
                langPopup.style.display = 'block';
                langToggleButton.setAttribute('aria-expanded', true);
            }

            function hideLangs() {
                langPopup.style.display = 'none';
                langToggleButton.setAttribute('aria-expanded', false);
                langToggleButton.focus();
            }

            langToggleButton.addEventListener('click', function () {
                if (langPopup.style.display === 'block') {
                    hideLangs();
                } else {
                    showLangs();
                }
            });

            langPopup.addEventListener('click', function (e) {
                var lang = e.target.id || e.target.parentElement.id;
                window.location.pathname = window.location.pathname
                    .split('/')
                    .map((s, idx) => {
                        return idx == 2 ? lang : s;
                    })
                    .join('/');
            });

            langPopup.addEventListener('focusout', function(e) {
                // e.relatedTarget is null in Safari and Firefox on macOS (see workaround below)
                if (!!e.relatedTarget && !langToggleButton.contains(e.relatedTarget) && !langPopup.contains(e.relatedTarget)) {
                    hideLangs();
                }
            });

            // Should not be needed, but it works around an issue on macOS & iOS: https://github.com/rust-lang-nursery/mdBook/issues/628
            document.addEventListener('click', function(e) {
                if (langPopup.style.display === 'block' && !langToggleButton.contains(e.target) && !langPopup.contains(e.target)) {
                    hideLangs();
                }
            });

        })();
        </script>


    </body>
</html>
