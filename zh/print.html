<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>《Move Book 中文版》</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">引言（Introduction）</a></li><li class="chapter-item expanded "><a href="modules-and-scripts.html"><strong aria-hidden="true">1.</strong> 模块和脚本（Modules and Scripts）</a></li><li class="chapter-item expanded "><a href="move-tutorial.html"><strong aria-hidden="true">2.</strong> Move 教程（Move Tutorial）</a></li><li class="chapter-item expanded "><a href="integers.html"><strong aria-hidden="true">3.</strong> 整数（Integers）</a></li><li class="chapter-item expanded "><a href="bool.html"><strong aria-hidden="true">4.</strong> 布尔类型（Bool）</a></li><li class="chapter-item expanded "><a href="address.html"><strong aria-hidden="true">5.</strong> 地址（Address）</a></li><li class="chapter-item expanded "><a href="vector.html"><strong aria-hidden="true">6.</strong> 向量（Vector）</a></li><li class="chapter-item expanded "><a href="signer.html"><strong aria-hidden="true">7.</strong> 签名（Signer）</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">8.</strong> 引用（References）</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">9.</strong> 元组和单值（Tuples and Unit）</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">10.</strong> 局部变量和作用域（Local Variables and Scopes）</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">11.</strong> 等式（Equality）</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">12.</strong> 中止和断言（Abort and Assert）</a></li><li class="chapter-item expanded "><a href="conditionals.html"><strong aria-hidden="true">13.</strong> 条件语句（Conditionals）</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">14.</strong> 循环（While and Loop）</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">15.</strong> 函数（Functions）</a></li><li class="chapter-item expanded "><a href="structs-and-resources.html"><strong aria-hidden="true">16.</strong> 结构体和资源（Structs and Resources）</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">17.</strong> 常量（Constants）</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">18.</strong> 泛型（Generics）</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">19.</strong> 类型能力（Type Abilities）</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">20.</strong> 导入和别名（Uses and Aliases）</a></li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">21.</strong> 友元函数（Friends）</a></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">22.</strong> 程序包（Packages）</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">23.</strong> 单元测试（Unit Tests）</a></li><li class="chapter-item expanded "><a href="global-storage-structure.html"><strong aria-hidden="true">24.</strong> 全局存储结构（Global Storage Structure）</a></li><li class="chapter-item expanded "><a href="global-storage-operators.html"><strong aria-hidden="true">25.</strong> 全局存储操作（Global Storage Operators）</a></li><li class="chapter-item expanded "><a href="standard-library.html"><strong aria-hidden="true">26.</strong> 标准库（Standard Library）</a></li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">27.</strong> Move 编码约定（Coding Conventions）</a></li><li class="chapter-item expanded "><a href="contribute.html"><strong aria-hidden="true">28.</strong> 中文版贡献指南</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">《Move Book 中文版》</h1>

                    <div class="right-buttons">
                        <button id="lang-toggle" class="icon-button" type="button" title="Change language" aria-label="Change language" aria-haspopup="true" aria-expanded="false" aria-controls="lang-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="lang-list" class="theme-popup" style="left: auto;" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="en">English</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="zh">Chinese</button></li>
                        </ul>
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="引言-introduction"><a class="header" href="#引言-introduction">引言 (Introduction)</a></h1>
<p>Welcome to Move, a next generation language for secure, sandboxed, and formally verified programming. Its first use case is for the Diem blockchain, where Move provides the foundation for its implementation. Move allows developers to write programs that flexibly manage and transfer assets, while providing the security and protections against attacks on those assets. However, Move has been developed with use cases in mind outside a blockchain context as well.</p>
<p>欢迎来到Move的世界，Move是一种安全、沙盒式和形式化验证的下一代编程语言，它的第一个用例是 Diem 区块链(当时名字叫Libra, 脸书团队开发的项目, 译者注), Move 为其实现提供了基础。 Move 允许开发人员编写灵活管理和转移数字资产的程序，同时提供安全保护，防止对那些链上资产的攻击。不仅如此，Move 也可用于区块链世界之外的开发场景。</p>
<p>Move takes its cue from <a href="https://www.rust-lang.org/">Rust</a> by using resource types with move (hence the name) semantics as an explicit representation of digital assets, such as currency.</p>
<p>Move 的诞生从<a href="https://www.rust-lang.org/">Rust</a>中吸取了灵感，Move也是因为使用具有移动(move)语义的资源类型作为数字资产(例如货币)的显式表示而得名。</p>
<h2 id="move是为谁准备的who-is-move-for"><a class="header" href="#move是为谁准备的who-is-move-for">Move是为谁准备的？(Who is Move for?)</a></h2>
<p>Move was designed and created as a secure, verified, yet flexible programming language. The first use of Move is for the implementation of the Diem blockchain. That said, the language is still evolving. Move has the potential to be a language for other blockchains, and even non-blockchain use cases as well.</p>
<p>Move语言被设计和创建为安全、可验证， 同时兼顾灵活性的编程语言。Move的第一个应用场景是用于Diem区块链的开发。现在，Move语言仍在不断发展中。Move 还有成为其他区块链，甚至非区块链用例开发语言的潜质。</p>
<p>Given custom Move modules will not be supported at the <a href="https://diem.com/white-paper/#whats-next">launch</a> of the Diem Payment Network (DPN), we are targeting an early Move Developer persona.</p>
<p>鉴于在 Diem 支付网络 (DPN) <a href="https://diem.com/white-paper/#whats-next">启动</a>时将不支持自定义 Move 模块(custom Move modules)，我们的目标是早期的 Move 开发人员。</p>
<p>The early Move Developer is one with some programming experience, who wants to begin understanding the core programming language and see examples of its usage.</p>
<p>早期的 Move 开发人员应该是具有一定编程经验的程序员，他们愿意了解编程语言核心，并探索它的用法。</p>
<h3 id="爱好者-hobbyists"><a class="header" href="#爱好者-hobbyists">爱好者 (Hobbyists)</a></h3>
<p>Understanding that the capability to create custom modules on the Diem Payment Network will not be available at launch, the hobbyist Move Developer is interested in learning the intricacies of the language. She will understand the basic syntax, the standard libraries available, and write example code that can be executed using the Move CLI. The Move Developer may even want to dig into understanding how the Move Virtual Machine executes the code she writes.</p>
<p>作为(Move语言)爱好者角色，首先需要明白在Diem支付网络上创建自定义模块(custom modules)是不可能的，其次，你还要对探索这门语言的复杂性保持兴趣。你将了解基本语法、可用的标准库，并编写可以用的Move CLI执行的示例代码。如果可能，你甚至可以去尝试体验Move虚拟机如何执行你自己编写的代码。</p>
<h3 id="核心贡献者-core-contributor"><a class="header" href="#核心贡献者-core-contributor">核心贡献者 (Core Contributor)</a></h3>
<p>Beyond a hobbyist wanting to stay ahead of the curve for the core programming language is someone who may want to <a href="https://diem.com/en-US/cla-sign/">contribute</a> directly to Move. Whether this includes submitting language improvements or even, in the future, adding core modules available on the Diem Payment Network, the core contributor will understand Move at a deep level.</p>
<p>核心贡献者指那些超越爱好者并想在核心编程语言方面保持领先，还直接为 Move 做出<a href="https://diem.com/en-US/cla-sign/">贡献</a>的人。无论是提交语言改进，甚至未来添加 Diem 支付网络上可用的核心模块等，核心贡献者都将深入了解Move。</p>
<h3 id="move不适用于哪些人who-move-is-currently-not-targeting"><a class="header" href="#move不适用于哪些人who-move-is-currently-not-targeting">Move不适用于哪些人？(Who Move is currently not targeting)</a></h3>
<p>Currently, Move is not targeting developers who wish to create custom modules and contracts for use on the Diem Payment Network. We are also not targeting novice developers who expect a completely polished developer experience even in testing the language.</p>
<p>目前，Move 并不适用那些希望在在 Diem 支付网络上创建自定义模块和合约的开发人员。我们也不针对期望在测试语言时就能获得完美开发体验的初学开发者。</p>
<h2 id="从哪里开始where-do-i-start"><a class="header" href="#从哪里开始where-do-i-start">从哪里开始？(Where Do I Start?)</a></h2>
<p>Begin with understanding <a href="https://move-language.github.io/move/modules-and-scripts.html">modules and scripts</a> and then work through the <a href="https://move-language.github.io/move/creating-coins.html">Move Tutorial</a>.</p>
<p>你可以从了解模块和脚本(<a href="./modules-and-scripts.html">modules and scripts</a>)开始，然后跟随Move教程(<a href="./move-tutorial.html">Move Tutorial</a>)进行练习。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块和脚本"><a class="header" href="#模块和脚本">模块和脚本</a></h1>
<p>Move 有两种不同类型的程序：<em><strong>模块（Module）<em><strong>和</strong></em>脚本（Script）</strong></em>。模块是定义结构类型以及对这些类型进行操作的函数的库。<em>结构类型</em>定义了 Move 的<a href="global-storage-structure.html">全局存储</a>的模式，<em>模块函数</em>定义了更新存储的规则。模块本身也存储在全局存储中。脚本是<a href="https://en.wikipedia.org/wiki/Executable">可执行文件</a>的入口点，类似于传统语言中的主函数 <code>main</code>。脚本通常调用已发布模块的函数来更新全局存储。脚本是临时代码片段，不会发布在全局存储中。</p>
<p>一个 Move 源文件（或<strong>编译单元</strong>）可能包含多个模块和脚本。然而，发布模块或执行脚本都是独立的虚拟机（VM）操作。</p>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<h3 id="脚本"><a class="header" href="#脚本">脚本</a></h3>
<p>脚本具有以下结构：</p>
<pre><code class="language-text">script {
    &lt;use&gt;*
    &lt;constants&gt;*
    fun &lt;identifier&gt;&lt;[type parameters: constraint]*&gt;([identifier: type]*) &lt;function_body&gt;
}
</code></pre>
<p>一个 <code>script</code> 块必须以它的所有 <a href="uses.html"><code>use</code></a> 声明开头，然后是<a href="constants.html">常量（constant）</a>声明，最后是主<a href="functions.html">函数</a>声明。主函数的名称可以是任意的（也就是说，它不一定命名为 <code>main</code>），它是脚本块中唯一的函数，可以有任意数量的参数，并且不能有返回值。下面是每个组件的示例：</p>
<pre><code class="language-move">script {
    // 导入在命名账户地址 std 上发布的 debug 模块。
    use std::debug;

    const ONE: u64 = 1;

    fun main(x: u64) {
        let sum = x + ONE;
        debug::print(&amp;sum)
    }
}
</code></pre>
<p>脚本（Script）的功能非常有限 —— 它们不能声明友元（friend）、结构类型或访问全局存储。他们的主要作用主要是调用<em>模块函数</em>。</p>
<h3 id="模块"><a class="header" href="#模块">模块</a></h3>
<p>模块具有以下结构：</p>
<pre><code class="language-text">module &lt;address&gt;::&lt;identifier&gt; {
    (&lt;use&gt; | &lt;friend&gt; | &lt;type&gt; | &lt;function&gt; | &lt;constant&gt;)*
}
</code></pre>
<p>其中 <code>&lt;address&gt;</code> 是一个有效的<a href="address.html">命名或字面量地址</a>。</p>
<p>例子：</p>
<pre><code class="language-move">module 0x42::test {
    struct Example has copy, drop { i: u64 }

    use std::debug;
    friend 0x42::another_test;

    const ONE: u64 = 1;

    public fun print(x: u64) {
        let sum = x + ONE;
        let example = Example { i: sum };
        debug::print(&amp;sum)
    }
}
</code></pre>
<p><code>module 0x42::test</code> 这部分指定模块 <code>test</code> 将在<a href="global-storage-structure.html">全局存储</a>的<a href="address.html">账户地址</a> <code>0x42</code> 下发布。</p>
<p>模块也可以使用<a href="address.html">命名地址</a>来声明，例如：</p>
<pre><code class="language-move">module test_addr::test {
    struct Example has copy, drop { a: address }

    use std::debug;
    friend test_addr::another_test;

    public fun print() {
        let example = Example { a: @test_addr };
        debug::print(&amp;example)
    }
}
</code></pre>
<p>因为命名地址只存在于源语言级别和编译期间，所以命名地址将在字节码级别彻底替换它们的值。例如，如果我们有以下代码：</p>
<pre><code class="language-move">script {
    fun example() {
        my_addr::m::foo(@my_addr);
    }
}
</code></pre>
<p>我们在把 <code>my_addr</code> 设置为 <code>0xC0FFEE</code> 的情况下编译它，那么它在操作上等同于以下内容：</p>
<pre><code class="language-move">script {
    fun example() {
        0xC0FFEE::m::foo(@0xC0FFEE);
    }
}
</code></pre>
<p>然而，在源代码级别，这些是<em>不等价的</em> —— 函数 <code>m::foo</code> <em>必须</em>通过 <code>my_addr</code> 命名地址来访问，而不是通过分配给该地址的数值来访问。</p>
<p>模块名称可以以字母 <code>a</code> 到 <code>z</code> 或字母 <code>A</code> 到 <code>Z</code> 开头。在第一个字符之后，模块名可以包含下划线 <code>_</code>、字母 <code>a</code> 到 <code>z</code>、字母 <code>A</code> 到 <code>Z</code> 或数字 <code>0</code> 到 <code>9</code>。</p>
<pre><code class="language-move">module my_module {}
module foo_bar_42 {}
</code></pre>
<p>通常，模块名称以小写字母开头。名为 <code>my_module</code> 的模块应该存储在名为 <code>my_module.move</code> 的源文件中。</p>
<p><code>module</code> 块内的所有元素都可以按任意顺序出现。从根本上说，模块是<a href="structs-and-resources.html"><code>类型（type）</code></a>和<a href="functions.html"><code>函数（function）</code></a>的集合。<a href="uses.html"><code>use</code></a> 关键字用来从其他模块导入类型。<a href="friends.html"><code>friend</code></a> 关键字指定一个可信的模块列表。<a href="constants.html"><code>const</code></a> 关键字定义了可以在模块函数中使用的私有常量。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-教程move-tutorial"><a class="header" href="#move-教程move-tutorial">Move 教程(Move Tutorial)</a></h1>
<p>Welcome to the Move Tutorial! In this tutorial, we are going to go through some steps of developing Move code including design, implementation, unit testing and formal verification of Move modules.</p>
<p>欢迎来到 Move 语言教程，在本教程中，我们通过一些具体的步骤进行 Move 语言代码的开发，包括 Move 模块的设计、实现、单元测试和形式化验证。</p>
<p>There are nine steps in total:</p>
<ul>
<li><a href="move-tutorial.html#Step0">Step 0: Installation</a></li>
<li><a href="move-tutorial.html#Step1">Step 1: Writing my first Move module</a></li>
<li><a href="move-tutorial.html#Step2">Step 2: Adding unit tests to my first Move module</a></li>
<li><a href="move-tutorial.html#Step3">Step 3: Designing my <code>BasicCoin</code> module</a></li>
<li><a href="move-tutorial.html#Step4">Step 4: Implementing my <code>BasicCoin</code> module</a></li>
<li><a href="move-tutorial.html#Step5">Step 5: Adding and using unit tests with the <code>BasicCoin</code> module</a></li>
<li><a href="move-tutorial.html#Step6">Step 6: Making my <code>BasicCoin</code> module generic</a></li>
<li><a href="move-tutorial.html#Step7">Step 7: Use the Move prover</a></li>
<li><a href="move-tutorial.html#Step8">Step 8: Writing formal specifications for the <code>BasicCoin</code> module</a></li>
</ul>
<p>整个过程共包含9个步骤：</p>
<ul>
<li><a href="move-tutorial.html#Step0">Step 0: 安装 Move 开发环境</a></li>
<li><a href="move-tutorial.html#Step1">Step 1: 编写第一个 Move 模块(Move Module)</a></li>
<li><a href="move-tutorial.html#Step2">Step 2: 给模块(Module)添加单元测试</a></li>
<li><a href="move-tutorial.html#Step3">Step 3: 设计自己的 <code>BasicCoin</code> 模块(Module)</a></li>
<li><a href="move-tutorial.html#Step4">Step 4: <code>BasicCoin</code> 模块(Module)的实现</a></li>
<li><a href="move-tutorial.html#Step5">Step 5: 给 <code>BasicCoin</code> 模块添加单元测试</a></li>
<li><a href="move-tutorial.html#Step6">Step 6: 使用泛型(generic)编写 <code>BasicCoin</code> 模块</a></li>
<li><a href="move-tutorial.html#Step7">Step 7: 使用 <code>Move prover</code></a></li>
<li><a href="move-tutorial.html#Step8">Step 8: 为 <code>BasicCoin</code> 模块编写形式化规范(formal specifications)</a></li>
</ul>
<p>Each step is designed to be self-contained in the corresponding <code>step_x</code> folder. For example, if you would
like to skip the contents in step 1 through 4, feel free to jump to step 5 since all the code we have written
before step 5 will be in <code>step_5</code> folder. At the end of some steps, we also include
additional material on more advanced topics.</p>
<p>其中每一步都被设计为自包含的文件夹, 相应名字为 <code>step_x</code>。 例如，如果您愿意跳过 <code>step 1</code> 到 <code>step 4</code> 的内容，可直接跳到 <code>step 5</code>，因为所有在 <code>step 5</code> 之前的代码均在在<code>step_5</code> 文件夹之下。在部分步骤结束时，我们还引入有关更高级主题的附加资料。</p>
<p>Now let's get started!</p>
<p>好了，我们现在开始！</p>
<h2 id="step-0-安装-move-开发环境-step-0-installation"><a class="header" href="#step-0-安装-move-开发环境-step-0-installation">Step 0: 安装 Move 开发环境<span id="Step0"><span> (Step 0: Installation)</a></h2>
<p>If you haven't already, open your terminal and clone <a href="https://github.com/move-language/move">the Move repository</a>:</p>
<p>如果您还没有安装过 Move，首先打开命令终端(terminal) 并clone <a href="https://github.com/move-language/move">Move代码库</a>:</p>
<pre><code class="language-bash">git clone https://github.com/move-language/move.git
</code></pre>
<p>Go to the <code>move</code> directory and run the <code>dev_setup.sh</code> script:</p>
<p>进入到 <code>move</code> 文件夹下，执行 <code>dev_setup.sh</code> 脚本:</p>
<pre><code class="language-bash">cd move
./scripts/dev_setup.sh -ypt
</code></pre>
<p>Follow the script's prompts in order to install all of Move's dependencies.</p>
<p>The script adds environment variable definitions to your <code>~/.profile</code> file.
Include them by running this command:</p>
<p>根据脚本命令的提示，按顺序安装 Move 的所有依赖项。
脚本将会将(move命令所在路径)环境变量写入到 <code>~/.profile</code> 文件中。</p>
<p>执行如下命令使环境变量生效：</p>
<pre><code class="language-bash">source ~/.profile
</code></pre>
<p>Next, install Move's command-line tool by running this commands:</p>
<p>然后执行如下命令来安装 Move 命令行工具：</p>
<pre><code class="language-bash">cargo install --path language/tools/move-cli
</code></pre>
<p>You can check that it is working by running the following command:</p>
<p>通过如下运行命令可以检查 move 命令是否可正常：</p>
<pre><code class="language-bash">move --help
</code></pre>
<p>You should see something like this along with a list and description of a number of commands:</p>
<p>您应该会看到类似这样的内容以及许多命令的列表和描述：</p>
<pre><code>move-package
Execute a package command. Executed in the current directory or the closest containing Move package

USAGE:
    move [OPTIONS] &lt;SUBCOMMAND&gt;

OPTIONS:
        --abi                          Generate ABIs for packages
...
</code></pre>
<p>If you want to find what commands are available and what they do, running
a command or subcommand with the <code>--help</code> flag will print documentation.</p>
<p>如果想了解有支持哪引命令及其作用, 执行命令或子命令时添加 <code>--help</code> 标记，此时会打印帮助文档。</p>
<p>Before running the next steps, <code>cd</code> to the tutorial directory:</p>
<p>在执行下一步骤之前，请先执行 <code>cd</code> 命令进入到教程对应目录下:</p>
<pre><code class="language-bash">cd &lt;path_to_move&gt;/language/documentation/tutorial
</code></pre>
<details>
<summary>Visual Studio Code Move 支持 (Visual Studio Code Move Support)</summary>
<p>There is official Move support for Visual Studio Code. You need to install
the move analyzer first:</p>
<p>Visual Studio Code 有正式的 Move 语言支持, 您需要先安装 <code>move analyzer</code> :</p>
<pre><code class="language-bash">cargo install --path language/move-analyzer
</code></pre>
<p>Now you can install the VS extension by opening VS Code, searching for the &quot;move-analyzer&quot; in the Extension Pane, and installing it. More detailed instructions can be found
in the extension's <a href="https://github.com/move-language/move/tree/main/language/move-analyzer/editors/code">README</a>.</p>
<p>现在您可以打开 VS Code 并安装 Move 扩展插件了，在扩展页面下找到 <code>move-analyzer</code> 并安装即可。关于扩展的详细信息可以查看扩展的<a href="https://github.com/move-language/move/tree/main/language/move-analyzer/editors/code">README</a>。</p>
</details>
<h2 id="step-1-编写第一个move模块-writing-my-first-move-module"><a class="header" href="#step-1-编写第一个move模块-writing-my-first-move-module">Step 1: 编写第一个Move模块<span id="Step1"><span> (Writing my first Move module)</a></h2>
<p>Change directory into the <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_1/BasicCoin"><code>step_1/BasicCoin</code></a> directory.
You should see a directory called <code>sources</code> -- this is the place where all
the Move code for this package lives. You should also see a
<code>Move.toml</code> file as well. This file specifies dependencies and other information about
the package; if you're familiar with Rust and Cargo, the <code>Move.toml</code> file
is similar to the <code>Cargo.toml</code> file, and the <code>sources</code> directory similar to
the <code>src</code> directory.</p>
<p>切换当前目录到<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_1/BasicCoin"><code>step_1/BasicCoin</code></a>下，您将看到 <code>sources</code> 子目录 -- 这个包(package)下所有的 Move 代码都在此目录中，同时您还会看到一个 <code>Move.toml</code> 文件。该文件指定当前包的依赖列表和其他信息。
如果您熟悉 <code>Rust</code> 和 <code>Cargo</code>，那 <code>Move.toml</code> 文件类似 <code>Cargo.toml</code> 文件， <code>sources</code> 目录类似 <code>src</code> 目录(它们的作用是一样的)</p>
<p>Let's take a look at some Move code! Open up
<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_1/BasicCoin/sources/FirstModule.move"><code>sources/FirstModule.move</code></a> in
your editor of choice. The first thing you'll see is this:</p>
<p>来一起看看 Move 语言代码内容！ 用你的编辑器打开<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_1/BasicCoin/sources/FirstModule.move"><code>sources/FirstModule.move</code></a>文件，会看到如下内容：</p>
<pre><code>// sources/FirstModule.move
module 0xCAFE::BasicCoin {
    ...
}
</code></pre>
<p>This is defining a Move
<a href="https://move-language.github.io/move/modules-and-scripts.html">module</a>. Modules are the
building block of Move code, and are defined with a specific address -- the address that the module can be published under.
In this case, the <code>BasicCoin</code> module can only be published under <code>0xCAFE</code>.</p>
<p>这是一个 <code>Move</code> <a href="./chpater_1_modules-and-scripts.html">module(模块)</a>的定义。
模块是 Move 语言的代码块, 并且它使用指定的地址(address)进行定义 -- 模块只能在该地址下发布。
当前 <code>BasicCoin</code> 模块只能被发布在 <code>0xCAFE</code> 地址下。</p>
<p>Let's now take a look at the next part of this file where we define a <a href="https://move-language.github.io/move/structs-and-resources.html">struct</a> to represent a <code>Coin</code> with a given <code>value</code>:</p>
<p>再看这个文件的下一部分，这里定义了一个具有字段 <code>value</code> 的<a href="./structs-and-resources.html">结构体</a> <code>Coin</code>：</p>
<pre><code>module 0xCAFE::BasicCoin {
    struct Coin has key {
        value: u64,
    }
    ...
}
</code></pre>
<p>Looking at the rest of the file, we see a function definition that creates a <code>Coin</code> struct and stores it under an account:</p>
<p>再看文件剩余部分，我们会看到一个函数，它会创建一个 <code>Coin</code> 结构体，并将其保存在某个账号(account)下：</p>
<pre><code>module 0xCAFE::BasicCoin {
    struct Coin has key {
        value: u64,
    }

    public fun mint(account: signer, value: u64) {
        move_to(&amp;account, Coin { value })
    }
}
</code></pre>
<p>Let's take a look at this function and what it's saying:</p>
<ul>
<li>It takes a <a href="https://move-language.github.io/move/signer.html"><code>signer</code></a> -- an
unforgeable token that represents control over a particular address, and
a <code>value</code> to mint.</li>
<li>It creates a <code>Coin</code> with the given value and stores it under the
<code>account</code> using the <code>move_to</code> operator.</li>
</ul>
<p>Let's make sure it builds! This can be done with the <code>build</code> command from within the package folder (<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_1/BasicCoin/"><code>step_1/BasicCoin</code></a>):</p>
<p>让我们来看看这个函数和它的含义:</p>
<ul>
<li>此函数需要一个<a href="./signer.html"><code>signer</code></a>参数 -- 表示不可伪造的 token 受此特定地址的控制; 和一个需要铸造的数量参数 <code>value</code>。</li>
<li>此函数使用给定的参数值铸造一个 <code>Coin</code>，然后通过 <code>move_to</code> 操作将其保存在(全局存储中)给定的 <code>account</code> 账户下。</li>
</ul>
<p>我们需要确保它真的执行，这可以通过在包文件夹(<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_1/BasicCoin/"><code>step_1/BasicCoin</code></a>)下的运行 <code>build</code> 命令来完成：</p>
<pre><code class="language-bash">move build
</code></pre>
<details>
<summary>进阶概念及参考引用 (Advanced concepts and references)</summary>
<ul>
<li>
<p>You can create an empty Move package by calling:</p>
<pre><code class="language-bash">move new &lt;pkg_name&gt;
</code></pre>
</li>
<li>
<p>Move code can also live a number of other places.  More information on the
Move package system can be found in the <a href="https://move-language.github.io/move/packages.html">Move book</a></p>
</li>
<li>
<p>More information on the <code>Move.toml</code> file can be found in the <a href="https://move-language.github.io/move/packages.html#movetoml">package section of the Move book</a>.</p>
</li>
<li>
<p>Move also supports the idea of <a href="https://move-language.github.io/move/address.html#named-addresses">named addresses</a>, Named addresses are a way to parametrize Move source code so that you can compile the module using different values for <code>NamedAddr</code> to get different bytecode that you can deploy, depending on what address(es) you control. They are used quite frequently, and can be defined in the <code>Move.toml</code> file in the <code>[addresses]</code> section, e.g.,</p>
<pre><code>[addresses]
SomeNamedAddress = &quot;0xC0FFEE&quot;
</code></pre>
</li>
<li>
<p>你可以通过以下命令创建一个空的 Move 包(move package):</p>
<pre><code class="language-bash">move new &lt;pkg_name&gt;
</code></pre>
</li>
<li>
<p>Move 代码也可以放在其他很多地方, 更多关于 Move 包系统的信息请参阅<a href="./packages.html">Move book</a></p>
</li>
<li>
<p>更多关于 <code>Move.toml</code> 文件的信息可以参阅<a href="./packages.html#movetoml">package section of the Move book</a>.</p>
</li>
<li>
<p>Move语言也支持命名地址的概念(<a href="./address.html#named-addresses">named addresses</a>), 命名地址是一种参数化 Move 源代码的方法，
就是如果对 <code>NamedAddr</code> 使用的不同赋值编译，编译后会获得部署到你控制地址的不同字节码. 这种用法很常见，一般都将地址变量其定义在 <code>Move.toml</code> 文件
的 <code>[addresses]</code> 部分. 例如:</p>
<pre><code>[addresses]
SomeNamedAddress = &quot;0xC0FFEE&quot;
</code></pre>
</li>
<li>
<p><a href="https://move-language.github.io/move/structs-and-resources.html">Structures</a> in Move can be given different
<a href="https://move-language.github.io/move/abilities.html">abilities</a> that describe what can be done with that type. There are four different abilities:</p>
<ul>
<li><code>copy</code>: Allows values of types with this ability to be copied.</li>
<li><code>drop</code>: Allows values of types with this ability to be popped/dropped.</li>
<li><code>store</code>: Allows values of types with this ability to exist inside a struct in global storage.</li>
<li><code>key</code>: Allows the type to serve as a key for global storage operations.</li>
</ul>
<p>So in the <code>BasicCoin</code> module we are saying that the <code>Coin</code> struct can be used as a key
in global storage and, because it has no other abilities, it cannot be
copied, dropped, or stored as a non-key value in storage. So you can't copy
coins, and you also can't lose coins by accident!</p>
</li>
<li>
<p><a href="https://move-language.github.io/move/functions.html">Functions</a> are default
private, and can also be <code>public</code>,
<a href="https://move-language.github.io/move/friends.html"><code>public(friend)</code></a>, or
<code>public(script)</code>. The last of these states that this function can be
called from a transaction script. <code>public(script)</code> functions can also be
called by other <code>public(script)</code> functions.</p>
</li>
<li>
<p><code>move_to</code> is one of the <a href="https://move-language.github.io/move/global-storage-operators.html">five different global storage operators</a>.</p>
</li>
<li>
<p>Move <a href="./chpater_16_structs-and-resources.html">结构体</a>可以通过给类型设定不同的能力<a href="./chapter_19_abilities.html">abilities</a>让类型下支持对应的行为. 有四种能力:</p>
<ul>
<li><code>copy</code>: 允许此类型的值被复制</li>
<li><code>drop</code>: 允许此类型的值被弹出/丢弃</li>
<li><code>store</code>: 允许此类型的值存在于全局存储的某个结构体中</li>
<li><code>key</code>: 允许此类型作为全局存储中的键(具有 <code>key</code> 能力的类型才能保存到全局存储中)</li>
</ul>
<p>所以 <code>BasicCoin</code> 模块下的 <code>Coin</code> 结构体可以用作全局存储(global storage)的键(key)， 因为它又不具备其他能力，它不能
被拷贝，不能被丢弃, 也不能作为非key来保存在(全局)存储里. 你无法复制 <code>Coin</code>，也不会意外弄丢它.</p>
</li>
<li>
<p>函数<a href="./functions.html">Functions</a>默认是私有的(private), 也可以声明为 <code>public</code> <a href="https://move-language.github.io/move/friends.html"><code>public(friend)</code></a>, <code>public(script)</code>. 最后一个声明(指 <code>public(script)</code>)的函数可以被事务脚本调用。<code>public(script)</code> 函数也可以被其他 <code>public(script)</code> 函数调用。(注意：在最新版本的 Move中，<code>public(script)</code> 已经被废弃，被<code>public entry</code> 取代，下同，译者注)</p>
</li>
<li>
<p><code>move_to</code> 是<a href="./global-storage-operators.html">五种不同的全局存储操作</a>之一</p>
</li>
</ul>
</details>
<h2 id="step-2-给模块module添加单元测试-adding-unit-tests-to-my-first-move-module"><a class="header" href="#step-2-给模块module添加单元测试-adding-unit-tests-to-my-first-move-module">Step 2: 给模块(Module)添加单元测试<span id="Step2"><span> (Adding unit tests to my first Move module)</a></h2>
<p>Now that we've taken a look at our first Move module, we'll take a look at a test to make sure minting works the way we expect it to by changing directory to <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_2/BasicCoin"><code>step_2/BasicCoin</code></a>.  Unit tests in Move are similar to unit tests in Rust if you're familiar with them -- tests are annotated with <code>#[test]</code> and written like normal Move functions.</p>
<p>You can run the tests with the <code>move test</code> command: (原文是 <code>package test</code>，应该有误)</p>
<p>现在我们已经完成了我们的第一个 Move 模块，我们将切换到目录<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_2/BasicCoin"><code>step_2/BasicCoin</code></a>下并完成一个测试，确保铸币按我们预期的方式工作。
如果你熟悉它们(Move 和 Rust)的话，Move 中的单元测试类似于 Rust 中的单元测试 —— 测试代码使用 <code>#[test]</code> 注解，并像编写普通的 Move 函数一样。</p>
<p>可以通过 <code>move test</code> 命令来执行测试:</p>
<pre><code class="language-bash">move test
</code></pre>
<p>Let's now take a look at the contents of the <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_2/BasicCoin/sources/FirstModule.move"><code>FirstModule.move</code>file</a>. The first new thing you'll
see is this test:</p>
<p>现在我们来完成文件<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_2/BasicCoin/sources/FirstModule.move"><code>FirstModule.move</code></a>的具体内容，你将看到的第一个新事项是这个测试:</p>
<pre><code>module 0xCAFE::BasicCoin {
    ...
    // Declare a unit test. It takes a signer called `account` with an
    // address value of `0xC0FFEE`.
    #[test(account = @0xC0FFEE)]
    fun test_mint_10(account: signer) acquires Coin {
        let addr = signer::address_of(&amp;account);
        mint(account, 10);
        // Make sure there is a `Coin` resource under `addr` with a value of `10`.
        // We can access this resource and its value since we are in the
        // same module that defined the `Coin` resource.
        assert!(borrow_global&lt;Coin&gt;(addr).value == 10, 0);
    }
}
</code></pre>
<p>This is declaring a unit test called <code>test_mint_10</code> that mints a <code>Coin</code> struct under the <code>account</code> with a <code>value</code> of <code>10</code>. It is then checking that the minted
coin in storage has the value that is expected with the <code>assert!</code> call. If the assertion fails the unit test will fail.</p>
<p>这里声明了一个命名为 <code>test_mint_10</code> 的单元测试，它在 <code>account</code> 账户地址下铸造了一个包含 <code>value</code> 为 <code>10</code>的 <code>Coin</code>，然后通过 <code>assert!</code> 断言检查已经铸造成功并保存在(全局)存储中的 <code>Coin</code> 的值是否与期望值一致。如果断言 <code>assert</code> 执行失败，则单元测试失败。</p>
<details>
<summary>进阶概念及参考练习 (Advanced concepts and exercises)</summary>
<ul>
<li>
<p>There are a number of test-related annotations that are worth exploring, they can be found
<a href="https://github.com/move-language/move/blob/main/language/changes/4-unit-testing.md#testing-annotations-their-meaning-and-usage">here</a>.
You'll see some of these used in Step 5.</p>
</li>
<li>
<p>Before running unit tests, you'll always need to add a dependency on the Move
standard library. This can be done by adding an entry to the <code>[dependencies]</code>
section of the <code>Move.toml</code>, e.g.,</p>
<pre><code class="language-toml">[dependencies]
MoveStdlib = { local = &quot;../../../../move-stdlib/&quot;, addr_subst = { &quot;Std&quot; = &quot;0x1&quot; } }
</code></pre>
<p>Note that you may need to alter the path to point to the <code>move-stdlib</code> directory under
<code>&lt;path_to_move&gt;/language</code>. You can also specify git dependencies. You can read more on Move
package dependencies <a href="https://move-language.github.io/move/packages.html#movetoml">here</a>.</p>
</li>
<li>
<p>很多测试相关的注解(annotations)都值得仔细探索, 参阅<a href="https://github.com/move-language/move/blob/main/language/changes/4-unit-testing.md#testing-annotations-their-meaning-and-usage">用法</a>。 在 <code>Step 5</code> 中会看到更多用法.</p>
</li>
<li>
<p>执行测试之前，需要设定Move标准库依赖关系，找到 <code>Move.toml</code> 并在 <code>[dependencies]</code> 段内进行设定, 例如</p>
<pre><code class="language-toml">[dependencies]
MoveStdlib = { local = &quot;../../../../move-stdlib/&quot;, addr_subst = { &quot;Std&quot; = &quot;0x1&quot; } }
</code></pre>
</li>
</ul>
<p>注意, 需要修改 <code>&lt;path_to_move&gt;/language</code> 中的内容来匹配实际 <code>move-stdlib</code> 所在的目录路径. 也可以用 <code>git</code> 方式指定依赖, 关于 Move 包依赖(package denpendices)信息可参阅<a href="./packages.html#movetoml">package文档</a></p>
<h4 id="练习-exercises"><a class="header" href="#练习-exercises">练习 (Exercises)</a></h4>
<ul>
<li>
<p>Change the assertion to <code>11</code> so that the test fails. Find a flag that you can pass to the <code>move test</code> command that will show you the global state when the test fails. It should look something like this:</p>
</li>
<li>
<p>将断言值改为 <code>11</code> 将导致断言执行失败, 找一个可以传递给 <code>move test</code> 命令的标志，当测试失败时它会显示全局状态。看起来像这样：</p>
<pre><code>  ┌── test_mint_10 ──────
  │ error[E11001]: test failure
  │    ┌─ ./sources/FirstModule.move:24:9
  │    │
  │ 18 │     fun test_mint_10(account: signer) acquires Coin {
  │    │         ------------ In this function in 0xcafe::BasicCoin
  │    ·
  │ 24 │         assert!(borrow_global&lt;Coin&gt;(addr).value == 11, 0);
  │    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Test was not expected to abort but it aborted with 0 here
  │
  │
  │ ────── Storage state at point of failure ──────
  │ 0xc0ffee:
  │       =&gt; key 0xcafe::BasicCoin::Coin {
  │           value: 10
  │       }
  │
  └──────────────────
</code></pre>
</li>
<li>
<p>Find a flag that allows you to gather test coverage information, and then play around with using the <code>move coverage</code> command to look at coverage statistics and source coverage.</p>
</li>
<li>
<p>找一个允许您收集测试覆盖率信息的标志，然后使用 <code>move coverage</code> 命令查看覆盖率统计信息和源码覆盖率。</p>
</li>
</ul>
</details>
<h2 id="step-3-设计-basiccoin-模块module-designing-my-basiccoin-module"><a class="header" href="#step-3-设计-basiccoin-模块module-designing-my-basiccoin-module">Step 3: 设计 <code>BasicCoin</code> 模块(Module)<span id="Step3"><span> (Designing my <code>BasicCoin</code> module)</a></h2>
<p>In this section, we are going to design a module implementing a basic coin and balance interface, where coins can be minted and transferred between balances held under different addresses.</p>
<p>在本节中，我们将设计一个具有基本代币和余额(balance)接口功能的模块，通过他们来实现币的挖矿铸造，不同地址之下钱包的转账。</p>
<p>The signatures of the public Move function are the following:</p>
<p>Move 语言的 <code>public function</code> 签名如下：</p>
<pre><code>/// Publish an empty balance resource under `account`'s address. This function must be called before
/// minting or transferring to the account.
public fun publish_balance(account: &amp;signer) { ... }

/// Mint `amount` tokens to `mint_addr`. Mint must be approved by the module owner.
public fun mint(module_owner: &amp;signer, mint_addr: address, amount: u64) acquires Balance { ... }

/// Returns the balance of `owner`.
public fun balance_of(owner: address): u64 acquires Balance { ... }

/// Transfers `amount` of tokens from `from` to `to`.
public fun transfer(from: &amp;signer, to: address, amount: u64) acquires Balance { ... }
</code></pre>
<p>Next we look at the data structs we need for this module.</p>
<p>接下来再看本模块所需要各数据结构.</p>
<p>A Move module doesn't have its own storage. Instead, Move &quot;global storage&quot; (what we call our
blockchain state) is indexed by addresses. Under each address there are Move modules (code) and Move resources (values).</p>
<p>Move 语言的模块没有自己的数据存储，相反的是 Move 语言提供按地址(addresses) 索引的 <strong>全局存储</strong> (也是就是我们所说的区块链状态(blockchain state)).
每个地址之下包含有 Move 模块(代码)和 Move 资源 (数据)。</p>
<p>The global storage looks roughly like this in Rust syntax:</p>
<p>在 Rust 语法中，全局存储看起来有点像这样：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GlobalStorage {
    resources: Map&lt;address, Map&lt;ResourceType, ResourceValue&gt;&gt;
    modules: Map&lt;address, Map&lt;ModuleName, ModuleBytecode&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>The Move resource storage under each address is a map from types to values. (An observant reader might observe that this means each address can only have one value of each type.) This conveniently provides us a native mapping indexed by addresses.
In our <code>BasicCoin</code> module, we define the following <code>Balance</code> resource representing the number of coins each address holds:</p>
<p>每个地址下的 Move 资源存储是一个类型到数值的映射。(细心的读者也许已经注意到每个地址, 每个类型下只能对应一个具体值)。这方便地为我们提供了一个按地址索引的本地映射。
在 <code>BasicCoin</code> 模块中，定义了每个 <code>Balance</code> (钱包，余额)资源表示每个地址下持有的币的数量：</p>
<pre><code>/// Struct representing the balance of each address.
struct Balance has key {
    coin: Coin // same Coin from Step 1
}
</code></pre>
<p>Roughly the Move blockchain state should look like this:</p>
<p>区块链状态(<code>Move blockchain state</code>)看起来大致如下：</p>
<p><img src="https://raw.githubusercontent.com/move-language/move/main/language/documentation/tutorial/diagrams/move_state.png" alt="" /></p>
<h4 id="进阶主题-advanced-topics-"><a class="header" href="#进阶主题-advanced-topics-">进阶主题 (Advanced topics) ：</a></h4>
<summary><code>public(script)</code> functions</summary>
<p>Only functions with <code>public(script)</code> visibility can be invoked directly in transactions. So if you would like to call the <code>transfer</code> method directly from a transaction, you'll want to change its signature to:</p>
<p>只有<code>public(script)</code>可见行的函数才能直接被交易调用，所以如果你要直接在交易内调用<code>transfer</code>方法，那么需要将函数签改成如下格式:</p>
<pre><code>public(script) fun transfer(from: signer, to: address, amount: u64) acquires Balance { ... }
</code></pre>
<p>Read more on Move function visibilities <a href="https://move-language.github.io/move/functions.html#visibility">here</a>.</p>
<p>关于函数可见性的更多信息，请参阅<a href="./functions.html#visibility">Move function visibilities</a>。</p>
</details>
<details>
<summary>与 Ethereum/Solidity 的比较 (Comparison with Ethereum/Solidity)</summary>
<p>In most Ethereum <a href="(https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)">ERC-20</a> contracts, the balance of each address is stored in a <em>state variable</em> of type <code>mapping(address =&gt; uint256)</code>. This state variable is stored in the storage of a particular smart contract.</p>
<p>在大多数以太坊<a href="(https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)">ERC-20</a>智能合约中，各个账户地址下的余额保存在类型为 <code>mapping(address =&gt; uint256)</code>的 <strong>状态变量</strong> 中，此状态变量存储在具体的智能合约内部存储中。</p>
<p>The Ethereum blockchain state might look like this:</p>
<p>以太坊区块链的状态看起来大致如下:</p>
<p><img src="https://raw.githubusercontent.com/move-language/move/main/language/documentation/tutorial/diagrams/solidity_state.png" alt="" /></p>
</details>
<h2 id="step-4-实现-basiccoin-模块span-idstep4-implementing-my-basiccoin-module"><a class="header" href="#step-4-实现-basiccoin-模块span-idstep4-implementing-my-basiccoin-module">Step 4: 实现 <code>BasicCoin</code> 模块span id=&quot;Step4&quot;&gt;<span> (Implementing my <code>BasicCoin</code> module)</a></h2>
<p>We have created a Move package for you in folder <code>step_4</code> called <code>BasicCoin</code>. The <code>sources</code> folder contains source code for all your Move modules in the package, including <code>BasicCoin.move</code>. In this section, we will take a closer look at the implementation of the methods inside <a href="https://github.com/move-language/move/blob/main/language/documentation/tutorial/step_4/BasicCoin/sources/BasicCoin.move"><code>BasicCoin.move</code></a>.</p>
<p>我们已经在 <code>step_4</code> 文件夹上创建了名叫 <code>BasicCoin</code> 的 Move 包。<code>sources</code> 文件夹包含所有的 Move 包(package)的模块源码，包括 <code>BasicCoin.move</code>。 在本节中，我们将仔细研究<a href="https://github.com/move-language/move/blob/main/language/documentation/tutorial/step_4/BasicCoin/sources/BasicCoin.move"><code>BasicCoin.move</code></a>内部方法的实现。</p>
<h3 id="编译代码-compiling-our-code"><a class="header" href="#编译代码-compiling-our-code">编译代码 (Compiling our code)</a></h3>
<p>Let's first try building the code using Move package by running the following command in <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_4/BasicCoin"><code>step_4/BasicCoin</code></a> folder:</p>
<p>首先尝试在文件夹<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_4/BasicCoin"><code>step_4/BasicCoin</code></a>中运行以下命令，使用 Move 包构建代码：</p>
<pre><code class="language-bash">move build
</code></pre>
<h3 id="方法的实现-implementation-of-methods"><a class="header" href="#方法的实现-implementation-of-methods">方法的实现 (Implementation of methods)</a></h3>
<p>Now let's take a closer look at the implementation of the methods inside <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_4/BasicCoin/sources/BasicCoin.move"><code>BasicCoin.move</code></a>.</p>
<p>现在仔细看看<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_4/BasicCoin/sources/BasicCoin.move"><code>BasicCoin.move</code></a>中内部方法的实现。</p>
<details>
<summary><code>publish_balance</code>方法 (Method <code>publish_balance</code>)</summary>
<p>This method publishes a <code>Balance</code> resource to a given address. Since this resource is needed to receive coins through minting or transferring, <code>publish_balance</code> method must be called by a user before they can receive money, including the module owner.</p>
<p>此方法将 <code>Balance</code> 资源发布到指定地址名下。由于此资源需要通过铸造或转账来接收代币，必须由用户先调用方法 <code>publish_balance</code> 才能接收钱，包括模块所有者。</p>
<p>This method uses a <code>move_to</code> operation to publish the resource:</p>
<p>此方法使用 <code>move_to</code> 操作来发布资源：</p>
<pre><code>let empty_coin = Coin { value: 0 };
move_to(account, Balance { coin:  empty_coin });
</code></pre>
</details>
<details>
<summary><code>mint</code>方法 (Method <code>mint</code>)</summary>）
<p>Here we require that <code>mint</code> must be approved by the module owner. We enforce this using the assert statement:
<code>mint</code> method mints coins to a given account.</p>
<p><code>mint</code> 方法将代币铸造到指定的帐户。在此我们要求 <code>mint</code> 必须得到模块所有者的批准。我们使用 <code>assert</code> 语句强制执行此操作：</p>
<pre><code>assert!(signer::address_of(&amp;module_owner) == MODULE_OWNER, errors::requires_address(ENOT_MODULE_OWNER));
</code></pre>
<p>Assert statements in Move can be used in this way: <code>assert!(&lt;predicate&gt;, &lt;abort_code&gt;);</code>. This means that if the <code>&lt;predicate&gt;</code> is false, then abort the transaction with <code>&lt;abort_code&gt;</code>. Here <code>MODULE_OWNER</code> and <code>ENOT_MODULE_OWNER</code> are both constants defined at the beginning of the module. And <code>errors</code> module defines common error categories we can use.
It is important to note that Move is transactional in its execution -- so if an <a href="https://move-language.github.io/move/abort-and-assert.html">abort</a> is raised no unwinding of state needs to be performed, as no changes from that transaction will be persisted to the blockchain.</p>
<p>Move 中的 <code>assert</code> 语句可以这样使用：<code>assert!(&lt;predicate&gt;, &lt;abort_code&gt;);</code>。这意味着如果 <code>&lt;predicate&gt;</code> 为假，则使用中止错误码 <code>&lt;abort_code&gt;</code> 来终止交易。此处的 <code>MODULE_OWNER</code> 和 <code>ENOT_MODULE_OWNER</code> 都是在模块开头定义的常量。<code>errors</code> 模块定义了我们可以使用的常见错误种类。重点是我们需要注意 Move 在其执行过程中是事务性的-- 因此，如果触发<a href="./chapter_12_abort-and-assert.html">中止(abort)</a>，并不用回退已执行状态的，因为该事务的任何更改都不会持久保存到区块链。</p>
<p>We then deposit a coin with value <code>amount</code> to the balance of <code>mint_addr</code>.</p>
<p>然后将数量为 <code>amount</code> 的代币存入 <code>mint_addr</code> 的余额中。</p>
<pre><code>deposit(mint_addr, Coin { value: amount });
</code></pre>
</details>
<details>
<summary><code>balance_of</code>方法 (Method <code>balance_of</code>)</summary>
<p>We use <code>borrow_global</code>, one of the global storage operators, to read from the global storage.</p>
<p>我们使用全局存储操作之一的 <code>borrow_global</code> 从全局存储中读取资源(数据)。</p>
<pre><code>borrow_global&lt;Balance&gt;(owner).coin.value
                 |       |       \    /
        resource type  address  field names
</code></pre>
</details>
<details>
<summary><code>transfer</code>方法 (Method <code>transfer</code>)</summary>
<p>This function withdraws tokens from <code>from</code>'s balance and deposits the tokens into <code>to</code>s balance. We take a closer look at <code>withdraw</code> helper function:</p>
<p>该函数从 <code>from</code> 的余额中提取代币并将代币存入 <code>to</code> 的余额中。我们仔细研究帮助函数 <code>withdraw</code>：</p>
<pre><code>fun withdraw(addr: address, amount: u64) : Coin acquires Balance {
    let balance = balance_of(addr);
    assert!(balance &gt;= amount, EINSUFFICIENT_BALANCE);
    let balance_ref = &amp;mut borrow_global_mut&lt;Balance&gt;(addr).coin.value;
    *balance_ref = balance - amount;
    Coin { value: amount }
}
</code></pre>
<p>At the beginning of the method, we assert that the withdrawing account has enough balance. We then use <code>borrow_global_mut</code> to get a mutable reference to the global storage, and <code>&amp;mut</code> is used to create a <a href="https://move-language.github.io/move/references.html">mutable reference</a> to a field of a struct. We then modify the balance through this mutable reference and return a new coin with the withdrawn amount.</p>
<p>在方法开始，我们断言提款账户有足够的余额。然后我们使用 <code>borrow_global_mut</code> 来获得全局存储的可变引用，并用 <code>&amp;mut</code> 创建结构体字段的<a href="./references.html">可变引用</a>。然后我们通过这个可变引用修改余额并返回一个带有提取金额的新代币。</p>
</details>
<h3 id="练习-exercises-1"><a class="header" href="#练习-exercises-1">练习 (Exercises)</a></h3>
<p>There are two <code>TODO</code>s in our module, left as exercises for the reader:</p>
<ul>
<li>Finish implementing the <code>publish_balance</code> method.</li>
<li>Implement the <code>deposit</code> method.</li>
</ul>
<p>在模块中有两个 TODOs，留给读者练习：</p>
<ul>
<li>完成 <code>publish_balance</code> 方法的实现。</li>
<li>实现 <code>deposit</code> 方法。</li>
</ul>
<p>The solution to this exercise can be found in <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_4_sol"><code>step_4_sol</code></a> folder.</p>
<p>此练习的解决方案可以在<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_4_sol"><code>step_4_sol</code></a>文件夹中找到。</p>
<p><strong>额外练习</strong> (<strong>Bonus exercise</strong>)</p>
<ul>
<li>What would happen if we deposit too many tokens to a balance?</li>
<li>如果我们在余额中存入太多会发生什么？</li>
</ul>
<h2 id="step-5-在模块-basiccoin-中添加和使用单元测试-adding-and-using-unit-tests-with-the-basiccoin-module"><a class="header" href="#step-5-在模块-basiccoin-中添加和使用单元测试-adding-and-using-unit-tests-with-the-basiccoin-module">Step 5: 在模块 <code>BasicCoin</code> 中添加和使用单元测试<span id="Step5"><span> (Adding and using unit tests with the <code>BasicCoin</code> module<span id="Step5"><span>)</a></h2>
<p>In this step we're going to take a look at all the different unit tests we've written to cover the code we wrote in step 4. We're also going to take a look at some tools we can use to help us write tests.</p>
<p>在这一步中，来看看我们为覆盖在 <code>step 4</code> 中编写的代码而编写的所有不同的单元测试。还将看看我们可以用来帮助我们编写测试用例的一些工具。</p>
<p>To get started, run the <code>move test</code> command in the <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_5/BasicCoin"><code>step_5/BasicCoin</code></a> folder</p>
<p>首先，请在文件夹 <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_5/BasicCoin"><code>step_5/BasicCoin</code></a>中 运行 <code>move test</code> 命令。</p>
<pre><code class="language-bash">move test
</code></pre>
<p>You should see something like this:</p>
<p>您应该看到如下内容：</p>
<pre><code>INCLUDING DEPENDENCY MoveStdlib
BUILDING BasicCoin
Running Move unit tests
[ PASS    ] 0xcafe::BasicCoin::can_withdraw_amount
[ PASS    ] 0xcafe::BasicCoin::init_check_balance
[ PASS    ] 0xcafe::BasicCoin::init_non_owner
[ PASS    ] 0xcafe::BasicCoin::publish_balance_already_exists
[ PASS    ] 0xcafe::BasicCoin::publish_balance_has_zero
[ PASS    ] 0xcafe::BasicCoin::withdraw_dne
[ PASS    ] 0xcafe::BasicCoin::withdraw_too_much
Test result: OK. Total tests: 7; passed: 7; failed: 0
</code></pre>
<p>Taking a look at the tests in the <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_5/BasicCoin/sources/BasicCoin.move"><code>BasicCoin</code> module</a> we've tried to keep each unit test to testing one particular behavior.</p>
<p>看看 <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_5/BasicCoin/sources/BasicCoin.move"><code>BasicCoin</code> </a>模块中的测试，我们试图让每个单元测试都测试一个具体的行为。</p>
<details>
<summary>Exercise (练习)</summary>
<p>After taking a look at the tests, try and write a unit test called <code>balance_of_dne</code> in the <code>BasicCoin</code> module that tests the case where a <code>Balance</code> resource doesn't exist under the address that <code>balance_of</code> is being called on. It should only be a couple lines!</p>
<p>在查看测试之后，尝试在 <code>BasicCoin</code> 模块中编写一个单元测试 <code>balance_of_dne</code>，测试地址没有 <code>Balance</code> 资源的情况，调用 <code>balance_of</code> 方法的执行结果。它应该只有几行代码。</p>
<p>The solution to this exercise can be found in <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_5_sol"><code>step_5_sol</code></a>.</p>
<p>练习的答案可以在<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_5_sol"><code>step_5_sol</code></a>中找到。</p>
</details>
<h2 id="step-6-basiccoin-模块泛型化making-my-basiccoin-module-generic"><a class="header" href="#step-6-basiccoin-模块泛型化making-my-basiccoin-module-generic">Step 6: <code>BasicCoin</code> 模块泛型化<span id="Step6"><span>（Making my <code>BasicCoin</code> module generic<span id="Step6"><span>）</a></h2>
<p>In Move, we can use generics to define functions and structs over different input data types. Generics are a great building block for library code. In this section, we are going to make our simple <code>BasicCoin</code> module generic so that it can serve as a library module that can be used by other user modules.</p>
<p>在 Move 语言中，我们可以使用泛型来定义不同输入数据类型的函数和结构体。泛型是库代码的重要组成部分。在本节中，我们将使我们的简单 <code>BasicCoin</code> 模块泛型化，以便它可以用作其他用户模块可以使用的模块库。</p>
<p>First, we add type parameters to our data structs:</p>
<p>首先，我们将类型参数添加到我们的数据结构中：</p>
<pre><code>struct Coin&lt;phantom CoinType&gt; has store {
    value: u64
}

struct Balance&lt;phantom CoinType&gt; has key {
    coin: Coin&lt;CoinType&gt;
}
</code></pre>
<p>We also add type parameters to our methods in the same manner. For example, <code>withdraw</code> becomes the following:</p>
<p>我们还以相同的方式将类型参数添加到我们的方法中。例如，<code>withdraw</code> 变成如下：</p>
<pre><code>fun withdraw&lt;CoinType&gt;(addr: address, amount: u64) : Coin&lt;CoinType&gt; acquires Balance {
    let balance = balance_of&lt;CoinType&gt;(addr);
    assert!(balance &gt;= amount, EINSUFFICIENT_BALANCE);
    let balance_ref = &amp;mut borrow_global_mut&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;
    *balance_ref = balance - amount;
    Coin&lt;CoinType&gt; { value: amount }
}
</code></pre>
<p>Take a look at <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_6/BasicCoin/sources/BasicCoin.move"><code>step_6/BasicCoin/sources/BasicCoin.move</code></a> to see the full implementation.</p>
<p>查看<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_6/BasicCoin/sources/BasicCoin.move"><code>step_6/BasicCoin/sources/BasicCoin.move</code></a>完整的实现。</p>
<p>At this point, readers who are familiar with Ethereum might notice that this module serves a similar purpose as the <a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-20/">ERC20 token standard</a>, which provides an interface for implementing fungible tokens in smart contracts. One key advantage of using generics is the ability to reuse code since the generic library module already provides a standard implementation and the instantiating module can provide customizations by wrapping the standard implementation.</p>
<p>此时，熟悉以太坊的读者可能会注意到，该模块的用途与<a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-20/">ERC20 token standard</a>类似，后者提供了在智能合约中实现可替代代币的接口。使用泛型的一个关键优势是能够重用代码，因为泛型模块库已经提供了标准实现，并且实例化模块可以通过包装标准实现提供定制化功能。</p>
<p>We provide a little module called <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_6/BasicCoin/sources/MyOddCoin.move"><code>MyOddCoin</code></a> that instantiates the <code>Coin</code> type and customizes its transfer policy: only odd number of coins can be transferred. We also include two <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_6/BasicCoin/sources/MyOddCoin.move">tests</a> to test this behavior. You can use the commands you learned in step 2 and step 5 to run the tests.</p>
<p>我们提供了一个称为<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_6/BasicCoin/sources/MyOddCoin.move"><code>MyOddCoin</code></a>并实例化 <code>Coin</code> 类型并自定义其转移策略的小模块：只能转移奇数个代币。其还包括两个 <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_6/BasicCoin/sources/MyOddCoin.move">tests</a>来测试这种行为。您可以使用在第 2 步和第 5 步中学到的命令来运行测试。</p>
<h4 id="进阶主题-advanced-topics"><a class="header" href="#进阶主题-advanced-topics">进阶主题 (Advanced topics):</a></h4>
<details>
<summary><code>phantom</code> 类型参数 (<code>phantom</code> type parameters)</summary>
<p>In definitions of both <code>Coin</code> and <code>Balance</code>, we declare the type parameter <code>CoinType</code> to be phantom because <code>CoinType</code> is not used in the struct definition or is only used as a phantom type parameter.</p>
<p>在 <code>Coin</code> 和 <code>Balance </code>的定义中，我们将类型参数 <code>CoinType</code> 声明为phantom，因为 <code>CoinType</code> 没有在结构体定义中使用或仅用作 phantom 类型参数。</p>
<p>Read more about phantom type parameters <a href="https://move-language.github.io/move/generics.html#phantom-type-parameters">here</a>.</p>
<p>阅读更多有关 <a href="generics.html">phantom 类型参数</a> 信息.</p>
</details>
<h2 id="进阶步骤-advanced-steps"><a class="header" href="#进阶步骤-advanced-steps">进阶步骤 (Advanced steps)</a></h2>
<p>Before moving on to the next steps, let's make sure you have all the prover dependencies installed.</p>
<p>在继续下一步之前，确保您已安装所有的验证器依赖项。</p>
<p>Try running <code>boogie /version </code>. If an error message shows up saying &quot;command not found: boogie&quot;, you will have to run the setup script and source your profile:</p>
<p>尝试运行 <code>boogie /version</code> 。如果出现错误消息“找不到命令：boogie”，您将必须运行安装脚本并更新环境配置(<code>source ~/.profile</code>)：</p>
<pre><code class="language-bash"># run the following in move repo root directory
./scripts/dev_setup.sh -yp
source ~/.profile
</code></pre>
<h2 id="step-7--使用move验证器use-the-move-prover"><a class="header" href="#step-7--使用move验证器use-the-move-prover">Step 7:  使用Move验证器<span id="Step7"><span>（Use the Move prover<span id="Step7"><span>）</a></h2>
<p>Smart contracts deployed on the blockchain may manipulate high-value assets. As a technique that uses strict mathematical methods to describe behavior and reason correctness of computer systems, formal verification has been used in blockchains to prevent bugs in smart contracts. <a href="https://github.com/move-language/move/blob/main/language/move-prover/doc/user/prover-guide.md">The Move prover</a> is an evolving formal verification tool for smart contracts written in the Move language. The user can specify functional properties of smart contracts using the <a href="https://github.com/move-language/move/blob/main/language/move-prover/doc/user/spec-lang.md">Move Specification Language (MSL)</a> and then use the prover to automatically check them statically. To illustrate how the prover is used, we have added the following code snippet to the <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_7/BasicCoin/sources/BasicCoin.move">BasicCoin.move</a>:</p>
<p>部署在区块链上的智能合约可能会操纵高价值资产。作为一种使用严格的数学方式来描述计算机系统的行为和推理正确性的技术，形式化验证已被用于区块链，以防止智能合约中错误的产生。 <a href="https://github.com/move-language/move/blob/main/language/move-prover/doc/user/prover-guide.md">Move验证器</a>是一种在进化中、用Move 语言编写的智能合约形式化验证工具。用户可以使用<a href="https://github.com/move-language/move/blob/main/language/move-prover/doc/user/spec-lang.md">Move语言规范(Move Specification Language (MSL))</a>指定智能合约的功能属性，然后使用验证器自动静态检查它们。
为了说明如何使用验证器，我们在<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_7/BasicCoin/sources/BasicCoin.move">BasicCoin.move</a>中添加了以下代码片段：</p>
<pre><code>    spec balance_of {
        pragma aborts_if_is_strict;
    }
</code></pre>
<p>Informally speaking, the block <code>spec balance_of {...}</code> contains the property specification of the method <code>balance_of</code>.</p>
<p>通俗地说，代码块 <code>spec balance_of {...}</code> 包含 <code>balance_of</code> 方法的属性规范说明。</p>
<p>Let's first run the prover using the following command inside <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_7/BasicCoin/"><code>BasicCoin</code> directory</a>:</p>
<p>首先在<a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_7/BasicCoin/"><code>BasicCoin</code> directory</a>目录中使用以下命令运行验证器。</p>
<pre><code class="language-bash">move prove
</code></pre>
<p>which outputs the following error information:</p>
<p>它输出以下错误信息：</p>
<pre><code>error: abort not covered by any of the `aborts_if` clauses
   ┌─ ./sources/BasicCoin.move:38:5
   │
35 │           borrow_global&lt;Balance&lt;CoinType&gt;&gt;(owner).coin.value
   │           ------------- 由于执行失败这里发生中止
   ·
38 │ ╭     spec balance_of {
39 │ │         pragma aborts_if_is_strict;
40 │ │     }
   │ ╰─────^
   │
   =     at ./sources/BasicCoin.move:34: balance_of
   =         owner = 0x29
   =     at ./sources/BasicCoin.move:35: balance_of
   =         中止

Error: exiting with verification errors
</code></pre>
<p>The prover basically tells us that we need to explicitly specify the condition under which the function <code>balance_of</code> will abort, which is caused by calling the function <code>borrow_global</code> when <code>owner</code> does not own the resource <code>Balance&lt;CoinType&gt;</code>. To remove this error information, we add an <code>aborts_if</code> condition as follows:</p>
<p>验证器大体上告诉我们，我们需要明确指定函数 <code>balance_of</code> 中止的条件，中止原因是 <code>owner</code>(函数调用者)在没有资源 <code>Balance&lt;CoinType&gt;</code> 的情况下调用 <code>borrow_global</code> 函数导致的。要去掉此错误信息，我们添加如下 <code>aborts_if</code> 条件：</p>
<pre><code>    spec balance_of {
        pragma aborts_if_is_strict;
        aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(owner);
    }
</code></pre>
<p>After adding this condition, try running the <code>prove</code> command again to confirm that there are no verification errors:</p>
<p>添加此条件后，再次尝试运行prove命令，确认没有验证错误：</p>
<pre><code class="language-bash">move prove
</code></pre>
<p>Apart from the abort condition, we also want to define the functional properties. In Step 8, we will give more detailed introduction to the prover by specifying properties for the methods defined the <code>BasicCoin</code> module.</p>
<p>除了中止条件，我们还想定义功能属性。在第 8 步中，我们将通过为定义 <code>BasicCoin</code> 模块的方法指定属性来更详细地介绍验证器。</p>
<h2 id="第-8-步为-basiccoin-模块编写正式规范write-formal-specifications-for-the-basiccoin-module"><a class="header" href="#第-8-步为-basiccoin-模块编写正式规范write-formal-specifications-for-the-basiccoin-module">第 8 步：为 <code>BasicCoin</code> 模块编写正式规范<span id="Step8"><span>（Write formal specifications for the <code>BasicCoin</code> module）<span id="Step8"><span></a></h2>
<details>
<summary> 取款方法 (Method withdraw) </summary>
<p>The signature of the method <code>withdraw</code> is given below:</p>
<p>取款(<code>withdraw</code>) 方法的签名如下：</p>
<pre><code>fun withdraw&lt;CoinType&gt;(addr: address, amount: u64) : Coin&lt;CoinType&gt; acquires Balance
</code></pre>
<p>The method withdraws tokens with value <code>amount</code> from the address <code>addr</code> and returns a created Coin of value <code>amount</code>.  The method <code>withdraw</code> aborts when 1) <code>addr</code> does not have the resource <code>Balance&lt;CoinType&gt;</code> or 2) the number of tokens in <code>addr</code> is smaller than <code>amount</code>. We can define conditions like this:</p>
<p>该方法从地址 <code>addr</code> 中提取数量为 <code>amount</code> 的代币，然后创建数量为 <code>amount</code> 的代币并将其返回。当出现如下情况会中止：</p>
<ol>
<li>地址 <code>addr</code> 没有资源 <code>Balance&lt;CoinType&gt;</code>，或</li>
<li>地址 <code>addr</code> 中的代币数量小于 <code>amount</code> 时，<code>withdraw</code> 。</li>
</ol>
<p>我们可以这样定义条件：</p>
<pre><code>    spec withdraw {
        let balance = global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;
        aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);
        aborts_if balance &lt; amount;
    }
</code></pre>
<p>As we can see here, a spec block can contain let bindings which introduce names for expressions. <code>global&lt;T&gt;(address): T</code> is a built-in function that returns the resource value at <code>addr</code>. <code>balance</code> is the number of tokens owned by <code>addr</code>. <code>exists&lt;T&gt;(address): bool</code> is a built-in function that returns true if the resource T exists at address. Two <code>aborts_if</code> clauses correspond to the two conditions mentioned above. In general, if a function has more than one <code>aborts_if</code> condition, those conditions are or-ed with each other. By default, if a user wants to specify aborts conditions, all possible conditions need to be listed. Otherwise, the prover will generate a verification error. However, if <code>pragma aborts_if_is_partial</code> is defined in the spec block, the combined aborts condition (the or-ed individual conditions) only <em>imply</em> that the function aborts. The reader can refer to the <a href="https://github.com/move-language/move/blob/main/language/move-prover/doc/user/spec-lang.md">MSL</a> document for more information.</p>
<p>正如我们在这里看到的，一个 spec 块可以包含 <code>let</code> 绑定，它为表达式引入名称。
<code>global&lt;T&gt;(address): T</code> 是一个返回 <code>addr</code> 资源值的内置函数。<code>balance</code> 是 <code>addr</code> 拥有的代币数量。
<code>exists&lt;T&gt;(address): bool</code> 是一个内置函数，如果指定的地址(address)在(全局存储中)有资源 <code>T</code> 则返回 <code>true</code> 。
两个 <code>aborts_if</code> 子句对应上述两个条件。通常，如果一个函数有多个 <code>aborts_if</code> 条件，这些条件之间是相互对等的。默认情况下，如果用户想要指定中止条件，则需要列出所有可能的条件。否则验证器将产生验证错误。
但是，如果在 <code>spec</code> 代码块中定义了 <code>pragma aborts_if_is_partial</code>，则组合中止条件（或对等的单个条件）仅 <em>暗示</em> 函数中止。
读者可以参考 <a href="https://github.com/move-language/move/blob/main/language/move-prover/doc/user/spec-lang.md">MSL</a> 文档了解更多信息。</p>
<p>The next step is to define functional properties, which are described in the two <code>ensures</code> clauses below. First, by using the <code>let post</code> binding, <code>balance_post</code> represents the balance of <code>addr</code> after the execution, which should be equal to <code>balance - amount</code>. Then, the return value (denoted as <code>result</code>) should be a coin with value <code>amount</code>.</p>
<p>下一步是定义功能属性，这些属性在下面的两个 <code>ensures</code> 子句中进行了描述。首先，通过使用 <code>let post</code> 绑定，<code>balance_post</code> 表示地址 <code>addr</code> 执行后的余额，应该等于 <code>balance - amount</code>。那么，返回值（表示为 <code>result</code> ）应该是一个价值为 <code>amount</code> 的代币。</p>
<pre><code>    spec withdraw {
        let balance = global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;
        aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);
        aborts_if balance &lt; amount;

        let post balance_post = global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;
        ensures balance_post == balance - amount;
        ensures result == Coin&lt;CoinType&gt; { value: amount };
    }
</code></pre>
</details>
<details>
<summary> 存款方法 (Method deposit) </summary>
<p>The signature of the method <code>deposit</code> is given below:</p>
<p>存款(<code>deposit</code>)方法的签名如下：</p>
<pre><code>fun deposit&lt;CoinType&gt;(addr: address, check: Coin&lt;CoinType&gt;) acquires Balance
</code></pre>
<p>The method deposits the <code>check</code> into <code>addr</code>. The specification is defined below:</p>
<p>该方法将代币 <code>check</code> 存入地址 <code>addr</code>. 规范定义如下：</p>
<pre><code>    spec deposit {
        let balance = global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;
        let check_value = check.value;

        aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);
        aborts_if balance + check_value &gt; MAX_U64;

        let post balance_post = global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;
        ensures balance_post == balance + check_value;
    }
</code></pre>
<p><code>balance</code> represents the number of tokens in <code>addr</code> before execution and <code>check_value</code> represents the number of tokens to be deposited. The method would abort if 1) <code>addr</code> does not have the resource <code>Balance&lt;CoinType&gt;</code> or 2) the sum of <code>balance</code> and <code>check_value</code> is greater than the maxium value of the type <code>u64</code>. The functional property checks that the balance is correctly updated after the execution.</p>
<p><code>balance</code> 表示 <code>addr</code> 执行前的代币数量，<code>check_value</code> 表示要存入的代币数量。方法出现如下情况将会中止：
1) 地址 <code>addr</code> 没有 <code>Balance&lt;CoinType&gt;</code> 资源， 或
2) <code>balance</code> 与 <code>check_value</code> 之和大于 <code>u64</code> 的最大值。</p>
<p>该功能属性检查执行后余额是否正确更新。</p>
</details>
<details>
<summary> 转账方法 (Method transfer) </summary>
<p>The signature of the method <code>transfer</code> is given below:</p>
<p>转账(<code>transfer</code>)方法的签名如下：</p>
<pre><code>public fun transfer&lt;CoinType: drop&gt;(from: &amp;signer, to: address, amount: u64, _witness: CoinType) acquires Balance
</code></pre>
<p>The method transfers the <code>amount</code> of coin from the account of <code>from</code> to the address <code>to</code>. The specification is given below:</p>
<p>该方法将数量为 <code>amount</code> 的代币从帐户 <code>from</code> 转账给地址 <code>to</code>。规范如下：</p>
<pre><code>    spec transfer {
        let addr_from = signer::address_of(from);

        let balance_from = global&lt;Balance&lt;CoinType&gt;&gt;(addr_from).coin.value;
        let balance_to = global&lt;Balance&lt;CoinType&gt;&gt;(to).coin.value;
        let post balance_from_post = global&lt;Balance&lt;CoinType&gt;&gt;(addr_from).coin.value;
        let post balance_to_post = global&lt;Balance&lt;CoinType&gt;&gt;(to).coin.value;

        ensures balance_from_post == balance_from - amount;
        ensures balance_to_post == balance_to + amount;
    }
</code></pre>
<p><code>addr_from</code> is the address of <code>from</code>. Then the balances of <code>addr_from</code> and <code>to</code> before and after the execution are obtained.
The <code>ensures</code> clauses specify that the <code>amount</code> number of tokens is deducted from <code>addr_from</code> and added to <code>to</code>. However, the prover will generate the error information as below:</p>
<p><code>addr_from</code> 是账户 <code>from</code> 的地址，然后获取执行前两个地址 <code>addr_from</code> 和 <code>to</code> 的余额。
<code>ensures</code> 子句指定从 <code>addr_from</code> 减去 <code>amount</code> 数量的代币，添加到 <code>to</code>。然而，验证器会生成以下错误：</p>
<pre><code>error: post-condition does not hold
   ┌─ ./sources/BasicCoin.move:57:9
   │
62 │         ensures balance_from_post == balance_from - amount;
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   │
   ...
</code></pre>
<p>The property is not held when <code>addr_from</code> is equal to <code>to</code>. As a result, we could add an assertion <code>assert!(from_addr != to)</code> in the method to make sure that <code>addr_from</code> is not equal to <code>to</code>.</p>
<p>当 <code>addr_from</code> 等于 <code>to</code> 时，这个属性无效。因此，我们可以在方法中添加一个断言，<code>assert!(from_addr != to)</code> 来确保 <code>addr_from</code> 不等于 <code>to</code>。</p>
</details>
<details>
<summary> 练习 (Exercises) </summary>
<ul>
<li>Implement the <code>aborts_if</code> conditions for the <code>transfer</code> method.</li>
<li>为<code> transfer</code> 方法实现 <code>aborts_if</code> 条件。</li>
<li>Implement the specification for the <code>mint</code> and <code>publish_balance</code> method.</li>
<li>为 <code>mint</code> 和 <code>publish_balance</code> 方法实现规范。</li>
</ul>
<p>The solution to this exercise can be found in <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_8_sol"><code>step_8_sol</code></a>.</p>
<p>练习的解答可以在 <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial/step_8_sol"><code>step_8_sol</code></a>中找到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整数-integers"><a class="header" href="#整数-integers">整数 (Integers)</a></h1>
<p>Move supports three unsigned integer types: <code>u8</code>, <code>u64</code>, and <code>u128</code>. Values of these types range from 0 to a maximum that depends on the size of the type.</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Value Range</th></tr></thead><tbody>
<tr><td>Unsigned 8-bit integer, <code>u8</code></td><td>0 to 2<sup>8</sup> - 1</td></tr>
<tr><td>Unsigned 64-bit integer, <code>u64</code></td><td>0 to 2<sup>64</sup> - 1</td></tr>
<tr><td>Unsigned 128-bit integer, <code>u128</code></td><td>0 to 2<sup>128</sup> - 1</td></tr>
</tbody></table>
</div>
<p>Move 支持三种无符号整数类型：<code>u8</code>、<code>u64</code> 和 <code>u128</code>。这些类型的值范围从 0 到最大值，最大值的具体取值取决于整数类型。</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>取值范围</th></tr></thead><tbody>
<tr><td>无符号 8位 整数, <code>u8</code></td><td>0 to 2<sup>8</sup> - 1</td></tr>
<tr><td>无符号 64位 整数, <code>u64</code></td><td>0 to 2<sup>64</sup> - 1</td></tr>
<tr><td>无符号 128位 整数, <code>u128</code></td><td>0 to 2<sup>128</sup> - 1</td></tr>
</tbody></table>
</div>
<h2 id="字面值literal"><a class="header" href="#字面值literal">字面值(Literal)</a></h2>
<p>Literal values for these types are specified either as a sequence of digits (e.g.,<code>112</code>) or as hex literals, e.g., <code>0xFF</code>. The type of the literal can optionally be added as a suffix, e.g., <code>112u8</code>. If the type is not specified, the compiler will try to infer the type from the context where the literal is used. If the type cannot be inferred, it is assumed to be <code>u64</code>.</p>
<p>If a literal is too large for its specified (or inferred) size range, an error is reported.</p>
<p>(在Move中)这些类型的字面值指定为数字序列(例如：112)或十六进制文字(例如：0xFF), 可以选择将字面值的类型定义为后缀, 例如 <code>112u8</code>。如果未指定类型，编译器将尝试从使用字面值的上下文推断类型。如果无法推断类型，则默认为 `u64。</p>
<p>如果字面值太大，超出其指定的(或推断的)大小范围，则会报错。</p>
<h3 id="例如"><a class="header" href="#例如">例如：</a></h3>
<pre><code class="language-jsx">// literals with explicit annotations;
let explicit_u8 = 1u8;
let explicit_u64 = 2u64;
let explicit_u128 = 3u128;

// literals with simple inference
let simple_u8: u8 = 1;
let simple_u64: u64 = 2;
let simple_u128: u128 = 3;

// literals with more complex inference
let complex_u8 = 1; // inferred: u8
// right hand argument to shift must be u8
let _unused = 10 &lt;&lt; complex_u8;

let x: u8 = 0;
let complex_u8 = 2; // inferred: u8
// arguments to `+` must have the same type
let _unused = x + complex_u8;

let complex_u128 = 3; // inferred: u128
// inferred from function argument type
function_that_takes_u128(complex_u128);

// literals can be written in hex
let hex_u8: u8 = 0x1;
let hex_u64: u64 = 0xCAFE;
let hex_u128: u128 = 0xDEADBEEF;
</code></pre>
<h2 id="运算集-operations"><a class="header" href="#运算集-operations">运算集 (Operations)</a></h2>
<h3 id="算术运算-arithmetic"><a class="header" href="#算术运算-arithmetic">算术运算 (Arithmetic)</a></h3>
<p>Each of these types supports the same set of checked arithmetic operations. For all of these operations, both arguments (the left and right side operands) must be of the same type. If you need to operate over values of different types, you will need to first perform a cast. Similarly, if you expect the result of the operation to be too large for the integer type, perform a cast to a larger size before performing the operation.</p>
<p>每一种(无符号整数)类型都支持相同算术运算集。对于所有这些运算，两个参数(左侧和右侧操作数)必须是同一类型。如果您需要对不同类型的值进行运算，则需要首先执行强制转换。同样，如果您预计运算结果对于当下整数类型来说太大，请在执行运算之前将之转换为更大的整数类型。</p>
<p>All arithmetic operations abort instead of behaving in a way that mathematical integers would not (e.g., overflow, underflow, divide-by-zero).</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts If</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>addition</td><td>Result is too large for the integer type</td></tr>
<tr><td><code>-</code></td><td>subtraction</td><td>Result is less than zero</td></tr>
<tr><td><code>*</code></td><td>multiplication</td><td>Result is too large for the integer type</td></tr>
<tr><td><code>%</code></td><td>modular division</td><td>The divisor is <code>0</code></td></tr>
<tr><td><code>/</code></td><td>truncating division</td><td>The divisor is <code>0</code></td></tr>
</tbody></table>
</div>
<h3 id="bitwise"><a class="header" href="#bitwise"><a href="https://move-language.github.io/move/integers.html#bitwise">Bitwise</a></a></h3>
<p>算术运算在遇到异常时将会中止，而不是以上溢、下溢、被零除等数学整数未定义的的方式输出结果。</p>
<div class="table-wrapper"><table><thead><tr><th>句法</th><th>操作</th><th>中止条件</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>加法</td><td>结果对于整数类型来说太大了</td></tr>
<tr><td><code>-</code></td><td>减法</td><td>结果小于零</td></tr>
<tr><td><code>*</code></td><td>乘法</td><td>结果对于整数类型来说太大了</td></tr>
<tr><td><code>%</code></td><td>取余运算</td><td>除数为 <code>0</code></td></tr>
<tr><td><code>/</code></td><td>截断除法</td><td>除数为 <code>0</code></td></tr>
</tbody></table>
</div>
<h3 id="位运算-bitwise"><a class="header" href="#位运算-bitwise">位运算 (Bitwise)</a></h3>
<p>The integer types support the following bitwise operations that treat each number as a series of individual bits, either 0 or 1, instead of as numerical integer values.</p>
<p>Bitwise operations do not abort.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&amp;</code></td><td>bitwise and</td><td>Performs a boolean and for each bit pairwise</td></tr>
<tr><td>`</td><td>`</td><td>bitwise or</td></tr>
<tr><td><code>^</code></td><td>bitwise xor</td><td>Performs a boolean exclusive or for each bit pairwise</td></tr>
</tbody></table>
</div>
<p>整数类型支持下列位运算，即将每个数字视为一系列单独的位：0 或 1，而不是整型数值。</p>
<p>位运算不会中止。</p>
<div class="table-wrapper"><table><thead><tr><th>句法</th><th>操作</th><th>描述</th></tr></thead><tbody>
<tr><td><code>&amp;</code></td><td>按位 和</td><td>对每个位成对执行布尔值和</td></tr>
<tr><td>`</td><td>`</td><td>按位或</td></tr>
<tr><td><code>^</code></td><td>按位 异与</td><td>对每个位成对执行布尔异或</td></tr>
</tbody></table>
</div>
<h3 id="位移-bit-shift"><a class="header" href="#位移-bit-shift">位移 (Bit shift)</a></h3>
<p>Similar to the bitwise operations, each integer type supports bit shifts. But unlike the other operations, the righthand side operand (how many bits to shift by) must <em>always</em> be a <code>u8</code> and need not match the left side operand (the number you are shifting).</p>
<p>Bit shifts can abort if the number of bits to shift by is greater than or equal to <code>8</code>, <code>64</code>, or <code>128</code> for <code>u8</code>, <code>u64</code>, and <code>u128</code> respectively.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts if</th></tr></thead><tbody>
<tr><td><code>&lt;&lt;</code></td><td>shift left</td><td>Number of bits to shift by is greater than the size of the integer type</td></tr>
<tr><td><code>&gt;&gt;</code></td><td>shift right</td><td>Number of bits to shift by is greater than the size of the integer type</td></tr>
</tbody></table>
</div>
<p>与按位运算类似，每种整数类型都支持位移(bit shifts)。但与其他运算不同的是，右侧操作数(要移位多少位)必须始终是 <code>u8</code>  并且不需要与左侧操作数类型(您要移位的数字)匹配。</p>
<p>如果要移位的位数分别大于或等于 <code>8</code>、<code>64</code>, <code>u128</code> 或 <code>128</code> 的 <code>u8</code>, <code>u64</code>, 则移位可以中止。</p>
<div class="table-wrapper"><table><thead><tr><th>句法</th><th>操作</th><th>中止条件</th></tr></thead><tbody>
<tr><td><code>&lt;&lt;</code></td><td>左移</td><td>要移位的位数大于整数类型的大小</td></tr>
<tr><td><code>&gt;&gt;</code></td><td>右移</td><td>要移位的位数大于整数类型的大小</td></tr>
</tbody></table>
</div>
<h3 id="比较运算-comparisons"><a class="header" href="#比较运算-comparisons">比较运算 (Comparisons)</a></h3>
<p>Integer types are the <em>only</em> types in Move that can use the comparison operators. Both arguments need to be of the same type. If you need to compare integers of different types, you will need to <a href="https://move-language.github.io/move/integers.html#casting">cast</a> one of them first.</p>
<p>Comparison operations do not abort.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th></tr></thead><tbody>
<tr><td><code>&lt;</code></td><td>less than</td></tr>
<tr><td><code>&gt;</code></td><td>greater than</td></tr>
<tr><td><code>&lt;=</code></td><td>less than or equal to</td></tr>
<tr><td><code>&gt;=</code></td><td>greater than or equal to</td></tr>
</tbody></table>
</div>
<p>整数类型是 Move 中唯一可以使用比较(Comparisons)运算符的类型。两个参数必须是同一类型。如果您需要比较不同类型的整数，则需要先转换其中一个。</p>
<p>比较操作不会中止。</p>
<div class="table-wrapper"><table><thead><tr><th>句法</th><th>操作</th></tr></thead><tbody>
<tr><td><code>&lt;</code></td><td>小于</td></tr>
<tr><td><code>&gt;</code></td><td>大于</td></tr>
<tr><td><code>&lt;=</code></td><td>小于等于</td></tr>
<tr><td><code>&gt;=</code></td><td>大于等于</td></tr>
</tbody></table>
</div>
<h3 id="相等-equality"><a class="header" href="#相等-equality">相等 (Equality)</a></h3>
<p>Like all types with <a href="https://move-language.github.io/move/abilities.html"><code>drop</code></a> in Move, all integer types support the <a href="https://move-language.github.io/move/equality.html">&quot;equal&quot;</a> and <a href="https://move-language.github.io/move/equality.html">&quot;not equal&quot;</a> operations. Both arguments need to be of the same type. If you need to compare integers of different types, you will need to <a href="https://move-language.github.io/move/integers.html#casting">cast</a> one of them first.</p>
<p>Equality operations do not abort.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>equal</td></tr>
<tr><td><code>!=</code></td><td>not equal</td></tr>
</tbody></table>
</div>
<p>For more details see the section on <a href="https://move-language.github.io/move/equality.html">equality</a></p>
<p>与 Move 中的所有具有<a href="./chapter_19_abilities.html"><code>drop</code></a>能力的类型一样，所有整数类型都支持 <a href="./chapter_11_equality.html">&quot;equal(等于)&quot;</a> 和 <a href="./chapter_11_equality.html">&quot;not equal(不等于)</a>运算。两个参数必须是同一类型。如果您需要比较不同类型的整数，则需要先转换其中一个。</p>
<p>相等(Equality)运算不会中止。</p>
<div class="table-wrapper"><table><thead><tr><th>句法</th><th>操作</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>等于</td></tr>
<tr><td><code>!=</code></td><td>不等于</td></tr>
</tbody></table>
</div>
<p>更多细节可以参考<a href="%5Bequality%5D(https://move-language.github.io/move/equality.html)">相等</a>章节。</p>
<h2 id="转换-casting"><a class="header" href="#转换-casting">转换 (Casting)</a></h2>
<p>Integer types of one size can be cast to integer types of another size. Integers are the only types in Move that support casting.</p>
<p>Casts <em>do not</em> truncate. Casting will abort if the result is too large for the specified type</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts if</th></tr></thead><tbody>
<tr><td><code>(e as T)</code></td><td>Cast integer expression <code>e</code> into an integer type <code>T</code></td><td><code>e</code> is too large to represent as a <code>T</code></td></tr>
</tbody></table>
</div>
<p>Here, the type of <code>e</code> must be <code>u8</code>, <code>u64</code>, or <code>u128</code> and <code>T</code> must be <code>u8</code>, <code>u64</code>, or <code>u128</code>.</p>
<p>For example:</p>
<ul>
<li><code>(x as u8)</code></li>
<li><code>(2u8 as u64)</code></li>
<li><code>(1 + 3 as u128)</code></li>
</ul>
<p>一种大小的整数类型可以转换为另一种大小的整数类型。整数是 Move 中唯一支持强制转换的类型。</p>
<p>强制转换不会截断。如果结果对于指定类型来说太大，则转换将中止。</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>操作</th><th>中止条件</th></tr></thead><tbody>
<tr><td><code>(e as T)</code></td><td>将整数表达式 <code>e</code> 转换为整数类型 <code>T</code></td><td><code>e</code> 太大而不能表示为 <code>T</code></td></tr>
</tbody></table>
</div>
<h2 id="所有权-ownership"><a class="header" href="#所有权-ownership">所有权 (Ownership)</a></h2>
<p>As with the other scalar values built-in to the language, integer values are implicitly copyable, meaning they can be copied without an explicit instruction such as <a href="https://move-language.github.io/move/variables.html#move-and-copy"><code>copy</code></a>.</p>
<p>与语言内置的其他标量值一样，整数值是隐式可复制的，这意味着它们可以在没有明确指令如<a href="variables.html#move-and-copy"><code>copy</code></a>的情况下复制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布尔类型-bool"><a class="header" href="#布尔类型-bool">布尔类型 (Bool)</a></h1>
<p><code>bool</code>is Move's primitive type for boolean <code>true</code> and <code>false</code>values.</p>
<p><code>bool</code> 是 Move 布尔基本类型，有 <code>true</code> 和 <code>false</code> 两个值。</p>
<h2 id="字面量-literals"><a class="header" href="#字面量-literals">字面量 (Literals)</a></h2>
<p>Literals for <code>bool</code> are either <code>true</code> or <code>false</code> .</p>
<p>布尔类型字面值只能是 <code>true</code> 或者 <code>false</code>中的一个 。</p>
<h2 id="操作-operations"><a class="header" href="#操作-operations">操作 (Operations)</a></h2>
<h3 id="逻辑运算-logical"><a class="header" href="#逻辑运算-logical">逻辑运算 (Logical)</a></h3>
<p><code>bool</code>supports three logical operations:</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Description</th><th>Equivalent Expression</th></tr></thead><tbody>
<tr><td><code>&amp;&amp;</code></td><td>short-circuiting logical and</td><td><code>p &amp;&amp; q</code> is equivalent to <code>if (p) q else false</code></td></tr>
<tr><td><code>||</code></td><td>short-circuiting logical or</td><td><code>p || q</code> is equivalent to <code>if (p) true else q</code></td></tr>
<tr><td><code>!</code></td><td>logical negation</td><td><code>!p</code> is equivalent to <code>if (p) false else true</code></td></tr>
</tbody></table>
</div>
<p><code>bool</code> 支持三种逻辑运算：</p>
<div class="table-wrapper"><table><thead><tr><th>句法</th><th>描述</th><th>Equivalent Expression</th></tr></thead><tbody>
<tr><td><code>&amp;&amp;</code></td><td>短路逻辑与(short-circuiting logical and)</td><td><code>p &amp;&amp; q</code> 等价于 <code>if (p) q else false</code></td></tr>
<tr><td><code>||</code></td><td>短路逻辑或(short-circuiting logical or)</td><td>`p</td></tr>
<tr><td><code>!</code></td><td>逻辑非(logical negation)</td><td><code>!p</code> 等价于 <code>if (p) false else true</code></td></tr>
</tbody></table>
</div>
<h3 id="控制流-control-flow"><a class="header" href="#控制流-control-flow">控制流 (Control Flow)</a></h3>
<p><code>bool</code>values are used in several of Move's control-flow constructs:</p>
<p>布尔值用于 Move 的多个控制流结构中：</p>
<ul>
<li><a href="./conditionals.html"><code>if (bool) { ... }</code></a></li>
<li><a href="/loops.html"><code>while (bool) { .. }</code></a></li>
<li><a href="./abort-and-assert.html"><code>assert!(bool, u64)</code></a></li>
</ul>
<h2 id="所有权-ownership-1"><a class="header" href="#所有权-ownership-1">所有权 (Ownership)</a></h2>
<p>As with the other scalar values built-in to the language, boolean values are implicitly copyable, meaning they can be copied without an explicit instruction such as <code>[copy](&lt;https://move-language.github.io/move/variables.html#move-and-copy&gt;).</code></p>
<p>与语言内置的其他标量值一样，布尔值是隐式可复制的，这意味着它们可以在没有明确指令如<a href="variables.html#move-and-copy"><code>copy</code></a>的情况下复制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="地址"><a class="header" href="#地址">地址</a></h1>
<p><code>地址（address）</code>是 Move 中的内置类型，用于表示全局存储中的的位置（有时称为账户）。<code>地址（address）</code> 值是一个 128 位（16 字节）标识符。在一个给定的地址，可以存储两样东西：<a href="modules-and-scripts.html">模块（Module）</a>和<a href="structs-and-resources.html">资源（Resources）</a>。</p>
<p>虽然<code>地址（address）</code>在底层是一个 128 位整数，但 Move 语言有意让其不透明 —— 它们不能从整数创建，不支持算术运算，也不能修改。即使可能有一些有趣的程序会使用这种特性（例如，C 中的指针算法实现了类似壁龛（niche）的功能），但 Move 语言不允许这种动态行为，因为它从头开始就被设计为支持静态验证。<em>（壁龛指安装在墙壁上的小格子或在墙身上留出的作为贮藏设施的空间，最早在宗教上是指排放佛像的小空间，现在多用在家庭装修上，因其不占建筑面积，使用比较方便，深受大家喜爱，Joe 注）</em></p>
<p>你可以通过运行时地址值（<code>address</code> 类型的值）来访问该地址处的资源。但<em>无法</em>在运行时通过地址值访问模块。</p>
<h2 id="地址及其语法"><a class="header" href="#地址及其语法">地址及其语法</a></h2>
<p>地址有两种形式：<em>命名的</em>或<em>数值的</em>。命名地址的语法遵循 Move 命名标识符的规则。数值地址的语法不受十六进制编码值的限制，任何有效的 <a href="integers.html"><code>u128</code> 数值</a>都可以用作地址值。例如，<code>42</code>，<code>0xCFAE</code> 和 <code>2021</code> 都是合法有效的数值地址字面量（literal）。</p>
<p>为了区分何时在表达式上下文中使用地址，使用地址时的语法根据使用地址的上下文而有所不同：</p>
<ul>
<li>当地址被用作表达式时，地址必须以 <code>@</code> 字符为前缀，例如：<a href="integers.html"><code>@&lt;numerical_value&gt;</code></a> 或 <code>@&lt;named_address_identifier&gt;</code>。</li>
<li>在表达式上下文之外，地址可以不带前缀字符 <code>@</code>。例如：<a href="integers.html"><code>&lt;numerical_value&gt;</code></a> 或 <code>&lt;named_address_identifier&gt;</code>。</li>
</ul>
<p>通常，可以将 <code>@</code> 视为将地址从命名空间项变为表达式项的运算符。</p>
<h2 id="命名地址"><a class="header" href="#命名地址">命名地址</a></h2>
<p>命名地址是一项特性，它允许在使用地址的任何地方使用标识符代替数值，而不仅仅是在值级别。命名地址被声明并绑定为 Move 包中的顶级元素（模块和脚本之外）或作为参数传递给 Move 编译器。</p>
<p>命名地址仅存在于源语言级别，并将在字节码级别完全替代它们的值。因此，模块和模块成员<em>必须</em>通过模块的命名地址而不是编译期间分配给命名地址的数值来访问，例如：<code>use my_addr::foo</code> <em>不等于</em> <code>use 0x2::foo</code>，即使 Move 程序编译时将 <code>my_addr</code> 设置成 <code>0x2</code>。这个区别在<a href="modules-and-scripts.html">模块和脚本</a>一节中有更详细的讨论。</p>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<pre><code class="language-move">let a1: address = @0x1; // 0x00000000000000000000000000000001 的缩写
let a2: address = @0x42; // 0x00000000000000000000000000000042 的缩写
let a3: address = @0xDEADBEEF; // 0x000000000000000000000000DEADBEEF 的缩写
let a4: address = @0x0000000000000000000000000000000A;
let a5: address = @std; // 将命名地址 `std` 的值赋给 `a5`
let a6: address = @66;
let a7: address = @0x42;

module 66::some_module {   // 不在表达式上下文中，所以不需要 @
    use 0x1::other_module; // 不在表达式上下文中，所以不需要 @
    use std::vector;       // 使用其他模块时，可以使用命名地址作为命名空间项
    ...
}

module std::other_module {  // 可以使用命名地址作为命名空间项来声明模块
    ...
}
</code></pre>
<h2 id="全局存储操作"><a class="header" href="#全局存储操作">全局存储操作</a></h2>
<p><code>address</code> 值主要用来与全局存储操作进行交互。</p>
<p><code>address</code> 值与 <code>exists</code>、<code>borrow_global</code>、<code>borrow_global_mut</code> 和 <code>move_from</code> <a href="global-storage-operators.html">操作（operation）</a>一起使用。</p>
<p>唯一<em>不使用</em> <code>address</code> 的全局存储操作是 <code>move_to</code>，它使用了 <a href="signer.html"><code>signer</code></a>。</p>
<h2 id="所有权"><a class="header" href="#所有权">所有权</a></h2>
<p>与 Move 语言内置的其他标量值一样，<code>address</code> 值是隐式可复制的，这意味着它们可以在没有显式指令（例如 <a href="variables.html#%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%A4%8D%E5%88%B6"><code>copy</code></a>）的情况下复制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="向量"><a class="header" href="#向量">向量</a></h1>
<p><code>vector&lt;T&gt;</code> 是 Move 提供的唯一原始集合类型。<code>vector&lt;T&gt;</code> 是类型为 <code>T</code> 的同构集合，可以通过从&quot;末端&quot;推入/弹出（出栈/入栈，译者注）值来增长或缩小。
<em>（与 Rust 一样，向量（vector）是一种可以存放任何类型的可变大小的容器，也可称为<a href="https://en.wikipedia.org/wiki/Dynamic_array">动态数组</a>，与 Python 中的<a href="https://computersciencewiki.org/index.php/Lists">列表（list）</a>不同，译者注）</em></p>
<p><code>vector&lt;T&gt;</code> 可以用任何类型 <code>T</code> 实例化。例如，<code>vector&lt;u64&gt;</code>、<code>vector&lt;address&gt;</code>、<code>vector&lt;0x42::MyModuel::MyResource&gt;</code> 和 <code>vector&lt;vector&lt;u8&gt;&gt;</code> 都是有效的向量类型。</p>
<h2 id="字面量"><a class="header" href="#字面量">字面量</a></h2>
<h3 id="通用-vector-字面量"><a class="header" href="#通用-vector-字面量">通用 <code>vector</code> 字面量</a></h3>
<p>任何类型的向量都可以通过 <code>vector</code> 字面量创建。</p>
<div class="table-wrapper"><table><thead><tr><th>语法</th><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td><code>vector[]</code></td><td><code>vector[]: vector&lt;T&gt;</code> 其中 <code>T</code> 是任何单一的非引用类型</td><td>一个空向量</td></tr>
<tr><td><code>vector[e1, ..., en]</code></td><td><code>vector[e1, ..., en]: vector&lt;T&gt;</code> where <code>e_i: T</code> 满足 <code>0 &lt; i &lt;= n</code> and <code>n &gt; 0</code></td><td>带有 <code>n</code> 个元素（长度为 n）的向量</td></tr>
</tbody></table>
</div>
<p>在这些情况下，<code>vector</code> 的类型是从元素类型或从向量的使用上推断出来的。如果无法推断类型或者只是为了更清楚地表示，则可以显式指定类型：</p>
<pre><code class="language-move">vector&lt;T&gt;[]: vector&lt;T&gt;
vector&lt;T&gt;[e1, ..., en]: vector&lt;T&gt;
</code></pre>
<h4 id="向量字面量示例"><a class="header" href="#向量字面量示例">向量字面量示例</a></h4>
<pre><code class="language-move">(vector[]: vector&lt;bool&gt;);
(vector[0u8, 1u8, 2u8]: vector&lt;u8&gt;);
(vector&lt;u128&gt;[]: vector&lt;u128&gt;);
(vector&lt;address&gt;[@0x42, @0x100]: vector&lt;address&gt;);
</code></pre>
<h3 id="vectoru8-字面量"><a class="header" href="#vectoru8-字面量"><code>vector&lt;u8&gt;</code> 字面量</a></h3>
<p>Move 中向量的一个常见用例是表示“字节数组”，用 <code>vector&lt;u8&gt;</code> 表示。这些值通常用于加密目的，例如公钥或哈希结果。这些值非常常见，以至于提供了特定的语法以使值更具可读性，而不是必须使用 <code>vector[]</code>，其中每个单独的 <code>u8</code> 值都以数字形式指定。</p>
<p>目前支持两种类型的 <code>vector&lt;u8&gt;</code> 字面量，<em>字节字符串</em>和<em>十六进制字符串</em>。</p>
<h4 id="字节字符串"><a class="header" href="#字节字符串">字节字符串</a></h4>
<p>字节字符串是带引号的字符串字面量，以 <code>b</code> 为前缀，例如，<code>b&quot;Hello!\n&quot;</code>。</p>
<p>这些是允许转义序列的 ASCII 编码字符串。目前，支持的转义序列如下：</p>
<div class="table-wrapper"><table><thead><tr><th>转义序列</th><th>描述</th></tr></thead><tbody>
<tr><td><code>\n</code></td><td>换行</td></tr>
<tr><td><code>\r</code></td><td>回车</td></tr>
<tr><td><code>\t</code></td><td>制表符</td></tr>
<tr><td><code>\\</code></td><td>反斜杠</td></tr>
<tr><td><code>\0</code></td><td>Null</td></tr>
<tr><td><code>\&quot;</code></td><td>引号</td></tr>
<tr><td><code>\xHH</code></td><td>十六进制进制转义，插入十六进制字节序列 <code>HH</code></td></tr>
</tbody></table>
</div>
<h4 id="十六进制字符串"><a class="header" href="#十六进制字符串">十六进制字符串</a></h4>
<p>十六进制字符串是以 <code>x</code> 为前缀的带引号的字符串字面量，例如，<code>x&quot;48656C6C6F210A&quot;</code>。</p>
<p>每个字节对，范围从 <code>00</code> 到 <code>FF</code> 都被解析为十六进制编码的 <code>u8</code> 值。所以每个字节对对应于结果 <code>vector&lt;u8&gt;</code> 的单个条目。</p>
<h4 id="字符串字面量示例"><a class="header" href="#字符串字面量示例">字符串字面量示例</a></h4>
<pre><code class="language-move">script {
    fun byte_and_hex_strings() {
        assert!(b&quot;&quot; == x&quot;&quot;, 0);
        assert!(b&quot;Hello!\n&quot; == x&quot;48656C6C6F210A&quot;, 1);
        assert!(b&quot;\x48\x65\x6C\x6C\x6F\x21\x0A&quot; == x&quot;48656C6C6F210A&quot;, 2);
        assert!(
            b&quot;\&quot;Hello\tworld!\&quot;\n \r \\Null=\0&quot; ==
                x&quot;2248656C6C6F09776F726C6421220A200D205C4E756C6C3D00&quot;,
            3
        );
    }
}
</code></pre>
<h2 id="操作"><a class="header" href="#操作">操作</a></h2>
<p><code>vector</code> 通过 Move 标准库里的 <code>std::vector</code> 模块支持以下操作：</p>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th><th>中止条件</th></tr></thead><tbody>
<tr><td><code>vector::empty&lt;T&gt;(): vector&lt;T&gt;</code></td><td>创建一个可以存储 <code>T</code> 类型值的空向量</td><td>永不中止</td></tr>
<tr><td><code>vector::singleton&lt;T&gt;(t: T): vector&lt;T&gt;</code></td><td>创建一个包含 <code>t</code> 的大小为 1 的向量</td><td>永不中止</td></tr>
<tr><td><code>vector::push_back&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, t: T)</code></td><td>将 <code>t</code> 添加到 <code>v</code> 的尾部</td><td>永不中止</td></tr>
<tr><td><code>vector::pop_back&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): T</code></td><td>移除并返回 <code>v</code> 中的最后一个元素</td><td>如果 <code>v</code> 是空向量</td></tr>
<tr><td><code>vector::borrow&lt;T&gt;(v: &amp;vector&lt;T&gt;, i: u64): &amp;T</code></td><td>返回在索引 <code>i</code> 处对 <code>T</code> 的不可变引用</td><td>如果 <code>i</code> 越界</td></tr>
<tr><td><code>vector::borrow_mut&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64): &amp;mut T</code></td><td>返回在索引 <code>i</code> 处对 <code>T</code> 的可变引用</td><td>如果 <code>i</code> 越界</td></tr>
<tr><td><code>vector::destroy_empty&lt;T&gt;(v: vector&lt;T&gt;)</code></td><td>销毁 <code>v</code> 向量</td><td>如果 <code>v</code> 不是空向量</td></tr>
<tr><td><code>vector::append&lt;T&gt;(v1: &amp;mut vector&lt;T&gt;, v2: vector&lt;T&gt;)</code></td><td>将 <code>v2</code> 中的元素添加到 <code>v1</code> 的末尾</td><td>永不中止</td></tr>
<tr><td><code>vector::contains&lt;T&gt;(v: &amp;vector&lt;T&gt;, e: &amp;T): bool</code></td><td>如果 <code>e</code> 在向量 <code>v</code> 里返回 true，否则返回 false</td><td>永不中止</td></tr>
<tr><td><code>vector::swap&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64, j: u64)</code></td><td>交换向量 <code>v</code> 中第 <code>i</code> 个和第 <code>j</code> 个索引处的元素</td><td>如果 <code>i</code> 或 <code>j</code> 越界</td></tr>
<tr><td><code>vector::reverse&lt;T&gt;(v: &amp;mut vector&lt;T&gt;)</code></td><td>反转向量 <code>v</code> 中元素的顺序</td><td>永不中止</td></tr>
<tr><td><code>vector::index_of&lt;T&gt;(v: &amp;vector&lt;T&gt;, e: &amp;T): (bool, u64)</code></td><td>如果 <code>e</code> 在索引 <code>i</code> 处的向量中，则返回 <code>(true, i)</code>。否则返回<code>(false, 0)</code></td><td>永不中止</td></tr>
<tr><td><code>vector::remove&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64): T</code></td><td>移除向量 <code>v</code> 中的第 <code>i</code> 个元素，移动所有后续元素。这里的时间复杂度是 O(n)，并且保留了向量中元素的顺序</td><td>如果 <code>i</code> 越界</td></tr>
<tr><td><code>vector::swap_remove&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64): T</code></td><td>将向量中的第 <code>i</code> 个元素与最后一个元素交换，然后弹出该元素。这里的时间复杂度是 O(1)，但是不保留向量中的元素顺序</td><td>如果 <code>i</code> 越界</td></tr>
</tbody></table>
</div>
<p>随着时间的推移可能会增加更多操作。</p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<pre><code class="language-move">use std::vector;

let v = vector::empty&lt;u64&gt;();
vector::push_back(&amp;mut v, 5);
vector::push_back(&amp;mut v, 6);

assert!(*vector::borrow(&amp;v, 0) == 5, 42);
assert!(*vector::borrow(&amp;v, 1) == 6, 42);
assert!(vector::pop_back(&amp;mut v) == 6, 42);
assert!(vector::pop_back(&amp;mut v) == 5, 42);
</code></pre>
<h2 id="销毁和复制-vector"><a class="header" href="#销毁和复制-vector">销毁和复制 <code>vector</code></a></h2>
<p><code>vector&lt;T&gt;</code> 的某些行为取决于元素类型 <code>T</code> 的能力（ability），例如：如果向量中包含不具有 <code>drop</code> 能力的元素，那么不能像上面例子中的 <code>v</code> 一样隐式丢弃 —— 它们必须用 <code>vector::destroy_empty</code> 显式销毁。</p>
<p>请注意，除非向量 <code>vec</code> 包含零个元素，否则 <code>vector::destroy_empty</code> 将在运行时中止：</p>
<pre><code class="language-move">fun destroy_any_vector&lt;T&gt;(vec: vector&lt;T&gt;) {
    vector::destroy_empty(vec) // 删除此行将导致编译器错误
}
</code></pre>
<p>但是删除包含带有 <code>drop</code> 能力的元素的向量不会发生错误：</p>
<pre><code class="language-move">fun destroy_droppable_vector&lt;T: drop&gt;(vec: vector&lt;T&gt;) {
    // 有效！
    // 不需要明确地做任何事情来销毁向量
}
</code></pre>
<p>同样，除非元素类型具有 <code>copy</code> 能力，否则无法复制向量。换句话说，当且仅当 <code>T</code> 具有 <code>copy</code> 能力时，<code>vector&lt;T&gt;</code> 才具有 <code>copy</code> 能力。然而，即使是可复制的向量也永远不会被隐式复制：</p>
<pre><code class="language-move">let x = vector::singleton&lt;u64&gt;(10);
let y = copy x; // 没有 copy 将导致编译器错误！
</code></pre>
<p>大向量的复制可能很昂贵，因此编译器需要显式 <code>copy</code> 以便更容易查看它们发生的位置。</p>
<p>有关更多详细信息，请参阅<a href="abilities.html">类型能力</a>和<a href="generics.html">泛型</a>部分。</p>
<h2 id="所有权-1"><a class="header" href="#所有权-1">所有权</a></h2>
<p><a href="vector.html#%E9%94%80%E6%AF%81%E5%92%8C%E5%A4%8D%E5%88%B6-vector">如上所述</a>，<code>vector</code> 值只有在元素值可以复制的时候才能复制。在这种情况下，复制必须通过显式 <a href="variables.html#%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%A4%8D%E5%88%B6"><code>copy</code></a> 或者<a href="references.html#%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5">解引用 <code>*</code></a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="签名者"><a class="header" href="#签名者">签名者</a></h1>
<p><code>签名者（signer）</code>是 Move 内置的资源类型。<code>签名者（signer）</code>是一种允许持有者代表特定<code>地址（address）</code>行使权力的<a href="https://en.wikipedia.org/wiki/Object-capability_model">能力（capability）</a>。你可以将原生实现（native implementation）视为：</p>
<pre><code class="language-move">struct signer has drop { a: address }
</code></pre>
<p><code>signer</code> 有点像 Unix <a href="https://en.wikipedia.org/wiki/User_identifier">UID</a>，因为它表示一个通过 Move <em>之外</em>的代码（例如，通过检查加密签名或密码）进行身份验证的用户。</p>
<h2 id="与-address-的比较"><a class="header" href="#与-address-的比较">与 <code>address</code> 的比较</a></h2>
<p>Move 程序可以使用地址字面量（literal）创建任何<code>地址（address）</code>值，而无需特殊许可：</p>
<pre><code class="language-move">let a1 = @0x1;
let a2 = @0x2;
// ... 等等，所有其他可能的地址
</code></pre>
<p>但是，<code>signer</code> 值是特殊的，因为它们不能通过字面量或者指令创建 —— 只能通过 Move 虚拟机（VM）创建。在虚拟机运行带有 <code>signer</code> 类型参数的脚本之前，它会自动创建 <code>signer</code> 值并将它们传递给脚本：</p>
<pre><code class="language-move">script {
    use std::signer;
    fun main(s: signer) {
        assert!(signer::address_of(&amp;s) == @0x42, 0);
    }
}
</code></pre>
<p>如果脚本是从 <code>0x42</code> 以外的任何地址发送的，则此脚本将中止并返回代码 <code>0</code>。</p>
<p>交易脚本可以有任意数量的 <code>signer</code>，只要 <code>signer</code> 参数排在其他参数前面。换句话说，所有 <code>signer</code> 参数都必须放在第一位。</p>
<pre><code class="language-move">script {
    use std::signer;
    fun main(s1: signer, s2: signer, x: u64, y: u8) {
        // ...
    }
}
</code></pre>
<p>这对于实现具有多方权限原子行为的*多重签名脚本（multi-signer scripts）*很有用。例如，上述脚本的扩展可以在 <code>s1</code> 和 <code>s2</code> 之间执行原子货币交换。</p>
<h2 id="signer-操作符"><a class="header" href="#signer-操作符"><code>signer</code> 操作符</a></h2>
<p><code>std::signer</code> 标准库模块为 <code>signer</code> 提供了两个实用函数：</p>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td><code>signer::address_of(&amp;signer): address</code></td><td>返回由 <code>&amp;signer</code> 包装的地址值。</td></tr>
<tr><td><code>signer::borrow_address(&amp;signer): &amp;address</code></td><td>返回由 <code>&amp;signer</code> 包装的地址的引用。</td></tr>
</tbody></table>
</div>
<p>此外，<code>move_to&lt;T&gt;(&amp;signer, T)</code> <a href="global-storage-operators.html">全局存储</a>操作符需要一个 <code>&amp;signer</code> 参数在 <code>signer.address</code> 的帐户下发布资源 <code>T</code>。这确保了只有经过身份验证的用户才能在其地址下发布资源。</p>
<h2 id="所有权-2"><a class="header" href="#所有权-2">所有权</a></h2>
<p>与简单的标量值不同，<code>signer</code> 值是不可复制的，这意味着他们不能被复制（通过任何操作，无论是通过显式 <a href="variables.html#%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%A4%8D%E5%88%B6"><code>copy</code></a>指令还是通过<a href="references.html#%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5">解引用（dereference）<code>*</code></a>）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引用references"><a class="header" href="#引用references">引用(references)</a></h1>
<p>Move has two types of references: immutable <code>&amp;</code> and mutable <code>&amp;mut</code>. Immutable references are read
only, and cannot modify the underlying value (or any of its fields). Mutable references allow for
modifications via a write through that reference. Move's type system enforces an ownership
discipline that prevents reference errors.</p>
<p>Move 支持两种类型的引用：不可变引用 <code>&amp;</code> 和可变引用 <code>&amp;mut</code>。不可变引用是只读的，不能修改相关值(或其任何字段)。可变引用通过写入该引用进行修改。Move的类型系统强制执行所有权规则，以避免引用错误。</p>
<p>For more details on the rules of references, see <a href="structs-and-resources.html">Structs and Resources</a></p>
<p>更多有关引用规则的详细信息，请参阅：<a href="./structs-and-resources.html">结构和资源</a>.</p>
<h2 id="引用运算符-reference-operators"><a class="header" href="#引用运算符-reference-operators">引用运算符 (Reference Operators)</a></h2>
<p>Move provides operators for creating and extending references as well as converting a mutable
reference to an immutable one. Here and elsewhere, we use the notation <code>e: T</code> for &quot;expression <code>e</code>
has type <code>T</code>&quot;.</p>
<p>Move 提供了用于创建和扩展引用以及将可变引用转换为不可变引用的运算符。在这里和其他地方，我们使用符号 <code>e: T</code> 来表示“表达式 <code>e</code> 的类型是 <code>T</code> ”</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&amp;e</code></td><td><code>&amp;T</code> where <code>e: T</code> and <code>T</code> is a non-reference type</td><td>Create an immutable reference to <code>e</code></td></tr>
<tr><td><code>&amp;mut e</code></td><td><code>&amp;mut T</code> where <code>e: T</code> and <code>T</code> is a non-reference type</td><td>Create a mutable reference to <code>e</code>.</td></tr>
<tr><td><code>&amp;e.f</code></td><td><code>&amp;T</code> where <code>e.f: T</code></td><td>Create an immutable reference to field <code>f</code> of struct <code>e</code>.</td></tr>
<tr><td><code>&amp;mut e.f</code></td><td><code>&amp;mut T</code> where <code>e.f: T</code></td><td>Create a mutable reference to field <code>f</code> of struct<code>e</code>.</td></tr>
<tr><td><code>freeze(e)</code></td><td><code>&amp;T</code> where <code>e: &amp;mut T</code></td><td>Convert the mutable reference <code>e</code> into an immutable reference.</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>语法</th><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td><code>&amp;e</code></td><td><code>&amp;T</code> 其中 <code>e: T</code> 和 <code>T</code> 是非引用类型</td><td>创建一个不可变的引用 <code>e</code></td></tr>
<tr><td><code>&amp;mut e</code></td><td><code>&amp;mut T</code> 其中 <code>e: T</code> 和 <code>T</code> 是非引用类型</td><td>创建一个可变的引用 <code>e</code></td></tr>
<tr><td><code>&amp;e.f</code></td><td><code>&amp;T</code> 其中 <code>e.f: T</code></td><td>创建结构 <code>e</code> 的字段 <code>f</code> 的不可变引用</td></tr>
<tr><td><code>&amp;mut e.f</code></td><td><code>&amp;mut T</code> 其中<code>e.f: T</code></td><td>创建结构 <code>e</code> 的字段 <code>f</code> 的可变引用</td></tr>
<tr><td><code>freeze(e)</code></td><td><code>&amp;T</code> 其中<code>e: &amp;mut T</code></td><td>将可变引用 <code>e</code> 转换为不可变引用</td></tr>
</tbody></table>
</div>
<p>The <code>&amp;e.f</code> and <code>&amp;mut e.f</code> operators can be used both to create a new reference into a struct or to extend an existing reference:</p>
<p><code>&amp;e.f</code>和<code>&amp;mut e.f</code>运算符既可以用于在结构中创建新引用，也可以用于扩展现有引用：</p>
<pre><code class="language-move">let s = S { f: 10 };
let f_ref1: &amp;u64 = &amp;s.f; // works
let s_ref: &amp;S = &amp;s;
let f_ref2: &amp;u64 = &amp;s_ref.f // also works
</code></pre>
<p>A reference expression with multiple fields works as long as both structs are in the same module:</p>
<p>只要两个结构都在同一个模块中，具有多个字段的引用表达式就可以工作：</p>
<pre><code class="language-move">struct A { b: B }
struct B { c : u64 }
fun f(a: &amp;A): &amp;u64 {
  &amp;a.b.c
}
</code></pre>
<p>Finally, note that references to references are not allowed:</p>
<p>最后，请注意，不允许引用&quot;引用&quot;(Move不支持多重引用, 但Rust可以，译者注)：</p>
<pre><code class="language-move">let x = 7;
let y: &amp;u64 = &amp;x;
let z: &amp;&amp;u64 = &amp;y; // will not compile
</code></pre>
<h2 id="通过引用读取和写入"><a class="header" href="#通过引用读取和写入">通过引用读取和写入</a></h2>
<p>Both mutable and immutable references can be read to produce a copy of the referenced value.</p>
<p>Only mutable references can be written. A write <code>*x = v</code> discards the value previously stored in <code>x</code>
and updates it with <code>v</code>.</p>
<p>可以读取可变和不可变引用以生成引用值的副本。</p>
<p>只能写入可变引用。写入表达式 <code>*x = v</code> 会丢弃先前存储在x中的值，并用 <code>v</code> 更新。</p>
<p>Both operations use the C-like <code>*</code> syntax. However, note that a read is an expression, whereas a
write is a mutation that must occur on the left hand side of an equals.</p>
<p>两种操作都使用类 C <code>*</code> 语法。但是请注意，读取是一个表达式，而写入是一个必须发生在等号左侧的改动。</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>*e</code></td><td><code>T</code> where <code>e</code> is <code>&amp;T</code> or <code>&amp;mut T</code></td><td>Read the value pointed to by <code>e</code></td></tr>
<tr><td><code>*e1 = e2</code></td><td><code>()</code> where <code>e1: &amp;mut T</code> and <code>e2: T</code></td><td>Update the value in <code>e1</code> with <code>e2</code>.</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>语法</th><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td><code>&amp;e</code></td><td><code>T</code> 其中 <code>e</code> 为 <code>&amp;T</code> 或 <code>&amp;mut T</code></td><td>读取 <code>e</code> 所指向的值</td></tr>
<tr><td><code>*e1 = e2</code></td><td>() 其中 <code>e1: &amp;mut T</code> 和 <code>e2: T</code></td><td>用 <code>e2</code> 更新 <code>e1</code> 中的值</td></tr>
</tbody></table>
</div>
<p>In order for a reference to be read, the underlying type must have the
<a href="abilities.html"><code>copy</code> ability</a> as reading the reference creates a new copy of the value. This rule
prevents the copying of resource values:</p>
<p>为了读取引用，相关类型必须具备<a href="./abilities.html"><code>copy</code> 能力</a>，因为读取引用会创建值的新副本。此规则防止复制资源值：</p>
<pre><code class="language-move=">fun copy_resource_via_ref_bad(c: Coin) {
    let c_ref = &amp;c;
    let counterfeit: Coin = *c_ref; // not allowed!
    pay(c);
    pay(counterfeit);
}
</code></pre>
<p>Dually: in order for a reference to be written to, the underlying type must have the
<a href="abilities.html"><code>drop</code> ability</a> as writing to the reference will discard (or &quot;drop&quot;) the old value.
This rule prevents the destruction of resource values:</p>
<p>双重性：为了写入引用，相关类型必须具备<a href="./abilities.html"><code>drop</code> 能力</a>，因为写入引用将丢弃(或“删除”)旧值。此规则可防止破坏资源值：</p>
<pre><code class="language-move=">fun destroy_resource_via_ref_bad(ten_coins: Coin, c: Coin) {
    let ref = &amp;mut ten_coins;
    *ref = c; // not allowed--would destroy 10 coins!
}
</code></pre>
<h2 id="freeze-推断-freeze-inference"><a class="header" href="#freeze-推断-freeze-inference"><code>freeze</code> 推断 (<code>freeze</code> inference)</a></h2>
<p>A mutable reference can be used in a context where an immutable reference is expected:</p>
<p>可变引用可以在预期不可变引用的上下文中使用：</p>
<pre><code class="language-move">let x = 7;
let y: &amp;mut u64 = &amp;mut x;
</code></pre>
<p>This works because the under the hood, the compiler inserts <code>freeze</code> instructions where they are
needed. Here are a few more examples of <code>freeze</code> inference in action:</p>
<p>这是因为编译器会在底层需要的地方插入 <code>freeze</code> 指令。以下是更多 <code>freeze</code> 实际推断行为的示例：</p>
<pre><code class="language-move=">fun takes_immut_returns_immut(x: &amp;u64): &amp;u64 { x }

// freeze inference on return value
fun takes_mut_returns_immut(x: &amp;mut u64): &amp;u64 { x }

fun expression_examples() {
    let x = 0;
    let y = 0;
    takes_immut_returns_immut(&amp;x); // no inference
    takes_immut_returns_immut(&amp;mut x); // inferred freeze(&amp;mut x)
    takes_mut_returns_immut(&amp;mut x); // no inference

    assert!(&amp;x == &amp;mut y, 42); // inferred freeze(&amp;mut y)
}

fun assignment_examples() {
    let x = 0;
    let y = 0;
    let imm_ref: &amp;u64 = &amp;x;

    imm_ref = &amp;x; // no inference
    imm_ref = &amp;mut y; // inferred freeze(&amp;mut y)
}
</code></pre>
<h3 id="子类型化-subtyping"><a class="header" href="#子类型化-subtyping">子类型化 (Subtyping)</a></h3>
<p>With this <code>freeze</code> inference, the Move type checker can view <code>&amp;mut T</code> as a subtype of <code>&amp;T</code>. As shown
above, this means that anywhere for any expression where a <code>&amp;T</code> value is used, a <code>&amp;mut T</code> value can
also be used. This terminology is used in error messages to concisely indicate that a <code>&amp;mut T</code> was
needed where a <code>&amp;T</code> was supplied. For example</p>
<p>通过freeze推断，Move 类型检查器可以将 <code>&amp;mut T</code> 视为 <code>&amp;T</code> 的子类型。 如上所示，这意味着对于使用 <code>&amp;T</code> 值的任何表达式，也可以使用 <code>&amp;mut T</code> 值。此术语用于错误消息中，以简明扼要地表明在提供 <code>&amp;T</code> 的地方需要 <code>&amp;mut T</code> 。例如:</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {
            *store = *new_value
        }

        fun subtype_examples() {
            let x: &amp;u64 = &amp;0;
            let y: &amp;mut u64 = &amp;mut 1;

            x = &amp;mut 1; // valid
            y = &amp;2; // invalid!

            read_and_assign(y, x); // valid
            read_and_assign(x, y); // invalid!
        }
    }
}
</code></pre>
<p>will yield the following error messages</p>
<p>将产生以下错误消息</p>
<pre><code class="language-text">error:
    ┌── example.move:12:9 ───
    │
 12 │         y = &amp;2; // invalid!
    │         ^ Invalid assignment to local 'y'
    ·
 12 │         y = &amp;2; // invalid!
    │             -- The type: '&amp;{integer}'
    ·
  9 │         let y: &amp;mut u64 = &amp;mut 1;
    │                -------- Is not a subtype of: '&amp;mut u64'
    │

error:
    ┌── example.move:15:9 ───
    │
 15 │         read_and_assign(x, y); // invalid!
    │         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of '0x42::example::read_and_assign'. Invalid argument for parameter 'store'
    ·
  8 │         let x: &amp;u64 = &amp;0;
    │                ---- The type: '&amp;u64'
    ·
  3 │     fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {
    │                                -------- Is not a subtype of: '&amp;mut u64'
    │
</code></pre>
<p>The only other types currently that has subtyping are <a href="tuples.html">tuples</a></p>
<p>当前唯一具有子类型的其他类型是<a href="./tuples.html">tuple(元组)</a></p>
<h2 id="所有权-ownership-2"><a class="header" href="#所有权-ownership-2">所有权 (Ownership)</a></h2>
<p>Both mutable and immutable references can always be copied and extended <em>even if there are existing
copies or extensions of the same reference</em>:</p>
<p><em>即使同一引用存在现有副本或扩展</em>，可变引用和不可变引用始终可以被复制和扩展：</p>
<pre><code class="language-move">fun reference_copies(s: &amp;mut S) {
  let s_copy1 = s; // ok
  let s_extension = &amp;mut s.f; // also ok
  let s_copy2 = s; // still ok
  ...
}
</code></pre>
<p>This might be surprising for programmers familiar with Rust's ownership system, which would reject
the code above. Move's type system is more permissive in its treatment of
<a href="variables.html#move-and-copy">copies</a>, but equally strict in ensuring unique ownership of mutable
references before writes.</p>
<p>对于熟悉 Rust 所有权系统的程序员来说，这可能会令人惊讶，因为他们会拒绝上面的代码。Move 的类型系统在处理<a href="./variables.html#move-and-copy">副本</a>方面更加宽松 ，但在写入前确保可变引用的唯一所有权方面同样严格。</p>
<h3 id="无法存储引用-references-cannot-be-stored"><a class="header" href="#无法存储引用-references-cannot-be-stored">无法存储引用 (References Cannot Be Stored)</a></h3>
<p>References and tuples are the <em>only</em> types that cannot be stored as a field value of structs, which
also means that they cannot exist in global storage. All references created during program execution
will be destroyed when a Move program terminates; they are entirely ephemeral. This invariant is
also true for values of types without the <code>store</code> <a href="abilities.html">ability</a>, but note that
references and tuples go a step further by never being allowed in structs in the first place.</p>
<p>This is another difference between Move and Rust, which allows references to be stored inside of
structs.</p>
<p>引用和元组是唯一不能存储为结构的字段值的类型，这也意味着它们不能存在于全局存储中。当 Move 程序终止时，程序执行期间创建的所有引用都将被销毁；它们完全是短暂的。这种不变式也适用于没有<a href="./chatper_19_abilities.html"><code>store</code> 能力</a>的类型的值，但请注意，引用和元组更进一步，从一开始就不允许出现在结构中。</p>
<p>这是 Move 和 Rust 之间的另一个区别，后者允许将引用存储在结构内。</p>
<p>Currently, Move cannot support this because references cannot be
<a href="https://en.wikipedia.org/wiki/Serialization">serialized</a>, but <em>every Move value must be
serializable</em>. This requirement comes from Move's
<a href="global-storage-structure.html">persistent global storage</a>, which needs to serialize values to
persist them across program executions. Structs can be written to global storage, and thus they must
be serializable.</p>
<p>One could imagine a fancier, more expressive, type system that would allow references to be stored
in structs <em>and</em> ban those structs from existing in global storage. We could perhaps allow
references inside of structs that do not have the <code>store</code> <a href="abilities.html">ability</a>, but that would
not completely solve the problem: Move has a fairly complex system for tracking static reference
safety, and this aspect of the type system would also have to be extended to support storing
references inside of structs. In short, Move's type system (particularly the aspects around
reference safety) would have to expand to support stored references. But it is something we are
keeping an eye on as the language evolves.</p>
<p>目前，Move 无法支持这一点，因为引用无法被<a href="https://en.wikipedia.org/wiki/Serialization">序列化</a>，但 <em>每个 Move 值都必须是可序列化的</em>。这个要求来自于 Move 的 <a href="./global-storage-structure.html">持久化全局存储</a>，它需要在程序执行期间序列化值以持久化它们。结构体可以写入全局存储，因此它们必须是可序列化的。</p>
<p>可以想象一种更奇特、更有表现力的类型系统，它允许将引用存储在结构中，并禁止这些结构存在于全局存储中。我们也许可以允许在没有<a href="./abilities.html"><code>store</code> 能力</a>的结构内部使用引用，但这并不能完全解决问题：Move 有一个相当复杂的系统来跟踪静态引用安全性，并且类型系统的这一方面也必须扩展以支持在结构内部存储引用。简而言之，Move 的类型系统(尤其是与引用安全相关的方面)需要扩展以支持存储的引用。随着语言的发展，我们正在关注这一点。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组和单值"><a class="header" href="#元组和单值">元组和单值</a></h1>
<p>Move 不完全支持元组，因为人们可能期望像来自另一种语言的元组一样将它们作为<a href="https://zh.wikipedia.org/wiki/%E9%A0%AD%E7%AD%89%E7%89%A9%E4%BB%B6">头等值（即头等公民）</a>。但是，为了支持多个返回值，Move 具有类似元组的表达式。这些表达式在运行时不会产生具体的值（字节码中没有元组），因此它们非常有限：它们只能出现在表达式中（通常在函数的返回位置）；它们不能绑定到局部变量；它们不能存储在结构中；元组类型不能用于实例化泛型。</p>
<p>类似地，<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%80%BC%E7%B1%BB%E5%9E%8B">单值（unit）<code>()</code></a> 是 Move 源语言创建的一种以表达式为基础的类型。单值 <code>()</code> 不会产生任何运行时值。我们可以认为单值 <code>()</code> 是一个空元组，适用于元组的任何限制也适用于单值。</p>
<p>考虑到这些限制，在语言中使用元组可能会感觉很奇怪。但其他语言中，元组最常见的用例之一是函数 —— 允许函数返回多个值。一些语言通过强制用户编写包含多个返回值的结构来解决这个问题。但是在 Move 中，您不能将引用放在<a href="structs-and-resources.html">结构体</a>中。这需要 Move 支持多个返回值。这些多个返回值都在字节码级别被压入到堆栈中。在源码级别，这些多个返回值使用元组表示。</p>
<h2 id="字面量-1"><a class="header" href="#字面量-1">字面量</a></h2>
<p>元组（tuple）是由括号内以逗号分隔的表达式列表创建的。</p>
<div class="table-wrapper"><table><thead><tr><th>语法</th><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td><code>()</code></td><td><code>(): ()</code></td><td>单值、空元组或 0 元素元组</td></tr>
<tr><td><code>(e1, ..., en)</code></td><td><code>(e1, ..., en): (T1, ..., Tn)</code> 其中 <code>e_i: Ti</code> 满足 <code>0 &lt; i &lt;= n</code> and <code>n &gt; 0</code></td><td>n 元组、n 元素元组、带有 n 个元素的元组</td></tr>
</tbody></table>
</div>
<p>注意 <code>(e)</code> 没有类型 <code>(e): (t)</code>，换句话说，没有一个元素的元组。如果括号内只有一个元素，则括号仅用于消除歧义，不带有任何其他特殊含义。</p>
<p>有时，具有两个元素的元组称为“二元组（pairs）”，而具有三个元素的元组称为“三元组（triples）”。</p>
<h3 id="例子-1"><a class="header" href="#例子-1">例子</a></h3>
<pre><code class="language-move">address 0x42 {
module example {
    // 这三个函数都是等价的

    // 当没有提供返回类型时，假定为 `()`
    fun returns_unit_1() { }

    // 空表达式块中存在隐式 () 值
    fun returns_unit_2(): () { }

    // `returns_unit_1` 和 `returns_unit_2` 的显式版本
    fun returns_unit_3(): () { () }


    fun returns_3_values(): (u64, bool, address) {
        (0, false, @0x42)
    }
    fun returns_4_values(x: &amp;u64): (&amp;u64, u8, u128, vector&lt;u8&gt;) {
        (x, 0, 1, b&quot;foobar&quot;)
    }
}
}
</code></pre>
<h2 id="操作-1"><a class="header" href="#操作-1">操作</a></h2>
<p>目前唯一可以对元组执行的操作是解构（destructuring）。</p>
<h3 id="解构"><a class="header" href="#解构">解构</a></h3>
<p>对于任何大小的元组，它们可以在 <code>let</code> 绑定或赋值中被解构。</p>
<p>例如：</p>
<pre><code class="language-move">address 0x42 {
module example {
    // 这三个函数都是等价的
    fun returns_unit() {}
    fun returns_2_values(): (bool, bool) { (true, false) }
    fun returns_4_values(x: &amp;u64): (&amp;u64, u8, u128, vector&lt;u8&gt;) { (x, 0, 1, b&quot;foobar&quot;) }

    fun examples(cond: bool) {
        let () = ();
        let (x, y): (u8, u64) = (0, 1);
        let (a, b, c, d) = (@0x0, 0, false, b&quot;&quot;);

        () = ();
        (x, y) = if (cond) (1, 2) else (3, 4);
        (a, b, c, d) = (@0x1, 1, true, b&quot;1&quot;);
    }

    fun examples_with_function_calls() {
        let () = returns_unit();
        let (x, y): (bool, bool) = returns_2_values();
        let (a, b, c, d) = returns_4_values(&amp;0);

        () = returns_unit();
        (x, y) = returns_2_values();
        (a, b, c, d) = returns_4_values(&amp;1);
    }
}
}
</code></pre>
<p>有关更多详细信息，请参阅 <a href="variables.html">Move 变量</a>。</p>
<h2 id="子类型"><a class="header" href="#子类型">子类型</a></h2>
<p>除了引用，元组是唯一在 Move 中具有<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%B1%BB%E5%9E%8B">子类型（subtyping）</a>的类型。元组只有在具有引用的子类型（以协变方式）的意义上才具有子类型。</p>
<p>例如:</p>
<pre><code class="language-move">let x: &amp;u64 = &amp;0;
let y: &amp;mut u64 = &amp;mut 1;

// (&amp;u64, &amp;mut u64) 是 (&amp;u64, &amp;u64) 的子类型
// 因为 &amp;mut u64 是 &amp;u64 的子类型
let (a, b): (&amp;u64, &amp;u64) = (x, y);

// (&amp;mut u64, &amp;mut u64) 是 (&amp;u64, &amp;u64) 的子类型
// 因为 &amp;mut u64 是 &amp;u64 的子类型
let (c, d): (&amp;u64, &amp;u64) = (y, y);

// 错误！(&amp;u64, &amp;mut u64) 不是 (&amp;mut u64, &amp;mut u64) 的子类型
// 因为 &amp;u64 不是 &amp;mut u64 的子类型
let (e, f): (&amp;mut u64, &amp;mut u64) = (x, y);
</code></pre>
<h2 id="所有权-3"><a class="header" href="#所有权-3">所有权</a></h2>
<p>如上所述，元组值在运行时并不真正存在。由于这个原因，目前它们不能存储到局部变量中（但这个功能很可能很快就会出现）。因此，元组目前只能移动，因为复制它们需要先将它们放入局部变量中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="局部变量和作用域local-variables-and-scopes"><a class="header" href="#局部变量和作用域local-variables-and-scopes">局部变量和作用域（Local Variables and Scopes）</a></h1>
<p>Local variables in Move are lexically (statically) scoped. New variables are introduced with the
keyword <code>let</code>, which will shadow any previous local with the same name. Locals are mutable and can
be updated both directly and via a mutable reference.</p>
<p>在 Move 语言中，局部变量的解析依赖于词法作用域（lexically scoped）或静态作用域（statically scoped）。使用关键字 <code>let</code> 引入新的变量，它将隐藏任何以前的同名局部变量。局部变量是可变的（Rust 中的变量默认不可变，译者注），可以直接更新，也可以通过可变引用更新。</p>
<h2 id="声明局部变量declaring-local-variables"><a class="header" href="#声明局部变量declaring-local-variables">声明局部变量（Declaring Local Variables）</a></h2>
<h3 id="let-绑定let-bindings"><a class="header" href="#let-绑定let-bindings"><code>let</code> 绑定（<code>let</code> bindings）</a></h3>
<p>Move programs use <code>let</code> to bind variable names to values:</p>
<p>Move 程序使用 <code>let</code> 给变量名绑定一个值：</p>
<pre><code class="language-move">let x = 1;
let y = x + x:
</code></pre>
<p><code>let</code> can also be used without binding a value to the local.</p>
<p><code>let</code> 使用时也可以不绑定任何数值给局部变量。</p>
<pre><code class="language-move">let x;
</code></pre>
<p>The local can then be assigned a value later.</p>
<p>然后可以稍后为局部变量赋一个值。</p>
<pre><code class="language-move">let x;
if (cond) {
  x = 1
} else {
  x = 0
}
</code></pre>
<p>This can be very helpful when trying to extract a value from a loop when a default value cannot be provided.</p>
<p>当无法提供默认值时，这在尝试从循环中提取值时非常有用。</p>
<pre><code class="language-move">let x;
let cond = true;
let i = 0;
loop {
    (x, cond) = foo(i);
    if (!cond) break;
    i = i + 1;
}
</code></pre>
<h3 id="变量必须在使用前赋值variables-must-be-assigned-before-use"><a class="header" href="#变量必须在使用前赋值variables-must-be-assigned-before-use">变量必须在使用前赋值（Variables must be assigned before use）</a></h3>
<p>Move's type system prevents a local variable from being used before it has been assigned.</p>
<p>Move 的类型系统防止在赋值之前使用局部变量。</p>
<pre><code class="language-move">let x;
x + x // ERROR!
</code></pre>
<pre><code class="language-move">let x;
if (cond) x = 0;
x + x // ERROR!
</code></pre>
<pre><code class="language-move">let x;
while (cond) x = 0;
x + x // ERROR!
</code></pre>
<h3 id="有效的变量名valid-variable-names"><a class="header" href="#有效的变量名valid-variable-names">有效的变量名（Valid variable names）</a></h3>
<p>Variable names can contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, and digits <code>0</code>
to <code>9</code>. Variable names must start with either an underscore <code>_</code> or a letter <code>a</code> through <code>z</code>. They
<em>cannot</em> start with uppercase letters.</p>
<p>变量名可以包含下划线 <code>_</code>、小写字母 <code>a</code> 到 <code>z</code>、大写字母 <code>A</code> 到 <code>Z</code>、和数字 <code>0</code> 到 <code>9</code>。变量名必须以下划线 <code>_</code> 或者以小写字母<code>a</code>到<code>z</code>开头。它们<em>不能</em>以大写字母开头。</p>
<pre><code class="language-move">// 全部有效
let x = e;
let _x = e;
let _A = e;
let x0 = e;
let xA = e;
let foobar_123 = e;

// 全部无效
let X = e; // ERROR!
let Foo = e; // ERROR!
</code></pre>
<h3 id="类型标注type-annotations"><a class="header" href="#类型标注type-annotations">类型标注（Type annotations）</a></h3>
<p>The type of a local variable can almost always be inferred by Move's type system. However, Move
allows explicit type annotations that can be useful for readability, clarity, or debuggability. The
syntax for adding a type annotation is:</p>
<p>局部变量的类型几乎总是可以通过 Move 的类型系统推断出来。但是，Move 允许显式类型标注，这对可读性、清晰性或可调试性很有用。添加类型标注的语法如下：</p>
<pre><code class="language-move">let x: T = e; // “T 类型的变量 x 被初始化为表达式 e”
</code></pre>
<p>Some examples of explicit type annotations:</p>
<p>一些显式类型标注的示例：</p>
<pre><code class="language-move">address 0x42 {
module example {

    struct S { f: u64, g: u64 }

    fun annotated() {
        let u: u8 = 0;
        let b: vector&lt;u8&gt; = b&quot;hello&quot;;
        let a: address = @0x0;
        let (x, y): (&amp;u64, &amp;mut u64) = (&amp;0, &amp;mut 1);
        let S { f, g: f2 }: S = S { f: 0, g: 1 };
    }
}
}
</code></pre>
<p>Note that the type annotations must always be to the right of the pattern:</p>
<p>请注意，类型标注必须始终位于变量模式的右侧：</p>
<pre><code class="language-move">let (x: &amp;u64, y: &amp;mut u64) = (&amp;0, &amp;mut 1); // 错误！正确写法是 let (x, y): ... =
</code></pre>
<h3 id="何时需要类型标注when-annotations-are-necessary"><a class="header" href="#何时需要类型标注when-annotations-are-necessary">何时需要类型标注（When annotations are necessary）</a></h3>
<p>In some cases, a local type annotation is required if the type system cannot infer the type. This
commonly occurs when the type argument for a generic type cannot be inferred. For example:</p>
<p>在某些情况下，如果类型系统无法推断类型，则需要局部类型标注。这通常发生在无法推断某个泛型（generic type）的类型参数时，比如：</p>
<pre><code class="language-move">let _v1 = vector::empty(); // 错误！
//        ^^^^^^^^^^^^^^^ Could not infer this type. Try adding an annotation （无法推断此类型。尝试添加标注）
let v2: vector&lt;u64&gt; = vector::empty(); // 没有错误
</code></pre>
<p>In a rarer case, the type system might not be able to infer a type for divergent code (where all the
following code is unreachable). Both <code>return</code> and <a href="abort-and-assert.html"><code>abort</code></a> are expressions
and can have any type. A <a href="loops.html"><code>loop</code></a> has type <code>()</code> if it has a <code>break</code>, but if there is no
break out of the <code>loop</code>, it could have any type. If these types cannot be inferred, a type
annotation is required. For example, this code:</p>
<p>在极少数情况下，Move 的类型系统可能无法推断出一段发散式代码（divergent code）的类型（后面所有代码无法访问）。在 Move 语言中，<code>return</code> 和 <a href="abort-and-assert.html"><code>abort</code></a> 都属于表达式，它们可以返回任何类型。如果一段 <a href="loops.html"><code>loop</code></a> 有 <code>break</code>，那么它的返回类型是 <code>()</code>，但是如果它不包含 <code>break</code>，它的返回类型可以是任何类型。如果无法推断出这些类型，那么类型标注是必须的。例如，这段代码：</p>
<pre><code class="language-move">let a: u8 = return ();
let b: bool = abort 0;
let c: signer = loop ();

let x = return (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let y = abort 0; // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let z = loop (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
</code></pre>
<p>Adding type annotations to this code will expose other errors about dead code or unused local
variables, but the example is still helpful for understanding this problem.</p>
<p>在这段代码中添加类型标注会暴露其他关于死代码或未使用的局部变量的错误，但该示例仍然有助于理解这个问题。</p>
<h3 id="元组式的多个变量声明multiple-declarations-with-tuples"><a class="header" href="#元组式的多个变量声明multiple-declarations-with-tuples">元组式的多个变量声明（Multiple declarations with tuples）</a></h3>
<p><code>let</code> can introduce more than one local at a time using tuples. The locals declared inside the
parenthesis are initialized to the corresponding values from the tuple.</p>
<p><code>let</code> 可以使用元组一次引入多个局部变量。在括号内声明的局部变量会被初始化为元组中的对应值。</p>
<pre><code class="language-move">let () = ();
let (x0, x1) = (0, 1);
let (y0, y1, y2) = (0, 1, 2);
let (z0, z1, z2, z3) = (0, 1, 2, 3);
</code></pre>
<p>The type of the expression must match the arity of the tuple pattern exactly.</p>
<p>表达式的类型必须与元组模式的数量完全匹配。</p>
<pre><code class="language-move">let (x, y) = (0, 1, 2); // 错误！
let (x, y, z, q) = (0, 1, 2); // 错误！
</code></pre>
<p>You cannot declare more than one local with the same name in a single <code>let</code>.</p>
<p>你不能在单个 <code>let</code> 中声明多个具有相同名称的局部变量。</p>
<pre><code class="language-move">let (x, x) = 0; // 错误！
</code></pre>
<h3 id="结构体式的多个变量声明multiple-declarations-with-structs"><a class="header" href="#结构体式的多个变量声明multiple-declarations-with-structs">结构体式的多个变量声明（Multiple declarations with structs）</a></h3>
<p><code>let</code> can also introduce more than one local at a time when destructuring (or matching against) a
struct. In this form, the <code>let</code> creates a set of local variables that are initialized to the values
of the fields from a struct. The syntax looks like this:</p>
<p><code>let</code> 还可以在解构（或匹配）结构体时一次引入多个局部变量。在这种形式中，<code>let</code> 创建了一组局部变量，这些变量被初始化为结构体中字段的值。语法如下所示：</p>
<pre><code class="language-move">struct T { f1: u64, f2: u64 }
</code></pre>
<pre><code class="language-move">let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
</code></pre>
<p>Here is a more complicated example:</p>
<p>这是一个更复杂的示例：</p>
<pre><code class="language-move">address 0x42 {
    module example {
        struct X { f: u64 }
        struct Y { x1: X, x2: X }

        fun new_x(): X {
            X { f: 1 }
        }

        fun example() {
            let Y { x1: X { f }, x2 } = Y { x1: new_x(), x2: new_x() };
            assert!(f + x2.f == 2, 42);

            let Y { x1: X { f: f1 }, x2: X { f: f2 } } = Y { x1: new_x(), x2: new_x() };
            assert!(f1 + f2 == 2, 42);
        }
    }
}
</code></pre>
<p>Fields of structs can serve double duty, identifying the field to bind <em>and</em> the name of the
variable. This is sometimes referred to as punning.</p>
<p>结构体的字段可以起到双重作用：识别要绑定的字段<em>和</em>命名变量。这有时被称为双关语。</p>
<pre><code class="language-move">let X { f } = e;
</code></pre>
<p>is equivalent to:</p>
<p>等价于：</p>
<pre><code class="language-move">let X { f: f } = e;
</code></pre>
<p>As shown with tuples, you cannot declare more than one local with the same name in a single <code>let</code>.</p>
<p>如元组所示，您不能在单个 <code>let</code> 中声明多个具有相同名称的局部变量。</p>
<pre><code class="language-move">let Y { x1: x, x2: x } = e; // 错误！（两个 x 同名了）
</code></pre>
<h3 id="针对引用进行解构destructuring-against-references"><a class="header" href="#针对引用进行解构destructuring-against-references">针对引用进行解构（Destructuring against references）</a></h3>
<p>In the examples above for structs, the bound value in the let was moved, destroying the struct value
and binding its fields.</p>
<p>在上面的结构体示例中，<code>let</code> 中绑定的值被移动了，这销毁了结构体的值并同时绑定了它的字段（到变量）。</p>
<pre><code class="language-move">struct T { f1: u64, f2: u64 }
</code></pre>
<pre><code class="language-move">let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
</code></pre>
<p>In this scenario the struct value <code>T { f1: 1, f2: 2 }</code> no longer exists after the <code>let</code>.</p>
<p>If you wish instead to not move and destroy the struct value, you can borrow each of its fields. For
example:</p>
<p>在这种场景下结构体的值 <code>T { f1: 1, f2: 2 }</code> 会在 <code>let</code> 后消失。</p>
<p>如果您希望不移动和销毁结构体的值，则可以借用其中的每个字段。例如：</p>
<pre><code class="language-move">let t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &amp;t;
// local1: &amp;u64
// local2: &amp;u64
</code></pre>
<p>And similarly with mutable references:</p>
<p>可变引用也类似：</p>
<pre><code class="language-move">let t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &amp;mut t;
// local1: &amp;mut u64
// local2: &amp;mut u64
</code></pre>
<p>This behavior can also work with nested structs.</p>
<p>此行为也适用于嵌套结构体。</p>
<pre><code class="language-move">address 0x42 {
    module example {
        struct X { f: u64 }
        struct Y { x1: X, x2: X }

        fun new_x(): X {
            X { f: 1 }
        }

        fun example() {
            let y = Y { x1: new_x(), x2: new_x() };

            let Y { x1: X { f }, x2 } = &amp;y;
            assert!(*f + x2.f == 2, 42);

            let Y { x1: X { f: f1 }, x2: X { f: f2 } } = &amp;mut y;
            *f1 = *f1 + 1;
            *f2 = *f2 + 1;
            assert!(*f1 + *f2 == 4, 42);
        }
    }
}
</code></pre>
<h3 id="忽略值ignoring-values"><a class="header" href="#忽略值ignoring-values">忽略值（Ignoring Values）</a></h3>
<p>In <code>let</code> bindings, it is often helpful to ignore some values. Local variables that start with <code>_</code>
will be ignored and not introduce a new variable</p>
<p>在 <code>let</code> 绑定中，忽略某些值通常很有帮助。以 <code>_</code> 开头的局部变量将被忽略并且不会引入新变量。</p>
<pre><code class="language-move">fun three(): (u64, u64, u64) {
    (0, 1, 2)
}
</code></pre>
<pre><code class="language-move">let (x1, _, z1) = three();
let (x2, _y, z2) = three();
assert!(x1 + z1 == x2 + z2, 42);
</code></pre>
<p>This can be necessary at times as the compiler will error on unused local variables。</p>
<p>这有时是必要的，因为编译器会在未使用的局部变量上报错。</p>
<pre><code class="language-move">let (x1, y, z1) = three(); // 错误！
//       ^ 未被使用的局部变量 'y'
</code></pre>
<h3 id="通用的-let-语法general-let-grammar"><a class="header" href="#通用的-let-语法general-let-grammar">通用的 <code>let</code> 语法（General <code>let</code> grammar）</a></h3>
<p>All of the different structures in <code>let</code> can be combined! With that we arrive at this general
grammar for <code>let</code> statements:</p>
<p><code>let</code> 中所有不同的结构体都可以组合！这样，我们就得出了 <code>let</code> 语句的通用语法：</p>
<blockquote>
<p><em>let-binding</em> → <strong>let</strong> <em>pattern-or-list</em> <em>type-annotation</em><sub><em>opt</em></sub>
<em>initializer</em><sub><em>opt</em></sub> &gt; <em>pattern-or-list</em> → <em>pattern</em> | <strong>(</strong> <em>pattern-list</em> <strong>)</strong> &gt;
<em>pattern-list</em> → <em>pattern</em> <strong>,</strong><sub><em>opt</em></sub> | <em>pattern</em> <strong>,</strong> <em>pattern-list</em> &gt;
<em>type-annotation</em> → <strong>:</strong> <em>type</em> <em>initializer</em> → <strong>=</strong> <em>expression</em></p>
</blockquote>
<p>The general term for the item that introduces the bindings is a <em>pattern</em>. The pattern serves to
both destructure data (possibly recursively) and introduce the bindings. The pattern grammar is as
follows:</p>
<p>引入绑定的项的通用术语是 <em>模式（pattern）</em>。该模式用于解构数据（可能是递归的）并引入绑定。模式语法如下：</p>
<blockquote>
<p><em>pattern</em> → <em>local-variable</em> | <em>struct-type</em> <strong>{</strong> <em>field-binding-list</em> <strong>}</strong> &gt;
<em>field-binding-list</em> → <em>field-binding</em> <strong>,</strong><sub><em>opt</em></sub> | <em>field-binding</em> <strong>,</strong>
<em>field-binding-list</em> &gt; <em>field-binding</em> → <em>field</em> | <em>field</em> <strong>:</strong> <em>pattern</em></p>
</blockquote>
<p>A few concrete examples with this grammar applied:</p>
<p>应用此语法的一些具体示例：</p>
<pre><code class="language-move">    let (x, y): (u64, u64) = (0, 1);
//       ^                           local-variable（局部变量）
//       ^                           pattern（模式）
//          ^                        local-variable（局部变量）
//          ^                        pattern（模式）
//          ^                        pattern-list（模式列表）
//       ^^^^                        pattern-list（模式列表）
//      ^^^^^^                       pattern-or-list（模式或列表）
//            ^^^^^^^^^^^^           type-annotation（类型标注）
//                         ^^^^^^^^  initializer（初始化器）
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding（let 绑定）

    let Foo { f, g: x } = Foo { f: 0, g: 1 };
//      ^^^                                    struct-type（结构类型）
//            ^                                field（字段）
//            ^                                field-binding（字段绑定）
//               ^                             field（字段）
//                  ^                          local-variable（局部变量）
//                  ^                          pattern（模式）
//               ^^^^                          field-binding（字段绑定）
//            ^^^^^^^                          field-binding-list（字段绑定列表）
//      ^^^^^^^^^^^^^^^                        pattern（模式）
//      ^^^^^^^^^^^^^^^                        pattern-or-list（模式或列表）
//                      ^^^^^^^^^^^^^^^^^^^^   initializer（初始化器）
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding（let 绑定）
</code></pre>
<h2 id="变更mutations"><a class="header" href="#变更mutations">变更（Mutations）</a></h2>
<h3 id="赋值assignments"><a class="header" href="#赋值assignments">赋值（Assignments）</a></h3>
<p>After the local is introduced (either by <code>let</code> or as a function parameter), the local can be
modified via an assignment:</p>
<p>在引入局部变量后（通过 <code>let</code> 或作为函数参数），可以通过赋值来修改局部变量：</p>
<pre><code class="language-move">x = e
</code></pre>
<p>Unlike <code>let</code> bindings, assignments are expressions. In some languages, assignments return the value
that was assigned, but in Move, the type of any assignment is always <code>()</code>.</p>
<p>与 <code>let</code> 绑定不同，赋值是表达式。在某些语言中，赋值会返回被赋予的值，但在 Move 语言中，任何赋值的返回类型始终是 <code>()</code>。</p>
<pre><code class="language-move">(x = e: ())
</code></pre>
<p>Practically, assignments being expressions means that they can be used without adding a new
expression block with braces (<code>{</code>...<code>}</code>).</p>
<p>实际上，赋值作为表达式意味着它们可以在不添加带有大括号（<code>{</code>...<code>}</code>）的新表达式块（expression block）的情况下使用。</p>
<pre><code class="language-move">let x = 0;
if (cond) x = 1 else x = 2;
</code></pre>
<p>The assignment uses the same pattern syntax scheme as <code>let</code> bindings:</p>
<p>赋值使用与 <code>let</code> 绑定相同的模式语法方案：</p>
<pre><code class="language-move">address 0x42 {
module example {
    struct X { f: u64 }

    fun new_x(): X {
        X { f: 1 }
    }

    // 这个例子会因为存在未使用的变量和赋值而报错。
    fun example() {
       let (x, _, z) = (0, 1, 3);
       let (x, y, f, g);

       (X { f }, X { f: x }) = (new_x(), new_x());
       assert!(f + x == 2, 42);

       (x, y, z, f, _, g) = (0, 0, 0, 0, 0, 0);
    }
}
}
</code></pre>
<p>Note that a local variable can only have one type, so the type of the local cannot change between
assignments.</p>
<p>注意，一个局部变量只能有一种类型，所以局部变量的类型不能在赋值之间（多次赋值）改变。</p>
<pre><code class="language-move">let x;
x = 0;
x = false; // 错误！
</code></pre>
<h3 id="通过引用进行变更mutating-through-a-reference"><a class="header" href="#通过引用进行变更mutating-through-a-reference">通过引用进行变更（Mutating through a reference）</a></h3>
<p>In addition to directly modifying a local with assignment, a local can be modified via a mutable
reference <code>&amp;mut</code>.</p>
<p>除了通过赋值直接修改局部变量外，还可以通过可变引用 <code>&amp;mut</code> 的方式修改局部变量。</p>
<pre><code class="language-move">let x = 0;
let r = &amp;mut x;
*r = 1;
assert!(x == 1, 42);
</code></pre>
<p>This is particularly useful if either:</p>
<p>(1) You want to modify different variables depending on some condition.</p>
<p>这在以下情况下特别有用：</p>
<p>(1) 你想根据某些条件修改不同的变量。</p>
<pre><code class="language-move">let x = 0;
let y = 1;
let r = if (cond) &amp;mut x else &amp;mut y;
*r = *r + 1;
</code></pre>
<p>(2) You want another function to modify your local value.</p>
<p>(2) 你想要另一个函数来修改你的局部变量值。</p>
<pre><code class="language-move">let x = 0;
modify_ref(&amp;mut x);
</code></pre>
<p>This sort of modification is how you modify structs and vectors!</p>
<p>这种修改方法就是你修改结构体和向量的方式！</p>
<pre><code class="language-move">let v = vector::empty();
vector::push_back(&amp;mut v, 100);
assert!(*vector::borrow(&amp;v, 0) == 100, 42);
</code></pre>
<p>For more details, see <a href="references.html">Move references</a>.</p>
<p>有关更多详细信息，请参阅 <a href="references.html">Move 引用</a>。</p>
<h2 id="作用域scopes"><a class="header" href="#作用域scopes">作用域（Scopes）</a></h2>
<p>Any local declared with <code>let</code> is available for any subsequent expression, <em>within that scope</em>.
Scopes are declared with expression blocks, <code>{</code>...<code>}</code>.</p>
<p>Locals cannot be used outside of the declared scope.</p>
<p>使用 <code>let</code> 声明的任何局部变量都可用于<em>该作用域内</em>的任何后续表达式。作用域用表达式块（expression blocks）声明，<code>{</code>...<code>}</code>。</p>
<p>局部变量不能在声明的作用域之外使用。</p>
<pre><code class="language-move">let x = 0;
{
    let y = 1;
};
x + y // 错误！
//  ^ unbound local 'y'（未绑定的局部变量“y”）
</code></pre>
<p>But, locals from an outer scope <em>can</em> be used in a nested scope.</p>
<p>但是，来自外部作用域的本地变量<em>可以</em>在嵌套作用域中使用。</p>
<pre><code class="language-move">{
    let x = 0;
    {
        let y = x + 1; // 有效的
    }
}
</code></pre>
<p>Locals can be mutated in any scope where they are accessible. That mutation survives with the local,
regardless of the scope that performed the mutation.</p>
<p>局部变量可以在允许访问的任何作用域内进行变更。无论执行变更的作用域如何，这种变更会跟随局部变量的生命周期。</p>
<pre><code class="language-move">let x = 0;
x = x + 1;
assert!(x == 1, 42);
{
    x = x + 1;
    assert!(x == 2, 42);
};
assert!(x == 2, 42);
</code></pre>
<h3 id="表达式块expression-blocks"><a class="header" href="#表达式块expression-blocks">表达式块（Expression Blocks）</a></h3>
<p>An expression block is a series of statements separated by semicolons (<code>;</code>). The resulting value of
an expression block is the value of the last expression in the block.</p>
<p>表达式块是由分号（<code>;</code>）分隔的一系列语句。表达式块的结果值是块中最后一个表达式的值。</p>
<pre><code class="language-move">{ let x = 1; let y = 1; x + y }
</code></pre>
<p>In this example, the result of the block is <code>x + y</code>.</p>
<p>A statement can be either a <code>let</code> declaration or an expression. Remember that assignments (<code>x = e</code>)
are expressions of type <code>()</code>.</p>
<p>在此示例中, 此区块的结果是 <code>x + y</code>.</p>
<p>语句可以是 <code>let</code> 声明或表达式。请记住，赋值（<code>x = e</code>）是 <code>()</code> 类型的表达式。</p>
<pre><code class="language-move">{ let x; let y = 1; x = 1; x + y }
</code></pre>
<p>Function calls are another common expression of type <code>()</code>. Function calls that modify data are
commonly used as statements.</p>
<p>函数调用是 <code>()</code> 类型的另一种常见表达方式。修改数据的函数调用通常被用作语句。</p>
<pre><code class="language-move">{ let v = vector::empty(); vector::push_back(&amp;mut v, 1); v }
</code></pre>
<p>This is not just limited to <code>()</code> types---any expression can be used as a statement in a sequence!</p>
<p>这不仅限于 <code>()</code> 类型 —— 任何表达式都可以用作序列中的语句！</p>
<pre><code class="language-move">{
    let x = 0;
    x + 1; // 值会被丢弃
    x + 2; // 值会被丢弃
    b&quot;hello&quot;; // 值会被丢弃
}
</code></pre>
<p>But! If the expression contains a resource (a value without the <code>drop</code> <a href="abilities.html">ability</a>),
you will get an error. This is because Move's type system guarantees that any value that is dropped
has the <code>drop</code> <a href="abilities.html">ability</a>. (Ownership must be transferred or the value must be
explicitly destroyed within its declaring module.)</p>
<p>但是！如果表达式包含资源（没有 <code>drop</code> <a href="abilities.html">能力</a>的值），你将收到错误消息。这是因为 Move 的类型系统保证任何被删除的值都具有 <code>drop</code> <a href="abilities.html">能力</a>。（必须转移所有权，或者必须在其声明模块中显式销毁该值。）</p>
<pre><code class="language-move">{
    let x = 0;
    Coin { value: x }; // 错误！
//  ^^^^^^^^^^^^^^^^^ unused value without the `drop` ability（未使用没有 `drop` 能力的值）
    x
}
</code></pre>
<p>If a final expression is not present in a block---that is, if there is a trailing semicolon <code>;</code>,
there is an implicit unit <code>()</code> value. Similarly, if the expression block is empty, there is an
implicit unit <code>()</code> value.</p>
<p>如果块中不存在最终表达式 —— 也就是说，如果有一个尾随分号 <code>;</code>，则含有一个隐式的<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%80%BC%E7%B1%BB%E5%9E%8B">单值（unit）<code>()</code></a>。同样，如果表达式块为空，那么也存在隐式的单值 <code>()</code>。</p>
<pre><code class="language-move">// 两者是等价的
{ x = x + 1; 1 / x; }
{ x = x + 1; 1 / x; () }
</code></pre>
<pre><code class="language-move">// 两者是等价的
{ }
{ () }
</code></pre>
<p>An expression block is itself an expression and can be used anyplace an expression is used. (Note:
The body of a function is also an expression block, but the function body cannot be replaced by
another expression.)</p>
<p>表达式块本身就是一个表达式，可以在任何使用表达式的地方使用。（注意：函数体也是一个表达式块，但函数体不能被另一个表达式替换。）</p>
<pre><code class="language-move">let my_vector: vector&lt;vector&lt;u8&gt;&gt; = {
    let v = vector::empty();
    vector::push_back(&amp;mut v, b&quot;hello&quot;);
    vector::push_back(&amp;mut v, b&quot;goodbye&quot;);
    v
};
</code></pre>
<p>(The type annotation is not needed in this example and only added for clarity.)</p>
<p>（此示例中不需要类型标注，只是为了清楚起见而添加。）</p>
<h3 id="遮蔽shadowing"><a class="header" href="#遮蔽shadowing">遮蔽（Shadowing）</a></h3>
<p>If a <code>let</code> introduces a local variable with a name already in scope, that previous variable can no
longer be accessed for the rest of this scope. This is called <em>shadowing</em>.</p>
<p>如果一个 <code>let</code> 引入了一个名称已经在作用域中的局部变量，则该作用域的剩余部分将无法再访问先前的变量。这称为<em>遮蔽（shadowing）</em>。</p>
<pre><code class="language-move">let x = 0;
assert!(x == 0, 42);

let x = 1; // x 被遮蔽了
assert!(x == 1, 42);
</code></pre>
<p>When a local is shadowed, it does not need to retain the same type as before.</p>
<p>当局部变量被遮蔽时，它不需要保留与以前相同的类型。</p>
<pre><code class="language-move">let x = 0;
assert!(x == 0, 42);

let x = b&quot;hello&quot;; // x 被遮蔽了
assert!(x == b&quot;hello&quot;, 42);
</code></pre>
<p>After a local is shadowed, the value stored in the local still exists, but will no longer be
accessible. This is important to keep in mind with values of types without the
<a href="abilities.html"><code>drop</code> ability</a>, as ownership of the value must be transferred by the end of the
function.</p>
<p>在局部变量被遮蔽后，存储在局部变量的值仍然存在，但是将不再可访问。对于没有 <a href="abilities.html"><code>drop</code> 能力</a>的类型的值，请记住这一点很重要，因为值的所有权必须在函数结束时转移。</p>
<pre><code class="language-move">address 0x42 {
    module example {
        struct Coin has store { value: u64 }

        fun unused_resource(): Coin {
            let x = Coin { value: 0 }; // ERROR!
//              ^ This local still contains a value without the `drop` ability（这个局部变量仍然包含一个没有 `drop` 能力的值）
            x.value = 1;
            let x = Coin { value: 10 };
            x
//          ^ Invalid return（无效的返回）
        }
    }
}
</code></pre>
<p>When a local is shadowed inside a scope, the shadowing only remains for that scope. The shadowing is
gone once that scope ends.</p>
<p>当局部变量在作用域内被遮蔽时，该遮蔽作用仅保留在该作用域内。一旦该作用域结束，遮蔽作用就消失了。</p>
<pre><code class="language-move">let x = 0;
{
    let x = 1;
    assert!(x == 1, 42);
};
assert!(x == 0, 42);
</code></pre>
<p>Remember, locals can change type when they are shadowed.</p>
<p>请记住，局部变量在被遮蔽时可以更改类型。</p>
<pre><code class="language-move">let x = 0;
{
    let x = b&quot;hello&quot;;
    assert!(x = b&quot;hello&quot;, 42);
};
assert!(x == 0, 42);
</code></pre>
<h2 id="移动和复制move-and-copy"><a class="header" href="#移动和复制move-and-copy">移动和复制（Move and Copy）</a></h2>
<p>All local variables in Move can be used in two ways, either by <code>move</code> or <code>copy</code>. If one or the other
is not specified, the Move compiler is able to infer whether a <code>copy</code> or a <code>move</code> should be used.
This means that in all of the examples above, a <code>move</code> or a <code>copy</code> would be inserted by the
compiler. A local variable cannot be used without the use of <code>move</code> or <code>copy</code>.</p>
<p><code>copy</code> will likely feel the most familiar coming from other programming languages, as it creates a
new copy of the value inside of the variable to use in that expression. With <code>copy</code>, the local
variable can be used more than once.</p>
<p>Move 中的所有局部变量都可以通过两种方式使用，通过 <code>move</code> 或 <code>copy</code>。如果未指定其中之一，则 Move 编译器能够推断应该使用 <code>copy</code> 还是 <code>move</code>。这意味着在上述所有示例中，编译器将插入 <code>move</code> 或 <code>copy</code>。如果不使用 <code>move</code> 或 <code>copy</code>，就不能使用局部变量。</p>
<p><code>copy</code> 对来自其他编程语言的开发者来说可能会觉得最熟悉，因为它会在变量内部创建一个新的副本值以在该表达式中使用。使用 <code>copy</code>，局部变量可以被多次使用。</p>
<pre><code class="language-move">let x = 0;
let y = copy x + 1;
let z = copy x + 2;
</code></pre>
<p>Any value with the <code>copy</code> <a href="abilities.html">ability</a> can be copied in this way.</p>
<p><code>move</code> takes the value out of the local variable <em>without</em> copying the data. After a <code>move</code> occurs,
the local variable is unavailable.</p>
<p>任何具有 <code>copy</code> <a href="abilities.html">能力</a>的值都可以通过这种方式复制。</p>
<p><code>move</code> 从局部变量中取出值<em>而不是</em>复制数据。<code>移动（move）</code>发生后，局部变量将不可用。</p>
<pre><code class="language-move">let x = 1;
let y = move x + 1;
//      ------ Local was moved here（局部变量被移动到这里了）
let z = move x + 2; // 错误！
//      ^^^^^^ Invalid usage of local 'x'（局部变量“x”的无效使用方式）
y + z
</code></pre>
<h3 id="安全性safety"><a class="header" href="#安全性safety">安全性（Safety）</a></h3>
<p>Move's type system will prevent a value from being used after it is moved. This is the same safety
check described in <a href="variables.html#let-bindings"><code>let</code> declaration</a> that prevents local variables from being used
before it is assigned a value.</p>
<p>Move 的类型系统会阻止一个值在移动后被使用。这与 <a href="variables.html#let-%E7%BB%91%E5%AE%9Alet-bindings"><code>let</code> 声明</a>中描述的防止在局部变量被赋值之前使用的安全检查相同。</p>
<!-- For more information, see TODO future section on ownership and move semantics. -->
<!-- 如了解更多信息, 参阅未来所有权和移动语义的部分 (TODO )。 -->
<h3 id="推断inference"><a class="header" href="#推断inference">推断（Inference）</a></h3>
<p>As mentioned above, the Move compiler will infer a <code>copy</code> or <code>move</code> if one is not indicated. The
algorithm for doing so is quite simple:</p>
<ul>
<li>Any scalar value with the <code>copy</code> <a href="abilities.html">ability</a> is given a <code>copy</code>.</li>
<li>Any reference (both mutable <code>&amp;mut</code> and immutable <code>&amp;</code>) is given a <code>copy</code>.
<ul>
<li>Except under special circumstances where it is made a <code>move</code> for predictable borrow checker errors.</li>
</ul>
</li>
<li>Any other value is given a <code>move</code>.
<ul>
<li>This means that even though other values might be have the <code>copy</code> <a href="abilities.html">ability</a>, it must be done <em>explicitly</em> by the programmer.</li>
<li>This is to prevent accidental copies of large data structures.</li>
</ul>
</li>
</ul>
<p>如上所述，如果未指明，Move 编译器将推断出 <code>copy</code> 还是 <code>move</code>。这样做的算法非常简单：</p>
<ul>
<li>任何带有 <code>copy</code> <a href="abilities.html">能力</a>的标量值都被赋予了 <code>copy</code>。</li>
<li>任何引用（可变的 <code>&amp;mut</code> 和不可变的 <code>&amp;</code>）都被赋予 <code>copy</code>。
<ul>
<li>除非在可预测的借用检查器错误的特殊情况下，会进行 <code>move</code> 操作。</li>
</ul>
</li>
<li>任何其他值都被赋予 <code>move</code>。
<ul>
<li>这意味着即使其他值可能具有 <code>copy</code> <a href="abilities.html">能力</a>，它也必须由程序员<em>显式</em>声明。</li>
<li>这是为了防止意外地复制很大的数据结构。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<pre><code class="language-move">let s = b&quot;hello&quot;;
let foo = Foo { f: 0 };
let coin = Coin { value: 0 };

let s2 = s; // 移动
let foo2 = foo; // 移动
let coin2 = coin; // 移动

let x = 0;
let b = false;
let addr = @0x42;
let x_ref = &amp;x;
let coin_ref = &amp;mut coin2;

let x2 = x; // 复制
let b2 = b; // 复制
let addr2 = @0x42; // 复制
let x_ref2 = x_ref; // 复制
let coin_ref2 = coin_ref; // 复制
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="等式-equality"><a class="header" href="#等式-equality">等式 (Equality)</a></h1>
<p>Move supports two equality operations <code>==</code> and <code>!=</code></p>
<p>Move 支持两种等式操作： <code>==</code> 和 <code>!=</code></p>
<h2 id="操作-operations-1"><a class="header" href="#操作-operations-1">操作 (Operations)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th><th>Description</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>equal</td><td>Returns <code>true</code> if the two operands have the same value, <code>false</code> otherwise</td></tr>
<tr><td><code>!=</code></td><td>not equal</td><td>Returns <code>true</code> if the two operands have different values, <code>false</code> otherwise</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>语法</th><th>操作</th><th>描述</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>相等</td><td>如果两个操作数(operands)值相同，返回 <code>true</code> , 否则返回 <code>false</code></td></tr>
<tr><td><code>!=</code></td><td>不相等</td><td>如果两个操作数(operands)值不相同，返回 <code>true</code> , 否则返回 <code>false</code></td></tr>
</tbody></table>
</div>
<h3 id="类型校验-typing"><a class="header" href="#类型校验-typing">类型校验 (Typing)</a></h3>
<p>Both the equal (<code>==</code>) and not-equal (<code>!=</code>) operations only work if both operands are the same type.</p>
<p>只有当左右两个操作数类型相同，相等操作 (<code>==</code>) 与不等操作 (<code>!=</code>) 才能正常使用。</p>
<pre><code class="language-move">0 == 0; // `true`
1u128 == 2u128; // `false`
b&quot;hello&quot; != x&quot;00&quot;; // `true`
</code></pre>
<p>Equality and non-equality also work over user defined types!</p>
<p>等式与不等式也可以在用户自定义的类型下使用！</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        struct S has copy, drop { f: u64, s: vector&lt;u8&gt; }

        fun always_true(): bool {
            let s = S { f: 0, s: b&quot;&quot; };
            // 括号不是必需的，但为了清楚起见在此示例中添加了括号
            (copy s) == s
        }

        fun always_false(): bool {
            let s = S { f: 0, s: b&quot;&quot; };
            // 括号不是必需的，但为了清楚起见在此示例中添加了括号
            (copy s) != s
        }
    }
}
</code></pre>
<p>If the operands have different types, there is a type checking error.</p>
<p>如果两边操作数的类型不同，则会出现类型检测错误。</p>
<pre><code class="language-move">1u8 == 1u128; // 错误!
//     ^^^^^ 期望此变量的类型是 'u8'
b&quot;&quot; != 0; // 错误!
//     ^ 期望此变量的类型是 'vector&lt;u8&gt;'
</code></pre>
<h3 id="引用变量的类型校验-typing-with-references"><a class="header" href="#引用变量的类型校验-typing-with-references">引用变量的类型校验 (Typing with references)</a></h3>
<p>When comparing <a href="references.html">references</a>, the type of the reference (immutable or mutable) does
not matter. This means that you can compare an immutable <code>&amp;</code> reference with a mutable one <code>&amp;mut</code> of
the same underlying type.</p>
<p>当比较<a href="references.html">引用变量</a>时，引用的类别(不可变更的或可变更的(immutable or mutable))无关紧要。这意味着我们可以拿一个不可变更的 <code>&amp;</code> 引用变量和另一个有相同相关类型的可变更的 <code>&amp;mut </code> 引用变量进行比较。</p>
<pre><code class="language-move">let i = &amp;0;
let m = &amp;mut 1;

i == m; // `false`
m == i; // `false`
m == m; // `true`
i == i; // `true`
</code></pre>
<p>The above is equivalent to applying an explicit freeze to each mutable reference where needed</p>
<p>在需要时，对每个可变引用使用显式冻结(explicit freeze)的结果与上述情况一致。</p>
<pre><code class="language-move">let i = &amp;0;
let m = &amp;mut 1;

i == freeze(m); // `false`
freeze(m) == i; // `false`
m == m; // `true`
i == i; // `true`
</code></pre>
<p>But again, the underlying type must be the same type</p>
<p>但同样的，我们需要两边操作数的类型一致</p>
<pre><code class="language-move">let i = &amp;0;
let s = &amp;b&quot;&quot;;

i == s; // 错误!
//   ^ 期望此变量的类型是 '&amp;u64'
</code></pre>
<h2 id="限制-restrictions"><a class="header" href="#限制-restrictions">限制 (Restrictions)</a></h2>
<p>Both <code>==</code> and <code>!=</code> consume the value when comparing them. As a result, the type system enforces that
the type must have <a href="abilities.html"><code>drop</code></a>. Recall that without the <a href="abilities.html"><code>drop</code> ability</a>,
ownership must be transferred by the end of the function, and such values can only be explicitly destroyed
within their declaring module. If these were used directly with either equality <code>==</code> or non-equality <code>!=</code>,
the value would be destroyed which would break <a href="abilities.html"><code>drop</code> ability</a> safety guarantees!</p>
<p><code>==</code> 和 <code>!=</code> 会在比较不同变量的时候消耗 (consume)它们所包含的值，所以 Move 的类型系统会强制要求这些类型含有<a href="abilities.html"><code>drop</code> 能力</a>。回想一下，变量在没有<a href="abilities.html"><code>drop</code> 能力</a>时，所有权必须在函数结束前进行转移，而且这些值只能在其声明模块中被明确销毁(explicitly destroyed)。如果它们被直接使用于等式 <code>==</code> 或不等式 <code>!=</code> ，其值会被销毁并且这会打破<a href="abilities.html"><code>drop</code> 能力</a>的安全保证！</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        struct Coin has store { value: u64 }
        fun invalid(c1: Coin, c2: Coin) {
            c1 == c2 // 错误!
    //      ^^    ^^ 这些资源将会被销毁!
        }
    }
}
</code></pre>
<p>But, a programmer can <em>always</em> borrow the value first instead of directly comparing the value, and
reference types have the <a href="abilities.html"><code>drop</code> ability</a>. For example</p>
<p>然而, 程序员 <em>总是</em> 可以优先借用变量的值，而不直接比较它们的值。这样一来，引用变量的类型将会拥有<a href="abilities.html"><code>drop</code> 能力</a>。例如：</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        struct Coin as store { value: u64 }
        fun swap_if_equal(c1: Coin, c2: Coin): (Coin, Coin) {
            let are_equal = &amp;c1 == &amp;c2; // 合规范的
            if (are_equal) (c2, c1) else (c1, c2)
        }
    }
}
</code></pre>
<h2 id="避免额外的复制-avoid-extra-copies"><a class="header" href="#避免额外的复制-avoid-extra-copies">避免额外的复制 (Avoid Extra Copies)</a></h2>
<p>While a programmer <em>can</em> compare any value whose type has <a href="abilities.html"><code>drop</code></a>, a programmer
should often compare by reference to avoid expensive copies.</p>
<p>当程序员 <em>可以</em> 比较其类型含有<a href="abilities.html"><code>drop</code> 能力</a>的任意值时，他们应该尽可能多地使用引用变量来比较，以此来避免昂贵的复制。</p>
<pre><code class="language-move=">let v1: vector&lt;u8&gt; = function_that_returns_vector();
let v2: vector&lt;u8&gt; = function_that_returns_vector();
assert!(copy v1 == copy v2, 42);
//     ^^^^       ^^^^
use_two_vectors(v1, v2);

let s1: Foo = function_that_returns_large_struct();
let s2: Foo = function_that_returns_large_struct();
assert!(copy s1 == copy s2, 42);
//     ^^^^       ^^^^
use_two_foos(s1, s2);
</code></pre>
<p>This code is perfectly acceptable (assuming <code>Foo</code> has <a href="abilities.html"><code>drop</code></a>), just not efficient.
The highlighted copies can be removed and replaced with borrows</p>
<p>以上代码是完全可以接受的(假设<code>Foo</code>具备<a href="abilities.html"><code>drop</code></a>能力)，但它不是最有效的写法。突出显示的副本可以删除并替换为借用。</p>
<pre><code class="language-move=">let v1: vector&lt;u8&gt; = function_that_returns_vector();
let v2: vector&lt;u8&gt; = function_that_returns_vector();
assert!(&amp;v1 == &amp;v2, 42);
//     ^      ^
use_two_vectors(v1, v2);

let s1: Foo = function_that_returns_large_struct();
let s2: Foo = function_that_returns_large_struct();
assert!(&amp;s1 == &amp;s2, 42);
//     ^      ^
use_two_foos(s1, s2);
</code></pre>
<p>The efficiency of the <code>==</code> itself remains the same, but the <code>copy</code>s are removed and thus the program is more efficient.</p>
<p><code>==</code> 本身的效率还是和之前一样，但是 <code>copy</code> 操作被移除后整个程序会比之前更有效率。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中止和断言-abort-and-assert"><a class="header" href="#中止和断言-abort-and-assert">中止和断言 (Abort and Assert)</a></h1>
<p><a href="functions.html"><code>return</code></a> and <code>abort</code> are two control flow constructs that end execution, one for
the current function and one for the entire transaction.</p>
<p>More information on <a href="functions.html"><code>return</code> can be found in the linked section</a></p>
<p><a href="functions.html"><code>return</code></a> 和 <code>abort</code> 是两种结束程序执行的控制流结构。前者针对当前函数，后者针对整个事务。</p>
<p><a href="functions.html"><code>return</code></a>的更多信息可以参考链接中的文章。</p>
<h2 id="abort-中止"><a class="header" href="#abort-中止"><code>abort</code> 中止</a></h2>
<p><code>abort</code> is an expression that takes one argument: an <strong>abort code</strong> of type <code>u64</code>. For example:</p>
<p><code>abort</code> 表达式只接受一个参数: 类型为 <code>u64</code> 的<strong>中止代码</strong>。例如：</p>
<pre><code class="language-move">abort 42
</code></pre>
<p>The <code>abort</code> expression halts execution the current function and reverts all changes made to global
state by the current transaction. There is no mechanism for &quot;catching&quot; or otherwise handling an <code>abort</code>.</p>
<p><code>abort</code> 表达式会中止执行当前函数并恢复当前事务对全局状态所做的所有更改。Move语言没有“捉捕”或者额外处理<code>abort</code>的机制。</p>
<p>Luckily, in Move transactions are all or nothing, meaning any changes to global storage are made all
at once only if the transaction succeeds. Because of this transactional commitment of changes, after
an abort there is no need to worry about backing out changes. While this approach is lacking in
flexibility, it is incredibly simple and predictable.</p>
<p>幸运的是，在Move里事务的计算要么完全执行要么完全不执行。这意味着只有在事务成功时，任何对全局存储状态的改变才会被一并执行。
由于这种对于所有更改的事务承诺，在 <code>abort</code> 之后我们不需要担心去回滚任何更改。尽管这种方法缺少灵活性，它还是非常简单和可预测的。</p>
<p>Similar to <a href="functions.html"><code>return</code></a>, <code>abort</code> is useful for exiting control flow when some condition cannot be met.</p>
<p>In this example, the function will pop two items off of the vector, but will abort early if the vector does not have two items</p>
<p>与 <a href="functions.html"><code>return</code></a>相似, 在一些条件无法被满足的时候，<code>abort</code> 可以被用于退出控制流(control flow)。</p>
<p>在以下示例中，目标函数会从vector里弹出两个元素，但是如果vector中并没有两个元素，函数会提前中止。</p>
<pre><code class="language-move=">use std::vector;
fun pop_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): (T, T) {
    if (vector::length(v) &lt; 2) abort 42;

    (vector::pop_back(v), vector::pop_back(v))
}
</code></pre>
<p>This is even more useful deep inside a control-flow construct. For example, this function checks
that all numbers in the vector are less than the specified <code>bound</code>. And aborts otherwise</p>
<p>这在控制流结构的深处甚至会更有用。例如，此函数检查vector中是否所有数字都小于指定的边界(<code>bound</code>)。否则函数中止：</p>
<pre><code class="language-move=">use std::vector;
fun check_vec(v: &amp;vector&lt;u64&gt;, bound: u64) {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        let cur = *vector::borrow(v, i);
        if (cur &gt; bound) abort 42;
        i = i + 1;
    }
}
</code></pre>
<h3 id="assert-断言"><a class="header" href="#assert-断言"><code>assert</code> 断言</a></h3>
<p><code>assert</code> is a builtin, macro-like operation provided by the Move compiler. It takes two arguments, a condition of type <code>bool</code> and a code of type <code>u64</code></p>
<p><code>assert</code> 是 Move 编译器提供的内置的类宏(macro-like)操作。它需要两个参数：一个 <code>bool</code> 类型的条件和一个 <code>u64</code> 类型的错误状态码(类似HTTP中的StatusCode: 404, 500等，译者注)</p>
<pre><code class="language-move">assert!(condition: bool, code: u64)
</code></pre>
<p>Since the operation is a macro, it must be invoked with the <code>!</code>. This is to convey that the
arguments to <code>assert</code> are call-by-expression. In other words, <code>assert</code> is not a normal function and
does not exist at the bytecode level. It is replaced inside the compiler with</p>
<p>由于该操作是一个宏，因此必须使用 <code>!</code> 调用它。这是为了表达 <code>assert</code> 的参数属于表达式调用(call-by-expression)。换句话说，<code>assert</code> 不是一个正常的函数，并且在字节码(bytecode)级别不存在。它在编译器内部被替换为以下代码：</p>
<pre><code class="language-move">if (condition) () else abort code
</code></pre>
<p><code>assert</code> is more commonly used than just <code>abort</code> by itself. The <code>abort</code> examples above can be rewritten using <code>assert</code></p>
<p><code>assert</code> 比 <code>abort</code> 本身更常用。上面的 <code>abort</code> 示例可以使用 <code>assert</code> 重写</p>
<pre><code class="language-move=">use std::vector;
fun pop_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): (T, T) {
    assert!(vector::length(v) &gt;= 2, 42); // 现在使用'assert'

    (vector::pop_back(v), vector::pop_back(v))
}
</code></pre>
<p>和</p>
<pre><code class="language-move=">use std::vector;
fun check_vec(v: &amp;vector&lt;u64&gt;, bound: u64) {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        let cur = *vector::borrow(v, i);
        assert!(cur &lt;= bound, 42); // 现在使用 'assert'
        i = i + 1;
    }
}
</code></pre>
<p>Note that because the operation is replaced with this <code>if-else</code>, the argument for the <code>code</code> is not
always evaluated. For example:</p>
<p>请注意，因为此操作被替换为 <code>if-else</code>，这段 <code>代码</code> 的参数不是总是被执行(evaluated)。例如：</p>
<pre><code class="language-move">assert!(true, 1 / 0)
</code></pre>
<p>Will not result in an arithmetic error, it is equivalent to</p>
<p>不会导致算术错误，因为它相当于：</p>
<pre><code class="language-move">if (true) () else (1 / 0)
</code></pre>
<p>So the arithmetic expression is never evaluated!</p>
<p>所以这个算术表达式永远不会被执行(evaluated)！</p>
<h3 id="abort-codes-in-the-move-vm-move虚拟机中的中止代码"><a class="header" href="#abort-codes-in-the-move-vm-move虚拟机中的中止代码">Abort codes in the Move VM (Move虚拟机中的中止代码)</a></h3>
<p>When using <code>abort</code>, it is important to understand how the <code>u64</code> code will be used by the VM.</p>
<p>Normally, after successful execution, the Move VM produces a change-set for the changes made to
global storage (added/removed resources, updates to existing resources, etc).</p>
<p>当使用 <code>abort</code> 时，理解虚拟机将如何使用 <code>u64</code> 代码是非常重要的。</p>
<p>通常，在成功执行后，Move 虚拟机会为对全局存储(添加/删除资源、更新现有资源等)所做的更改生成一个更改集。</p>
<p>If an <code>abort</code> is reached, the VM will instead indicate an error. Included in that error will be two
pieces of information:</p>
<ul>
<li>The module that produced the abort (address and name)</li>
<li>The abort code.</li>
</ul>
<p>For example</p>
<p>如果执行到 <code>abort</code> 代码，虚拟机将指示错误。该错误中包含两块信息：</p>
<ul>
<li>发生中止的模块(地址和名称)</li>
<li>错误状态码。</li>
</ul>
<p>例如</p>
<pre><code class="language-move=">address 0x2 {
    module example {
        public fun aborts() {
            abort 42
        }
    }
}

script {
    fun always_aborts() {
        0x2::example::aborts()
    }
}
</code></pre>
<p>If a transaction, such as the script <code>always_aborts</code> above, calls <code>0x2::example::aborts</code>, the VM
would produce an error that indicated the module <code>0x2::example</code> and the code <code>42</code>.</p>
<p>This can be useful for having multiple aborts being grouped together inside a module.</p>
<p>In this example, the module has two separate error codes used in multiple functions</p>
<p>如果一个事务，例如上面的脚本 <code>always_aborts</code> 调用了 <code>0x2::example::aborts</code>，虚拟机将产生一个指示模块 <code>0x2::example</code> 和错误状态码 <code>42</code> 的错误。</p>
<p>这在一个模块内将多个中止功能组合起来会很有用。</p>
<p>在以下示例中，模块有两个单独的错误状态码，用于多个函数</p>
<pre><code class="language-move=">address 0x42 {
    module example {

        use std::vector;

        const EMPTY_VECTOR: u64 = 0;
        const INDEX_OUT_OF_BOUNDS: u64 = 1;

        // 移动 i 到 j, 移动 j 到 k, 移动 k 到 i
        public fun rotate_three&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64, j: u64, k: u64) {
            let n = vector::length(v);
            assert!(n &gt; 0, EMPTY_VECTOR);
            assert!(i &lt; n, INDEX_OUT_OF_BOUNDS);
            assert!(j &lt; n, INDEX_OUT_OF_BOUNDS);
            assert!(k &lt; n, INDEX_OUT_OF_BOUNDS);

            vector::swap(v, i, k);
            vector::swap(v, j, k);
        }

        public fun remove_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64, j: u64): (T, T) {
            let n = vector::length(v);
            assert!(n &gt; 0, EMPTY_VECTOR);
            assert!(i &lt; n, INDEX_OUT_OF_BOUNDS);
            assert!(j &lt; n, INDEX_OUT_OF_BOUNDS);
            assert!(i &gt; j, INDEX_OUT_OF_BOUNDS);

            (vector::remove&lt;T&gt;(v, i), vector::remove&lt;T&gt;(v, j))
        }
    }
}
</code></pre>
<h2 id="the-type-of-abort-abort-的类型"><a class="header" href="#the-type-of-abort-abort-的类型">The type of <code>abort</code> (<code>abort</code> 的类型)</a></h2>
<p>The <code>abort i</code> expression can have any type! This is because both constructs break from the normal
control flow, so they never need to evaluate to the value of that type.</p>
<p>The following are not useful, but they will type check</p>
<p><code>abort i</code> 表达式可以有任何类型！这是因为这两种构造都打破了正常控制流，因此他们永远不需要计算该类型的值。</p>
<p>以下的示例不是特别有用，但它们会做类型检查</p>
<pre><code class="language-move">let y: address = abort 0;
</code></pre>
<p>This behavior can be helpful in situations where you have a branching instruction that produces a
value on some branches, but not all. For example:</p>
<p>在您有一个分支指令，并且这个指令会产生某些分支(不是全部)的值的时候，这种行为会非常有用。例如：</p>
<pre><code class="language-move">let b =
    if (x == 0) false
    else if (x == 1) true
    else abort 42;
//       ^^^^^^^^ `abort 42` 的类型是 `bool`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条件语句-conditionals"><a class="header" href="#条件语句-conditionals">条件语句 (Conditionals)</a></h1>
<p>An <code>if</code> expression specifies that some code should only be evaluated if a certain condition is true. For example:</p>
<p><code>if</code> 语句可以用来指定一块代码块，但只在判断条件(condition)为true时才会被执行。例如:</p>
<pre><code class="language-move">if (x &gt; 5) x = x - 5
</code></pre>
<p>The condition must be an expression of type <code>bool</code>.</p>
<p>An <code>if</code> expression can optionally include an <code>else</code> clause to specify another expression to evaluate when the condition is false.</p>
<p>条件语句(condition)必须是 <code>bool</code> 类型的表达式。</p>
<p><code>if</code> 语句可选包含 <code>else</code> 子句，以指定当条件(condition)为 false 时要执行的另一个代码块。</p>
<pre><code class="language-move">if (y &lt;= 10) y = y + 1 else y = 10
</code></pre>
<p>Either the &quot;true&quot; branch or the &quot;false&quot; branch will be evaluated, but not both. Either branch can be a single expression or an expression block.</p>
<p>The conditional expressions may produce values so that the <code>if</code> expression has a result.</p>
<p>无论是&quot;true&quot;分支还是&quot;false&quot;分支都会被执行，但不会同时执行.其中任何一个分支都可以是单行代码或代码块。条件表达式会产生值，所以 <code>if</code> 表达式会有一个结果。</p>
<pre><code class="language-move">let z = if (x &lt; 100) x else 100;
</code></pre>
<p>The expressions in the true and false branches must have compatible types. For example:</p>
<p>true 和 false 分支的表达式类型必须是一致的,例如:</p>
<pre><code class="language-move=">// x和y必须是u64整型
// x and y must be u64 integers
let maximum: u64 = if (x &gt; y) x else y;

// 错误！分支的类型不一致
// (ERROR! branches different types)
let z = if (maximum &lt; 10) 10u8 else 100u64;

// 错误！分支的类型不一致,false-branch默认是()不是u64
// ERROR! branches different types, as default false-branch is () not u64
if (maximum &gt;= 10) maximum;
</code></pre>
<p>If the <code>else</code> clause is not specified, the false branch defaults to the unit value. The following are equivalent:</p>
<p>如果<code>else</code>子句未定义，false分支默认为 unit 。下面的例子是相等价的:</p>
<pre><code class="language-move">if (condition) true_branch // implied default: else ()
if (condition) true_branch else ()
</code></pre>
<p>Commonly, <a href="conditionals.html"><code>if</code> expressions</a> are used in conjunction with expression blocks.</p>
<p>一般来说, <a href="conditionals.html"><code>if</code> 表达式</a>与多个表达式块结合使用.</p>
<pre><code class="language-move">let maximum = if (x &gt; y) x else y;
if (maximum &lt; 10) {
    x = x + 10;
    y = y + 10;
} else if (x &gt;= 10 &amp;&amp; y &gt;= 10) {
    x = x - 10;
    y = y - 10;
}
</code></pre>
<h2 id="条件语句的语法-grammar-for-conditionals"><a class="header" href="#条件语句的语法-grammar-for-conditionals">条件语句的语法 (Grammar for Conditionals)</a></h2>
<blockquote>
<p><em>if-expression</em> → <strong>if (</strong> <em>expression</em> <strong>)</strong> <em>expression</em> <em>else-clause</em><sub><em>opt</em></sub>
<em>else-clause</em> → <strong>else</strong> <em>expression</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-and-loop"><a class="header" href="#while-and-loop">While and Loop</a></h1>
<p>Move offers two constructs for looping: <code>while</code> and <code>loop</code>.</p>
<p>Move 提供了两种循环结构: <code>while</code> and <code>loop</code>.</p>
<h2 id="while-循环"><a class="header" href="#while-循环"><code>while</code> 循环</a></h2>
<p>The <code>while</code> construct repeats the body (an expression of type unit) until the condition (an expression of type <code>bool</code>) evaluates to <code>false</code>.</p>
<p>Here is an example of simple <code>while</code> loop that computes the sum of the numbers from <code>1</code> to <code>n</code>:</p>
<p><code>while</code> 会重复执行结构(一个 <code>unit</code> 类型的表达式), 直到条件语句(<code>bool</code> 类型的表达式)运算结果为 <code>false</code>。</p>
<p>下面是一个简单的 <code>while</code> 循环的例子，计算从 <code>1</code> 到 <code>n</code> 数字之和:</p>
<pre><code class="language-move">fun sum(n: u64): u64 {
    let sum = 0;
    let i = 1;
    while (i &lt;= n) {
        sum = sum + i;
        i = i + 1
    };

    sum
}
</code></pre>
<p>Infinite loops are allowed:</p>
<p>无限循环是被允许的:</p>
<pre><code class="language-move=">fun foo() {
    while (true) { }
}
</code></pre>
<h3 id="break"><a class="header" href="#break"><code>break</code></a></h3>
<p>The <code>break</code> expression can be used to exit a loop before the condition evaluates to <code>false</code>. For example, this loop uses <code>break</code> to find the smallest factor of <code>n</code> that's greater than 1:</p>
<p><code>break</code> 表达式可用于在条件计算结果为 <code>false</code> 之前退出循环。例如，这个循环使用 <code>break</code> 查找 <code>n</code> 大于1的最小因子:</p>
<pre><code class="language-move">fun smallest_factor(n: u64): u64 {
    // assuming the input is not 0 or 1
    let i = 2;
    while (i &lt;= n) {
        if (n % i == 0) break;
        i = i + 1
    };

    i
}
</code></pre>
<p>The <code>break</code> expression cannot be used outside of a loop.</p>
<p><code>break</code> 表达式不能在循环之外使用。</p>
<h3 id="continue"><a class="header" href="#continue"><code>continue</code></a></h3>
<p>The <code>continue</code> expression skips the rest of the loop and continues to the next iteration. This loop uses <code>continue</code> to compute the sum of <code>1, 2, ..., n</code>, except when the number is divisible by 10:</p>
<p><code>continue</code> 表达式跳过当前循环的剩余部分, 并继续下一轮迭代。下面的例子, 使用 <code>continue</code> 去计算 <code>1, 2, ..., n</code> 的总和，过滤掉不能被10整除的数:</p>
<pre><code class="language-move">fun sum_intermediate(n: u64): u64 {
    let sum = 0;
    let i = 0;
    while (i &lt; n) {
        i = i + 1;
        if (i % 10 == 0) continue;
        sum = sum + i;
    };

    sum
}
</code></pre>
<p>The <code>continue</code> expression cannot be used outside of a loop.</p>
<p><code>continue</code> 表达式不能在循环之外使用。</p>
<h3 id="the-type-of-break-and-continue"><a class="header" href="#the-type-of-break-and-continue">The type of <code>break</code> and <code>continue</code></a></h3>
<p><code>break</code> and <code>continue</code>, much like <code>return</code> and <code>abort</code>, can have any type. The following examples illustrate where this flexible typing can be helpful:</p>
<p><code>break</code> and <code>continue</code>, 和 <code>return</code> and <code>abort</code>  很相像, 可以是任何类型。下面的例子说明了这种灵活的类型在那些方面有帮助:</p>
<pre><code class="language-move">fun pop_smallest_while_not_equal(
    v1: vector&lt;u64&gt;,
    v2: vector&lt;u64&gt;,
): vector&lt;u64&gt; {
    let result = vector::empty();
    while (!vector::is_empty(&amp;v1) &amp;&amp; !vector::is_empty(&amp;v2)) {
        let u1 = *vector::borrow(&amp;v1, vector::length(&amp;v1) - 1);
        let u2 = *vector::borrow(&amp;v2, vector::length(&amp;v2) - 1);
        let popped =
            if (u1 &lt; u2) vector::pop_back(&amp;mut v1)
            else if (u2 &lt; u1) vector::pop_back(&amp;mut v2)
            else break; // Here, `break` has type `u64`
        vector::push_back(&amp;mut result, popped);
    };

    result
}

fun pick(
    indexes: vector&lt;u64&gt;,
    v1: &amp;vector&lt;address&gt;,
    v2: &amp;vector&lt;address&gt;
): vector&lt;address&gt; {
    let len1 = vector::length(v1);
    let len2 = vector::length(v2);
    let result = vector::empty();
    while (!vector::is_empty(&amp;indexes)) {
        let index = vector::pop_back(&amp;mut indexes);
        let chosen_vector =
            if (index &lt; len1) v1
            else if (index &lt; len2) v2
            else continue; // Here, `continue` has type `&amp;vector&lt;address&gt;`
        vector::push_back(&amp;mut result, *vector::borrow(chosen_vector, index))
    };

    result
}
</code></pre>
<h2 id="loop表达式"><a class="header" href="#loop表达式"><code>loop</code>表达式</a></h2>
<p>The <code>loop</code> expression repeats the loop body (an expression with type <code>()</code>) until it hits a <code>break</code></p>
<p>Without a <code>break</code>, the loop will continue forever</p>
<p><code>loop</code> 表达式重复循环体(类型为unit()的表达式) ，直到遇到 <code>break</code> 为止。</p>
<p>(下面的代码中)没有 <code>break</code>, 循环将一直执行。</p>
<pre><code class="language-move">fun foo() {
    let i = 0;
    loop { i = i + 1 }
}
</code></pre>
<p>Here is an example that uses <code>loop</code> to write the <code>sum</code> function:</p>
<p>这是一个使用 <code>loop</code> 编写 <code>sum</code> 函数的示例(可与 <code>while</code> 循环比较):</p>
<pre><code class="language-move">fun sum(n: u64): u64 {
    let sum = 0;
    let i = 0;
    loop {
        i = i + 1;
        if (i &gt; n) break;
        sum = sum + i
    };

    sum
}
</code></pre>
<p>As you might expect, <code>continue</code> can also be used inside a <code>loop</code>. Here is <code>sum_intermediate</code> from above rewritten using <code>loop</code> instead of <code>while</code></p>
<p>正如你所料, <code>continue</code> 也可以在 <code>loop</code> 中使用。这是上面的 <code>sum_intermediate</code> 使用 <code>loop</code> 代替 <code>while</code> 重写的:</p>
<pre><code class="language-move">fun sum_intermediate(n: u64): u64 {
    let sum = 0;
    let i = 0;
    loop {
        i = i + 1;
        if (i % 10 == 0) continue;
        if (i &gt; n) break;
        sum = sum + i
    };

    sum
}
</code></pre>
<h2 id="while-and-loop-的类型"><a class="header" href="#while-and-loop-的类型"><code>while</code> and <code>loop</code> 的类型</a></h2>
<p>Move loops are typed expressions. A <code>while</code> expression always has type <code>()</code>.</p>
<p>Move 循环是有类型化的表达式。 <code>while</code> 表达式始终具有 <code>()</code> 类型。</p>
<pre><code class="language-move">let () = while (i &lt; 10) { i = i + 1 };
</code></pre>
<p>If a <code>loop</code> contains a <code>break</code>, the expression has type unit <code>()</code></p>
<p>如果 <code>loop</code> 中包含 <code>break</code> , 这个表达式的类型则为 unit <code>()</code></p>
<pre><code class="language-move">(loop { if (i &lt; 10) i = i + 1 else break }: ());
let () = loop { if (i &lt; 10) i = i + 1 else break };
</code></pre>
<p>If <code>loop</code> does not have a <code>break</code>, <code>loop</code> can have any type much like <code>return</code>, <code>abort</code>, <code>break</code>, and <code>continue</code>.</p>
<p>如果 <code>loop</code> 不包含 <code>break</code>, <code>loop</code> 可以是任何类型, 就像<code>return</code>, <code>abort</code>, <code>break</code>, 和 <code>continue</code>。</p>
<pre><code class="language-move">(loop (): u64);
(loop (): address);
(loop (): &amp;vector&lt;vector&lt;u8&gt;&gt;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数-functions"><a class="header" href="#函数-functions">函数 (Functions)</a></h1>
<p>Function syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.</p>
<p>Move中的函数语法在模块函数和脚本函数之间是一致的。模块内部的函数可重复使用，而脚本的函数只能被使用一次用来调用事务。</p>
<h1 id="声明-declaration"><a class="header" href="#声明-declaration">声明 (Declaration)</a></h1>
<p>Functions are declared with the <code>fun</code> keyword followed by the function name, type parameters, parameters, a return type, acquires annotations, and finally the function body.</p>
<p>函数使用 <code>fun</code> 关键字声明，后跟函数名称、类型参数、参数、返回类型、获取标注(annotation)，最后是函数体。</p>
<pre><code class="language-text">fun &lt;identifier&gt;&lt;[type_parameters: constraint],*&gt;([identifier: type],*): &lt;return_type&gt; &lt;acquires [identifier],*&gt; &lt;function_body&gt;
</code></pre>
<p>例如</p>
<pre><code class="language-move">fun foo&lt;T1, T2&gt;(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }
</code></pre>
<h3 id="可见性-visibility"><a class="header" href="#可见性-visibility">可见性 (Visibility)</a></h3>
<p>Module functions, by default, can only be called within the same module. These internal (sometimes called private) functions cannot be called from other modules or from scripts.</p>
<p>默认情况下，模块函数只能在同一个模块内调用。这些内部(有时称为私有)函数不能从其他模块或脚本中调用。</p>
<pre><code class="language-move=">address 0x42 {
    module m {
        fun foo(): u64 { 0 }
        fun calls_foo(): u64 { foo() } // valid
    }

    module other {
        fun calls_m_foo(): u64 {
            0x42::m::foo() // ERROR!
    //      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
        }
    }
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
</code></pre>
<p>To allow access from other modules or from scripts, the function must be declared <code>public</code> or <code>public(friend)</code>.</p>
<p>要允许从其他模块或脚本访问，该函数必须声明为 <code>public</code> 或 <code>public(friend)</code>。</p>
<h4 id="public-可见性-public-visibility"><a class="header" href="#public-可见性-public-visibility"><code>public</code> 可见性 (<code>public</code> visibility)</a></h4>
<p>A <code>public</code> function can be called by <em>any</em> function defined in <em>any</em> module or script. As shown in the following example, a <code>public</code> function can be called by:</p>
<ul>
<li>other functions defined in the same module,</li>
<li>functions defined in another module, or</li>
<li>the function defined in a script.</li>
</ul>
<p><code>public</code> 函数可以被任何模块或脚本中定义的任何函数调用。如以下示例所示，可以通过以下方式调用 <code>public</code> 函数：</p>
<ul>
<li>在同一模块中定义的其他函数</li>
<li>在另一个模块中定义的函数</li>
<li>在脚本中定义的函数</li>
</ul>
<pre><code class="language-move=">address 0x42 {
    module m {
        public fun foo(): u64 { 0 }
        fun calls_foo(): u64 { foo() } // valid
    }

    module other {
        fun calls_m_foo(): u64 {
            0x42::m::foo() // valid
        }
    }
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}
</code></pre>
<h4 id="publicfriend-可见性-publicfriend-visibility"><a class="header" href="#publicfriend-可见性-publicfriend-visibility"><code>public(friend)</code> 可见性 (<code>public(friend)</code> visibility)</a></h4>
<p>The <code>public(friend)</code> visibility modifier is a more restricted form of the <code>public</code> modifier to give more control about where a function can be used. A <code>public(friend)</code> function can be called by:</p>
<ul>
<li>other functions defined in the same module, or</li>
<li>functions defined in modules which are explicitly specified in the <strong>friend list</strong> (see <a href="friends.html">Friends</a> on how to specify the friend list).</li>
</ul>
<p>Note that since we cannot declare a script to be a friend of a module, the functions defined in scripts can never call a <code>public(friend)</code> function.</p>
<p><code>public(friend)</code> 可见性修饰符是一种比 <code>public</code> 修饰符限制更严格的形式，可以更好地控制函数的使用位置。 <code>public(friend)</code> 函数可以通过以下方式调用：</p>
<ul>
<li>在同一模块中定义的其他函数，或者在 <strong>friend list</strong> 中明确指定的模块中定义的函数(请参阅 <a href="friends.html">Friends</a> 了解如何指定友元(friends)列表)。</li>
</ul>
<p>请注意，由于我们不能将脚本声明为模块的友元关系，因此脚本中定义的函数永远不能调用 <code>public(friend)</code> 函数。</p>
<pre><code class="language-move=">address 0x42 {
    module m {
        friend 0x42::n;  // friend declaration
        public(friend) fun foo(): u64 { 0 }
        fun calls_foo(): u64 { foo() } // valid
    }

    module n {
        fun calls_m_foo(): u64 {
            0x42::m::foo() // valid
        }
    }

    module other {
        fun calls_m_foo(): u64 {
            0x42::m::foo() // ERROR!
    //      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'
        }
    }
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'
    }
}
</code></pre>
<h3 id="entry-修饰符-entry-modifier"><a class="header" href="#entry-修饰符-entry-modifier"><code>entry</code> 修饰符 (<code>entry</code> modifier)</a></h3>
<p>The <code>entry</code> modifier is designed to allow module functions to be safely and directly invoked much like scripts. This allows module writers to specify which functions can be to begin execution. The module writer then knows that any non-<code>entry</code> function will be called from a Move program already in execution.</p>
<p>Essentially, <code>entry</code> functions are the &quot;main&quot; functions of a module, and they specify where Move programs start executing.</p>
<p>Note though, an <code>entry</code> function <em>can</em> still be called by other Move functions. So while they <em>can</em> serve as the start of a Move program, they aren't restricted to that case.</p>
<p><code>entry</code> 修饰符旨在允许像脚本一样安全直接地调用模块函数。这允许模块编写者指定哪些函数可以成为开始执行的入口。这样模块编写者就知道任何非<code>entry</code>函数都是从已经在执行的 Move 程序中被调用的。</p>
<p>本质上，<code>entry</code> 函数是模块的“main”函数，它们指定 Move 程序开始执行的位置。</p>
<p>但请注意，<code>entry</code> 函数仍可被其他 Move 函数调用。因此，虽然它们 <em>可以</em> 作为 Move 程序的入口，但它们并不局限于这种用法。</p>
<p>例如：</p>
<pre><code class="language-move=">address 0x42 {
    module m {
        public entry fun foo(): u64 { 0 }
        fun calls_foo(): u64 { foo() } // valid!
    }

    module n {
        fun calls_m_foo(): u64 {
            0x42::m::foo() // valid!
        }
    }

    module other {
        public entry fun calls_m_foo(): u64 {
            0x42::m::foo() // valid!
        }
    }
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid!
    }
}
</code></pre>
<p>Even internal functions can be marked as <code>entry</code>! This lets you guarantee that the function is called only at the beginning of execution (assuming you do not call it elsewhere in your module)</p>
<p>甚至内部函数也可以标记为 <code>entry</code>！这使你可以保证仅在开始执行时调用该函数(假如你没有在模块中的其他地方调用它)</p>
<pre><code class="language-move=">address 0x42 {
    module m {
        entry fun foo(): u64 { 0 } // valid! entry functions do not have to be public
    }

    module n {
        fun calls_m_foo(): u64 {
            0x42::m::foo() // ERROR!
    //      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
        }
    }

    module other {
        public entry fun calls_m_foo(): u64 {
            0x42::m::foo() // ERROR!
    //      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
        }
    }
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
</code></pre>
<h3 id="函数名-name"><a class="header" href="#函数名-name">函数名 (Name)</a></h3>
<p>Function names can start with letters <code>a</code> to <code>z</code> or letters <code>A</code> to <code>Z</code>. After the first character, function names can contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<p>函数名称可以以字母 <code>a</code> 到 <code>z</code> 或字母 <code>A</code> 到 <code>Z</code> 开头。在第一个字符之后，函数名称可以包含下划线 <code>_</code>、字母 <code>a</code> 到 <code>z</code> 、字母 <code>A</code> 到 <code>Z</code> 或数字 <code>0</code> 到 <code>9</code>。</p>
<pre><code class="language-move">fun FOO() {}
fun bar_42() {}
fun _bAZ19() {}
</code></pre>
<h3 id="类型参数-type-parameters"><a class="header" href="#类型参数-type-parameters">类型参数 (Type Parameters)</a></h3>
<p>After the name, functions can have type parameters</p>
<p>函数名后可以有类型参数</p>
<pre><code class="language-move">fun id&lt;T&gt;(x: T): T { x }
fun example&lt;T1: copy, T2&gt;(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }
</code></pre>
<p>For more details, see <a href="generics.html">Move generics</a>.</p>
<p>有关更多详细信息，请参阅 <a href="generics.html">移动泛型</a>。</p>
<h3 id="参数-parameters"><a class="header" href="#参数-parameters">参数 (Parameters)</a></h3>
<p>Functions parameters are declared with a local variable name followed by a type annotation</p>
<p>函数参数使用局部变量名，后跟类型标注的方式进行声明。</p>
<pre><code class="language-move">fun add(x: u64, y: u64): u64 { x + y }
</code></pre>
<p>We read this as <code>x</code> has type <code>u64</code></p>
<p>A function does not have to have any parameters at all.</p>
<p>(上面代码中的函数参数) 我们读为：<code>x</code> 参数的类型是 <code>u64</code> 。</p>
<p>函数可以没有任何参数。</p>
<pre><code class="language-move">fun useless() { }
</code></pre>
<p>This is very common for functions that create new or empty data structures</p>
<p>在函数中创建新或空的数据结构是常见的用法。</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        struct Counter { count: u64 }

        fun new_counter(): Counter {
            Counter { count: 0 }
        }

    }
}
</code></pre>
<h3 id="acquires"><a class="header" href="#acquires">Acquires</a></h3>
<p>When a function accesses a resource using <code>move_from</code>, <code>borrow_global</code>, or <code>borrow_global_mut</code>, the function must indicate that it <code>acquires</code> that resource. This is then used by Move's type system to ensure the references into global storage are safe, specifically that there are no dangling references into global storage.</p>
<p>当一个函数使用 <code>move_from</code>、<code>borrow_global</code> 或 <code>borrow_global_mut</code> 访问资源时，则该函数必须表明它 <code>获取(acquires)</code> 该资源。然后 Move 的类型系统使用它来确保对全局存储的引用是安全的，特别是没有对全局存储的悬垂引用(dangling references)。</p>
<pre><code class="language-move=">address 0x42 {
    module example {

        struct Balance has key { value: u64 }

        public fun add_balance(s: &amp;signer, value: u64) {
            move_to(s, Balance { value })
        }

        public fun extract_balance(addr: address): u64 acquires Balance {
            let Balance { value } = move_from(addr); // acquires needed
            value
        }
    }
}
</code></pre>
<p><code>acquires</code> annotations must also be added for transitive calls within the module. Calls to these functions from another module do not need to annotated with these acquires because one module cannot access resources declared in another module--so the annotation is not needed to ensure reference safety.</p>
<p><code>acquires</code> 标注也必须为模块内有传递性的调用添加。从另一个模块对这些函数的调用不需要使用 <code>acquires</code> 进行注释，因为一个模块无法访问在另一个模块中声明的资源——因此不需要用标注来确保引用安全。</p>
<pre><code class="language-move=">address 0x42 {
    module example {

        struct Balance has key { value: u64 }

        public fun add_balance(s: &amp;signer, value: u64) {
            move_to(s, Balance { value })
        }

        public fun extract_balance(addr: address): u64 acquires Balance {
            let Balance { value } = move_from(addr); // acquires needed
            value
        }

        public fun extract_and_add(sender: address, receiver: &amp;signer) acquires Balance {
            let value = extract_balance(sender); // acquires needed here
            add_balance(receiver, value)
        }
    }
}

address 0x42 {
    module other {
        fun extract_balance(addr: address): u64 {
            0x42::example::extract_balance(addr) // no acquires needed
        }
    }
}
</code></pre>
<p>A function can <code>acquire</code> as many resources as it needs to</p>
<p>函数可以根据需要 <code>acquire</code> 尽可能多的资源。</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        use std::vector;

        struct Balance has key { value: u64 }
        struct Box&lt;T&gt; has key { items: vector&lt;T&gt; }

        public fun store_two&lt;Item1: store, Item2: store&gt;(
            addr: address,
            item1: Item1,
            item2: Item2,
        ) acquires Balance, Box {
            let balance = borrow_global_mut&lt;Balance&gt;(addr); // acquires needed
            balance.value = balance.value - 2;
            let box1 = borrow_global_mut&lt;Box&lt;Item1&gt;&gt;(addr); // acquires needed
            vector::push_back(&amp;mut box1.items, item1);
            let box2 = borrow_global_mut&lt;Box&lt;Item2&gt;&gt;(addr); // acquires needed
            vector::push_back(&amp;mut box2.items, item2);
        }
    }
}
</code></pre>
<h3 id="返回类型-return-type"><a class="header" href="#返回类型-return-type">返回类型 (Return type)</a></h3>
<p>After the parameters, a function specifies its return type.</p>
<p>在参数之后，函数指定其返回类型。</p>
<pre><code class="language-move">fun zero(): u64 { 0 }
</code></pre>
<p>Here <code>: u64</code> indicates that the function's return type is <code>u64</code>.</p>
<p>Using tuples, a function can return multiple values</p>
<p>这里 <code>: u64</code> 表示函数的返回类型是 <code>u64</code>。</p>
<p>使用元组，一个函数可以返回多个值：</p>
<pre><code class="language-move">fun one_two_three(): (u64, u64, u64) { (0, 1, 2) }
</code></pre>
<p>If no return type is specified, the function has an implicit return type of unit <code>()</code>. These functions are equivalent</p>
<p>如果未指定返回类型，则该函数具有隐式返回类型单值 <code>()</code>。这些函数是等价的：</p>
<pre><code class="language-move">fun just_unit(): () { () }
fun just_unit() { () }
fun just_unit() { }
</code></pre>
<p><code>script</code> functions must have a return type of unit <code>()</code></p>
<p><code>script</code> 函数的返回类型必须为单值 <code>()</code>（不能是任何其他类型，例如 <code>bool</code>、<code>u64</code> 等，注者注）：</p>
<pre><code class="language-move">script {
    fun do_nothing() {
    }
}
</code></pre>
<p>As mentioned in the <a href="tuples.html">tuples section</a>, these tuple &quot;values&quot; are virtual and do not exist at runtime. So for a function that returns unit <code>()</code>, it will not be returning any value at all during execution.</p>
<p>如<a href="./tuples.html">元组部分</a>所述，这些元组“值”是虚拟的（virtual），且在运行时不存在。因此，对于返回单值 <code>()</code> 的函数，它在执行期间根本不会返回任何值。</p>
<h3 id="function-body-函数体"><a class="header" href="#function-body-函数体">Function body (函数体)</a></h3>
<p>A function's body is an expression block. The return value of the function is the last value in the sequence</p>
<p>函数体是一个表达式块。函数的返回值是序列中最后一个表达式的值。</p>
<pre><code class="language-move=">fun example(): u64 {
    let x = 0;
    x = x + 1;
    x // returns 'x'
}
</code></pre>
<p>See <a href="functions.html#returning-values">the section below for more information on returns</a></p>
<p>请参阅<a href="functions.html#returning-values">有关返回值的更多信息</a></p>
<p>For more information on expression blocks, see <a href="variables.html">Move variables</a>.</p>
<p>有关表达式块的更多信息，请参阅 <a href="variables.html">Move variables</a>。</p>
<h3 id="native-functions"><a class="header" href="#native-functions">Native Functions</a></h3>
<p>Some functions do not have a body specified, and instead have the body provided by the VM. These functions are marked <code>native</code>.</p>
<p>Without modifying the VM source code, a programmer cannot add new native functions. Furthermore, it is the intent that <code>native</code> functions are used for either standard library code or for functionality needed for the given Move environment.</p>
<p>Most <code>native</code> functions you will likely see are in standard library code such as `vecto</p>
<p>有些函数没有函数体，而是由 Move VM 提供的函数体。这些函数被标记为 <code>native</code>。</p>
<p>如果不修改 Move VM 源代码，程序员就无法添加新的 <code>native</code> 函数。此外，<code>native</code> 函数的意图是用于标准库代码或 Move 环境所需的基础功能。</p>
<p>你看到的大多数 <code>native</code> 函数可能都在标准库代码中，例如 <code>vector</code></p>
<pre><code class="language-move=">module std::vector {
    native public fun empty&lt;Element&gt;(): vector&lt;Element&gt;;
    ...
}
</code></pre>
<h2 id="调用-calling"><a class="header" href="#调用-calling">调用 (Calling)</a></h2>
<p>When calling a function, the name can be specified either through an alias or fully qualified</p>
<p>调用函数时，名称可以通过别名或完全限定名指定</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        public fun zero(): u64 { 0 }
    }
}

script {
    use 0x42::example::{Self, zero};
    fun call_zero() {
        // With the `use` above all of these calls are equivalent
        0x42::example::zero();
        example::zero();
        zero();
    }
}
</code></pre>
<p>When calling a function, an argument must be given for every parameter.</p>
<p>调用函数时，每个参数必须指定一个值。</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        public fun takes_none(): u64 { 0 }
        public fun takes_one(x: u64): u64 { x }
        public fun takes_two(x: u64, y: u64): u64 { x + y }
        public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }
    }
}

script {
    use 0x42::example;
    fun call_all() {
        example::takes_none();
        example::takes_one(0);
        example::takes_two(0, 1);
        example::takes_three(0, 1, 2);
    }
}
</code></pre>
<p>Type arguments can be either specified or inferred. Both calls are equivalent.</p>
<p>函数的类型参数可以被指定或推断出来。以下两个调用是等价的。</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        public fun id&lt;T&gt;(x: T): T { x }
    }
}

script {
    use 0x42::example;
    fun call_all() {
        example::id(0);
        example::id&lt;u64&gt;(0);
    }
}
</code></pre>
<p>For more details, see <a href="generics.html">Move generics</a>.</p>
<p>有关更多详细信息，请参阅 <a href="generics.html">Move generics</a>。</p>
<h2 id="returning-values-返回值"><a class="header" href="#returning-values-返回值">Returning values (返回值)</a></h2>
<p>The result of a function, its &quot;return value&quot;, is the final value of its function body. For example</p>
<p>一个函数的结果，也就是它的“返回值”，是函数体的最后一个值。例如：</p>
<pre><code class="language-move=">fun add(x: u64, y: u64): u64 {
    x + y
}
</code></pre>
<p><a href="functions.html#function-body">As mentioned above</a>, the function's body is an <a href="variables.html">expression block</a>. The expression block can sequence various statements, and the final expression in the block will be be the value of that block</p>
<p><a href="functions.html#function-body">如上所述</a>，函数体是一个<a href="variables.html">表达式块</a>。表达式块中可以有各种各种语句，块中最后一个表达式将是该表达式块的值。</p>
<pre><code class="language-move=">fun double_and_add(x: u64, y: u64): u64 {
    let double_x = x * 2;
    let double_y = y * 2;
    double_x + double_y
}
</code></pre>
<p>The return value here is <code>double_x + double_y</code></p>
<p>这里的返回值是 <code>double_x + double_y</code></p>
<h3 id="return-表达式-return-expression"><a class="header" href="#return-表达式-return-expression"><code>return</code> 表达式 (<code>return</code> expression)</a></h3>
<p>A function implicitly returns the value that its body evaluates to. However, functions can also use the explicit <code>return</code> expression:</p>
<p>函数隐式返回其函数体计算的值。但是，函数也可以使用显式的 <code>return</code> 表达式：</p>
<pre><code class="language-move">fun f1(): u64 { return 0 }
fun f2(): u64 { 0 }
</code></pre>
<p>These two functions are equivalent. In this slightly more involved example, the function subtracts two <code>u64</code> values, but returns early with <code>0</code> if the second value is too large:</p>
<p>这两个功能是等价的。在下面这个稍微复杂的示例中，该函数返回两个 <code>u64</code> 值相减的结果，但如果第二个值大于第一个值，则提前返回 <code>0</code> ：</p>
<pre><code class="language-move=">fun safe_sub(x: u64, y: u64): u64 {
    if (y &gt; x) return 0;
    x - y
}
</code></pre>
<p>Note that the body of this function could also have been written as <code>if (y &gt; x) 0 else x - y</code>.</p>
<p>However <code>return</code> really shines is in exiting deep within other control flow constructs. In this example, the function iterates through a vector to find the index of a given value:</p>
<p>请注意，这个函数的函数体也可以写成 <code>if (y &gt; x) 0 else x - y</code>。</p>
<p>然而，<code>return</code> 真正的亮点在于在其他控制流结构的深处退出。在此示例中，函数遍历数组以查找给定值的索引：</p>
<pre><code class="language-move=">use std::vector;
use std::option::{Self, Option};
fun index_of&lt;T&gt;(v: &amp;vector&lt;T&gt;, target: &amp;T): Option&lt;u64&gt; {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        if (vector::borrow(v, i) == target) return option::some(i);
        i = i + 1
    };

    option::none()
}
</code></pre>
<p>Using <code>return</code> without an argument is shorthand for <code>return ()</code>. That is, the following two functions are equivalent:</p>
<p>使用不带参数的 <code>return</code> 是 <code>return ()</code> 的简写。即以下两个函数是等价的：</p>
<pre><code class="language-move">fun foo() { return }
fun foo() { return () }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体和资源"><a class="header" href="#结构体和资源">结构体和资源</a></h1>
<p>A <em>struct</em> is a user-defined data structure containing typed fields. Structs can store any
non-reference type, including other structs.</p>
<p><em><strong>结构体</strong></em>（struct）是包含类型字段的自定义数据结构。结构体可以存储任何非引用类型，包括其他结构。</p>
<p>We often refer to struct values as <em>resources</em> if they cannot be copied and cannot be dropped. In
this case, resource values must have ownership transferred by the end of the function. This property
makes resources particularly well served for defining global storage schemas or for representing
important values (such as a token).</p>
<p>如果结构值无法复制且无法删除，我们通常将其称为<em><strong>资源</strong></em>（resource）。在这种情况下，资源值必须在函数结束时转移所有权。这个属性使资源特别适合定义全局存储模式或表示重要的值（如 token）。</p>
<p>By default, structs are linear and ephemeral. By this we mean that they: cannot be copied, cannot be
dropped, and cannot be stored in global storage. This means that all values have to have ownership
transferred (linear) and the values must be dealt with by the end of the program's execution
(ephemeral). We can relax this behavior by giving the struct <a href="abilities.html">abilities</a> which allow
values to be copied or dropped and also to be stored in global storage or to define global storage
schemas.</p>
<p>默认情况下，结构体是线性的和临时的。我们的意思是它们：不能被复制，不能被删除，不能被存储在全局存储中。这意味着所有值都必须转移所有权（线性），并且必须在程序执行结束时处理这些值（临时）。我们可以通过赋予结构体允许复制或删除值以及将值存储在全局存储中或定义全局存储模式的<a href="abilities.html">能力</a>来放松这种行为（减轻限制）。</p>
<h2 id="定义结构体"><a class="header" href="#定义结构体">定义结构体</a></h2>
<p>Structs must be defined inside a module:</p>
<p>结构体必须在模块内定义：</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo { x: u64, y: bool }
    struct Bar {}
    struct Baz { foo: Foo, }
    //                   ^ 注意：尾随逗号是可以的
}
}
</code></pre>
<p>Structs cannot be recursive, so the following definition is invalid:</p>
<p>结构体不能递归（定义），所以下面的定义是无效的：</p>
<pre><code class="language-move">struct Foo { x: Foo }
//              ^ 错误！ Foo 不能包含 Foo
</code></pre>
<p>As mentioned above: by default, a struct declaration is linear and ephemeral. So to allow the value
to be used with certain operations (that copy it, drop it, store it in global storage, or use it as
a storage schema), structs can be granted <a href="abilities.html">abilities</a> by annotating them with
<code>has &lt;ability&gt;</code>:</p>
<p>如上所述：默认情况下，结构体声明是线性且临时的。因此，为了允许将值用于某些操作（复制、删除、将其存储在全局存储中或将其用作存储模式），可以通过使用 <code>has &lt;ability&gt;</code> 标注它们来授予结构体<a href="abilities.html">能力</a>：</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo has copy, drop { x: u64, y: bool }
}
}
</code></pre>
<p>For more details, see the <a href="abilities.html#annotating-structs">annotating structs</a> section.</p>
<p>有关更多详细信息，请参阅<a href="abilities.html#%E6%A0%87%E6%B3%A8%E7%BB%93%E6%9E%84%E4%BD%93">标注结构体</a>部分。</p>
<h3 id="命名"><a class="header" href="#命名">命名</a></h3>
<p>Structs must start with a capital letter <code>A</code> to <code>Z</code>. After the first letter, constant names can
contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<p>结构体必须以大写字母 <code>A</code> 到 <code>Z</code> 开头。在第一个字母之后，结构体名称可以包含下划线 <code>_</code>、字母 <code>a</code> 到 <code>z</code>、字母 <code>A</code> 到 <code>Z</code> 或数字 <code>0</code> 到 <code>9</code>。</p>
<pre><code class="language-move">struct Foo {}
struct BAR {}
struct B_a_z_4_2 {}
</code></pre>
<p>This naming restriction of starting with <code>A</code> to <code>Z</code> is in place to give room for future language
features. It may or may not be removed later.</p>
<p>这种以 <code>A</code> 到 <code>Z</code> 开头的命名限制是为了给未来的语言特性留出空间。以后可能会也可能不会删除这个限制。</p>
<h2 id="使用结构体"><a class="header" href="#使用结构体">使用结构体</a></h2>
<h3 id="创建结构体"><a class="header" href="#创建结构体">创建结构体</a></h3>
<p>Values of a struct type can be created (or &quot;packed&quot;) by indicating the struct name, followed by
value for each field:</p>
<p>可以通过写明结构体名称来创建（或“打包”）结构体类型的值，然后是每个字段的值：</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo has drop { x: u64, y: bool }
    struct Baz has drop { foo: Foo }

    fun example() {
        let foo = Foo { x: 0, y: false };
        let baz = Baz { foo: foo };
    }
}
}
</code></pre>
<p>If you initialize a struct field with a local variable whose name is the same as the field, you can
use the following shorthand:</p>
<p>如果使用与字段名相同的局部变量初始化结构体字段，则可以使用以下简写：</p>
<pre><code class="language-move">let baz = Baz { foo: foo };
// 相当于
let baz = Baz { foo };
</code></pre>
<p>This is called sometimes called &quot;field name punning&quot;.</p>
<p>这有时称为“字段名双关语”。</p>
<h3 id="通过模式匹配销毁结构体"><a class="header" href="#通过模式匹配销毁结构体">通过模式匹配销毁结构体</a></h3>
<p>Struct values can be destroyed by binding or assigning them patterns.</p>
<p>结构值可以通过绑定或赋值模式来销毁。</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo { x: u64, y: bool }
    struct Bar { foo: Foo }
    struct Baz {}

    fun example_destroy_foo() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y: foo_y } = foo;
        //        ^ `x: x` 的简写

        // 两个新绑定
        //   x: u64 = 3
        //   foo_y: bool = false
    }

    fun example_destroy_foo_wildcard() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y: _ } = foo;

        // 由于 y 绑定到通配符，因此只有一个新绑定
        //   x: u64 = 3
    }

    fun example_destroy_foo_assignment() {
        let x: u64;
        let y: bool;
        Foo { x, y } = Foo { x: 3, y: false };

        // 改变现有变量 x 和 y
        //   x = 3, y = false
    }

    fun example_foo_ref() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y } = &amp;foo;

        // 两个新绑定
        //   x: &amp;u64
        //   y: &amp;bool
    }

    fun example_foo_ref_mut() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y } = &amp;mut foo;

        // 两个新绑定
        //   x: &amp;mut u64
        //   y: &amp;mut bool
    }

    fun example_destroy_bar() {
        let bar = Bar { foo: Foo { x: 3, y: false } };
        let Bar { foo: Foo { x, y } } = bar;
        //             ^ 嵌套模式

        // 两个新绑定
        //   x: u64 = 3
        //   y: bool = false
    }

    fun example_destroy_baz() {
        let baz = Baz {};
        let Baz {} = baz;
    }
}
}
</code></pre>
<h3 id="借用结构体和字段"><a class="header" href="#借用结构体和字段">借用结构体和字段</a></h3>
<p>The <code>&amp;</code> and <code>&amp;mut</code> operator can be used to create references to structs or fields. These examples
include some optional type annotations (e.g., <code>: &amp;Foo</code>) to demonstrate the type of operations.</p>
<p><code>&amp;</code> 和 <code>&amp;mut</code> 运算符可用于创建对结构体或字段的引用。这些例子包括一些可选的类型标注（例如，<code>: &amp;Foo</code>）来演示操作的类型。</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let foo_ref: &amp;Foo = &amp;foo;
let y: bool = foo_ref.y;          // 通过对结构体的引用读取字段
let x_ref: &amp;u64 = &amp;foo.x;

let x_ref_mut: &amp;mut u64 = &amp;mut foo.x;
*x_ref_mut = 42;            // 通过可变引用修改字段
</code></pre>
<p>It is possible to borrow inner fields of nested structs.</p>
<p>可以借用嵌套结构体的内部字段：</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let bar = Bar { foo };

let x_ref = &amp;bar.foo.x;
</code></pre>
<p>You can also borrow a field via a reference to a struct.</p>
<p>你还可以通过对结构体的引用来借用字段：</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let foo_ref = &amp;foo;
let x_ref = &amp;foo_ref.x;
// 这与 let x_ref = &amp;foo.x 的效果相同
</code></pre>
<h3 id="读写字段"><a class="header" href="#读写字段">读写字段</a></h3>
<p>If you need to read and copy a field's value, you can then dereference the borrowed field</p>
<p>如果你需要读取和复制字段的值，则可以解引用借用的字段：</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let bar = Bar { foo: copy foo };
let x: u64 = *&amp;foo.x;
let y: bool = *&amp;foo.y;
let foo2: Foo = *&amp;bar.foo;
</code></pre>
<p>If the field is implicitly copyable, the dot operator can be used to read fields of a struct without
any borrowing. (Only scalar values with the <code>copy</code> ability are implicitly copyable.)</p>
<p>如果该字段是隐式可复制的，则点运算符可用于读取结构体的字段而无需任何借用。（只有具有 <code>copy</code> 能力的标量值是隐式可复制的。）</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let x = foo.x;  // x == 3
let y = foo.y;  // y == true
</code></pre>
<p>Dot operators can be chained to access nested fields.</p>
<p>点运算符可以链式访问嵌套字段：</p>
<pre><code class="language-move">let baz = Baz { foo: Foo { x: 3, y: true } };
let x = baz.foo.x; // x = 3;
</code></pre>
<p>However, this is not permitted for fields that contain non-primitive types, such a vector or another
struct</p>
<p>但是，对于包含非原始类型（例如向量或其他结构体）的字段，这是不允许的：</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let bar = Bar { foo };
let foo2: Foo = *&amp;bar.foo;
let foo3: Foo = bar.foo; // 错误！必须使用 *&amp; 添加显式复制
</code></pre>
<p>The reason behind this design decision is that copying a vector or another struct might be an
expensive operation. It is important for a programmer to be aware of this copy and make others aware
with the explicit syntax <code>*&amp;</code></p>
<p>In addition reading from fields, the dot syntax can be used to modify fields, regardless of the
field being a primitive type or some other struct</p>
<p>这个设计决策背后的原因是复制一个向量或另一个结构体可能是一项昂贵的操作。对于程序员来说，了解这个复制（操作）并使用显式语法 <code>*&amp;</code> 让其他人意识到是很重要的。</p>
<p>除了从字段中读取之外，点语法还可用于修改字段，无论该字段是原始类型还是其他结构体。</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
foo.x = 42;     // foo = Foo { x: 42, y: true }
foo.y = !foo.y; // foo = Foo { x: 42, y: false }
let bar = Bar { foo };            // bar = Bar { foo: Foo { x: 42, y: false } }
bar.foo.x = 52;                   // bar = Bar { foo: Foo { x: 52, y: false } }
bar.foo = Foo { x: 62, y: true }; // bar = Bar { foo: Foo { x: 62, y: true } }
</code></pre>
<p>The dot syntax also works via a reference to a struct</p>
<p>点语法也适用于对结构体的引用：</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let foo_ref = &amp;mut foo;
foo_ref.x = foo_ref.x + 1;
</code></pre>
<h2 id="私有结构体操作"><a class="header" href="#私有结构体操作">私有结构体操作</a></h2>
<p>Most struct operations on a struct type <code>T</code> can only be performed inside the module that declares
<code>T</code>:</p>
<ul>
<li>Struct types can only be created (&quot;packed&quot;), destroyed (&quot;unpacked&quot;) inside the module that defines
the struct.</li>
<li>The fields of a struct are only accessible inside the module that defines the struct.</li>
</ul>
<p>Following these rules, if you want to modify your struct outside the module, you will need to
provide public APIs for them. The end of the chapter contains some examples of this.</p>
<p>However, struct <em>types</em> are always visible to another module or script:</p>
<p>大多数对结构体类型 <code>T</code> 的结构体操作只能在声明 <code>T</code> 的模块内执行：</p>
<ul>
<li>结构体类型只能在定义结构体的模块内创建（“打包”）、销毁（“解包”）。</li>
<li>结构体的字段只能在定义结构体的模块内部访问。</li>
</ul>
<p>按照这些规则，如果你想在模块之外修改你的结构体，你需要为他们提供公共 API。本章的最后包含了这方面的一些例子。</p>
<p>但是，结构体类型始终对其他模块或脚本可见：</p>
<pre><code class="language-move">// m.move
address 0x2 {
module m {
    struct Foo has drop { x: u64 }

    public fun new_foo(): Foo {
        Foo { x: 42 }
    }
}
}
</code></pre>
<pre><code class="language-move">// n.move
address 0x2 {
module n {
    use 0x2::m;

    struct Wrapper has drop {
        foo: m::Foo
    }

    fun f1(foo: m::Foo) {
        let x = foo.x;
        //      ^ 错误！此处无法访问 `foo` 的字段
    }

    fun f2() {
        let foo_wrapper = Wrapper { foo: m::new_foo() };
    }
}
}
</code></pre>
<p>Note that structs do not have visibility modifiers (e.g., <code>public</code> or <code>private</code>).</p>
<p>请注意，结构体没有可见性修饰符（例如，<code>public</code> 或 <code>private</code>）。</p>
<h2 id="所有权-4"><a class="header" href="#所有权-4">所有权</a></h2>
<p>As mentioned above in <a href="structs-and-resources.html#defining-structs">Defining Structs</a>, structs are by default linear and
ephemeral. This means they cannot be copied or dropped. This property can be very useful when
modeling real world resources like money, as you do not want money to be duplicated or get lost in
circulation.
正如上面<a href="structs-and-resources.html#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93">定义结构体</a>中提到的，结构体默认是线性的和临时的。这意味着它们不能被复制或删除。在模拟货币等现实世界资源时，此属性非常有用，因为你不希望货币被复制或在流通中丢失。</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo { x: u64 }

    public fun copying_resource() {
        let foo = Foo { x: 100 };
        let foo_copy = copy foo; // 错误！“复制”需要“复制”能力
        let foo_ref = &amp;foo;
        let another_copy = *foo_ref // 错误！解引用需要“复制”能力
    }

    public fun destroying_resource1() {
        let foo = Foo { x: 100 };

        // 错误！当函数返回时，foo 仍然包含一个值。
        // 这种销毁需要“drop”能力
    }

    public fun destroying_resource2(f: &amp;mut Foo) {
        *f = Foo { x: 100 } // 错误！通过写入销毁旧值需要“drop”能力
    }
}
}
</code></pre>
<p>To fix the second example (<code>fun dropping_resource</code>), you would need to manually &quot;unpack&quot; the resource:</p>
<p>要修复第二个示例（<code>fun destroying_resource1</code>），你需要手动“解包”资源：</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo { x: u64 }

    public fun destroying_resource1_fixed() {
        let foo = Foo { x: 100 };
        let Foo { x: _ } = foo;
    }
}
}
</code></pre>
<p>Recall that you are only able to deconstruct a resource within the module in which it is defined.
This can be leveraged to enforce certain invariants in a system, for example, conservation of money.</p>
<p>If on the other hand, your struct does not represent something valuable, you can add the abilities
<code>copy</code> and <code>drop</code> to get a struct value that might feel more familiar from other programming
languages:</p>
<p>回想一下，你只能在定义资源的模块中解构资源。这可以用来在系统中强制执行某些不变量，例如货币守恒。</p>
<p>另一方面，如果你的结构体不代表有价值的东西，你可以添加 <code>copy</code> 和 <code>drop</code> 能力来获取一个结构值，这感觉可能会与其他编程语言更相似。</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo has copy, drop { x: u64 }

    public fun run() {
        let foo = Foo { x: 100 };
        let foo_copy = copy foo;
        // ^ 此代码复制 foo，而 `let x = foo` 或
        // `let x = move foo` 都移动 foo

        let x = foo.x;            // x = 100
        let x_copy = foo_copy.x;  // x = 100

        // 函数返回时 foo 和 foo_copy 都被隐式丢弃
    }
}
}
</code></pre>
<h2 id="在全局存储中存储资源"><a class="header" href="#在全局存储中存储资源">在全局存储中存储资源</a></h2>
<p>Only structs with the <code>key</code> ability can be saved directly in
<a href="global-storage-operators.html">persistent global storage</a>. All values stored within those <code>key</code>
structs must have the <code>store</code> abilities. See the [ability](./abilities] and
<a href="global-storage-operators.html">global storage</a> chapters for more detail.</p>
<p>只有具有 <code>key</code> 能力的结构体才能直接保存在<a href="global-storage-operators.html">持久性全局存储</a>中。存储在这些 <code>key</code> 结构体中的所有值都必须具有 <code>store</code> 能力。有关更多详细信息，请参阅<a href="abilities.html">能力</a>和<a href="global-storage-operators.html">全局存储</a>章节。</p>
<h2 id="示例-1"><a class="header" href="#示例-1">示例</a></h2>
<p>Here are two short examples of how you might use structs to represent valuable data (in the case of
<code>Coin</code>) or more classical data (in the case of <code>Point</code> and <code>Circle</code>)</p>
<p>这里有两个简短的示例，说明如何使用结构体来表示有价值的数据（在 <code>Coin</code> 的情况下）或更经典的数据（在 <code>Point</code> 和 <code>Circle</code> 的情况下）。</p>
<h3 id="示例-1coin"><a class="header" href="#示例-1coin">示例 1：Coin</a></h3>
<!-- TODO link to access control for mint -->
<pre><code class="language-move">address 0x2 {
module m {
    // 我们不希望钱币（Coin）被复制，因为那会复制这个“钱”，
    // 所以我们不会给结构体“copy”能力。
    // 同样，我们不希望程序员销毁钱币，所以我们不会给结构体“drop”能力。
    // 但是，我们*希望*模块的用户能够将这个钱币存储在持久的全局存储中，
    // 所以我们授予结构体“store”能力。
    // 这个结构体只会在全局存储内的其他资源中，因此我们不会赋予该结构体“key”能力。
    struct Coin has store {
        value: u64,
    }

    public fun mint(value: u64): Coin {
        // 你可能希望通过某种形式的访问控制来关闭此（铸币）功能，以防止使用此模块的任何人铸造无限数量的钱币。
        Coin { value }
    }

    public fun withdraw(coin: &amp;mut Coin, amount: u64): Coin {
        assert!(coin.balance &gt;= amount, 1000);
        coin.value = coin.value - amount;
        Coin { value: amount }
    }

    public fun deposit(coin: &amp;mut Coin, other: Coin) {
        let Coin { value } = other;
        coin.value = coin.value + value;
    }

    public fun split(coin: Coin, amount: u64): (Coin, Coin) {
        let other = withdraw(&amp;mut coin, amount);
        (coin, other)
    }

    public fun merge(coin1: Coin, coin2: Coin): Coin {
        deposit(&amp;mut coin1, coin2);
        coin1
    }

    public fun destroy_zero(coin: Coin) {
        let Coin { value } = coin;
        assert!(value == 0, 1001);
    }
}
}
</code></pre>
<h3 id="示例-2geometry"><a class="header" href="#示例-2geometry">示例 2：Geometry</a></h3>
<pre><code class="language-move">address 0x2 {
module point {
    struct Point has copy, drop, store {
        x: u64,
        y: u64,
    }

    public fun new(x: u64, y: u64): Point {
        Point {
            x, y
        }
    }

    public fun x(p: &amp;Point): u64 {
        p.x
    }

    public fun y(p: &amp;Point): u64 {
        p.y
    }

    fun abs_sub(a: u64, b: u64): u64 {
        if (a &lt; b) {
            b - a
        }
        else {
            a - b
        }
    }

    public fun dist_squared(p1: &amp;Point, p2: &amp;Point): u64 {
        let dx = abs_sub(p1.x, p2.x);
        let dy = abs_sub(p1.y, p2.y);
        dx*dx + dy*dy
    }
}
}
</code></pre>
<pre><code class="language-move">address 0x2 {
module circle {
    use 0x2::point::{Self, Point};

    struct Circle has copy, drop, store {
        center: Point,
        radius: u64,
    }

    public fun new(center: Point, radius: u64): Circle {
        Circle { center, radius }
    }

    public fun overlaps(c1: &amp;Circle, c2: &amp;Circle): bool {
        let d = point::dist_squared(&amp;c1.center, &amp;c2.center);
        let r1 = c1.radius;
        let r2 = c2.radius;
        d*d &lt;= r1*r1 + 2*r1*r2 + r2*r2
    }
}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常量-constants"><a class="header" href="#常量-constants">常量 (Constants)</a></h1>
<p>Constants are a way of giving a name to shared, static values inside of a <code>module</code> or <code>script</code>.</p>
<p>The constant's must be known at compilation. The constant's value is stored in the compiled module
or script. And each time the constant is used, a new copy of that value is made.</p>
<p>常量是一种对 <code>module</code> 或 <code>script</code> 内的共享静态值进行命名的方法(类似变量，但值不变，译者注)。</p>
<p>常量必须在编译时知道。常量的值存储在编译模块或脚本中。每次使用该常量时，都会生成该值的新副本。</p>
<h2 id="声明-declaration-1"><a class="header" href="#声明-declaration-1">声明 (Declaration)</a></h2>
<p>Constant declarations begin with the <code>const</code> keyword, followed by a name, a type, and a value. They
can exist in either a script or module</p>
<p>常量声明以 <code>const</code> 关键字开头，后跟名称、类型和值。他们可以存在于脚本或模块中</p>
<pre><code class="language-text">const &lt;name&gt;: &lt;type&gt; = &lt;expression&gt;;
</code></pre>
<p>例如</p>
<pre><code class="language-move=">script {

    const MY_ERROR_CODE: u64 = 0;

    fun main(input: u64) {
        assert!(input &gt; 0, MY_ERROR_CODE);
    }

}

address 0x42 {
    module example {

        const MY_ADDRESS: address = @0x42;

        public fun permissioned(s: &amp;signer) {
            assert!(std::signer::address_of(s) == MY_ADDRESS, 0);
        }

    }
}
</code></pre>
<h2 id="命名-naming"><a class="header" href="#命名-naming">命名 (Naming)</a></h2>
<p>Constants must start with a capital letter <code>A</code> to <code>Z</code>. After the first letter, constant names can
contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<p>常量必须以大写字母 <code>A</code> 到 <code>Z</code> 开头。在第一个字母之后，常量名可以包含下划线 <code>_</code>、字母 <code>a</code> 到 <code>z</code>、字母 <code>A</code> 到 <code>Z</code> 或数字 <code>0</code> 到 <code>9</code>。</p>
<pre><code class="language-move">const FLAG: bool = false;
const MY_ERROR_CODE: u64 = 0;
const ADDRESS_42: address = @0x42;
</code></pre>
<p>Even though you can use letters <code>a</code> to <code>z</code> in a constant. The
<a href="coding-conventions.html">general style guidelines</a> are to use just uppercase letters <code>A</code> to <code>Z</code>,
with underscores <code>_</code> between each word.</p>
<p>虽然你可以在常量中使用字母 <code>a</code> 到 <code>z</code>。但<a href="coding-conventions.html">通用风格指南</a> 只使用大写字母 <code>A</code> 到 <code>Z</code>，每个单词之间有下划线<code>_</code>。</p>
<p>This naming restriction of starting with <code>A</code> to <code>Z</code> is in place to give room for future language features. It may or may not be removed later.</p>
<p>这种以 <code>A</code> 到 <code>Z</code> 开头的命名限制是为了给未来的语言特性留出空间。此限制未来可能会保留或删除。</p>
<h2 id="可见性-visibility-1"><a class="header" href="#可见性-visibility-1">可见性 (Visibility)</a></h2>
<p><code>public</code> constants are not currently supported. <code>const</code> values can be used only in the declaring
module.</p>
<p>当前不支持 <code>public</code> 常量。 <code>const</code> 值只能在声明的模块中使用。</p>
<h2 id="有效表达式-valid-expressions"><a class="header" href="#有效表达式-valid-expressions">有效表达式 (Valid Expressions)</a></h2>
<p>Currently, constants are limited to the primitive types <code>bool</code>, <code>u8</code>, <code>u64</code>, <code>u128</code>, <code>address</code>, and
<code>vector&lt;u8&gt;</code>. Future support for other <code>vector</code> values (besides the &quot;string&quot;-style literals) will come later.</p>
<p>目前，常量仅限于原始类型 <code>bool</code>、<code>u8</code>、<code>u64</code>、<code>u128</code>、<code>address</code> 和<code>vector&lt;u8&gt;</code>。其他 <code>vector</code> 值(除了“string”风格的字面量)将在不远的将来获得支持。</p>
<h3 id="值-values"><a class="header" href="#值-values">值 (Values)</a></h3>
<p>Commonly, <code>const</code>s are assigned a simple value, or literal, of their type. For example</p>
<p>通常，<code>const</code> (常量)会被分配一个对应类型的简单值或字面量。例如</p>
<pre><code class="language-move">const MY_BOOL: bool = false;
const MY_ADDRESS: address = @0x70DD;
const BYTES: vector&lt;u8&gt; = b&quot;hello world&quot;;
const HEX_BYTES: vector&lt;u8&gt; = x&quot;DEADBEEF&quot;;
</code></pre>
<h3 id="复杂表达式-complex-expressions"><a class="header" href="#复杂表达式-complex-expressions">复杂表达式 (Complex Expressions)</a></h3>
<p>In addition to literals, constants can include more complex expressions, as long as the compiler is
able to reduce the expression to a value at compile time.</p>
<p>Currently, equality operations, all boolean operations, all bitwise operations, and all arithmetic
operations can be used.</p>
<p>除了字面量，常量还可以包含更复杂的表达式，只要编译器能够在编译时将表达式归纳(reduce)为一个值。</p>
<p>目前，相等运算、所有布尔运算、所有按位运算和所有算术运算可以使用。</p>
<pre><code class="language-move">const RULE: bool = true &amp;&amp; false;
const CAP: u64 = 10 * 100 + 1;
const SHIFTY: u8 = {
  (1 &lt;&lt; 1) * (1 &lt;&lt; 2) * (1 &lt;&lt; 3) * (1 &lt;&lt; 4)
};
const HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;
const EQUAL: bool = 1 == 1;
</code></pre>
<p>If the operation would result in a runtime exception, the compiler will give an error that it is
unable to generate the constant's value</p>
<p>如果操作会导致运行时异常，编译器会给出无法生成常量值的错误。</p>
<pre><code class="language-move">const DIV_BY_ZERO: u64 = 1 / 0; // error!
const SHIFT_BY_A_LOT: u64 = 1 &lt;&lt; 100; // error!
const NEGATIVE_U64: u64 = 0 - 1; // error!
</code></pre>
<p>Note that constants cannot currently refer to other constants. This feature, along with support for
other expressions, will be added in the future.</p>
<p>请注意，常量当前不能引用其他常量。此功能会在将来和支持其他表达方式一起被补充。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型-generics"><a class="header" href="#泛型-generics">泛型 (generics)</a></h1>
<p>Generics can be used to define functions and structs over different input data types. This language feature is sometimes referred to as <em>parametric polymorphism</em>. In Move, we will often use the term generics interchangeably with type parameters and type arguments.</p>
<p>泛型可用于定义具有不同输入数据类型的函数和结构体。这种语言特性被称为参数多态。在 Move语言中，我们经常将交替使用术语泛型与类型参数和类型参数。</p>
<p>Generics are commonly used in library code, such as in vector, to declare code that works over any possible instantiation (that satisfies the specified constraints). In other frameworks, generic code can sometimes be used to interact with global storage many different ways that all still share the same implementation.</p>
<p>泛型通常用于库代码中，例如 <code>vector</code>，以声明适用于任何可实例化(满足指定约束)的代码。在其他框架中，泛型代码有时可用多种不同的方式与全局存储交互，这些方式有着相同的实现。</p>
<h2 id="声明类型参数-declaring-type-parameters"><a class="header" href="#声明类型参数-declaring-type-parameters">声明类型参数 (Declaring Type Parameters)</a></h2>
<p>Both functions and structs can take a list of type parameters in their signatures, enclosed by a pair of angle brackets <code>&lt;...&gt;</code> .</p>
<p>函数和结构体都可以在其签名中采用类型参数列表，由一对尖括号括起来 <code>&lt;...&gt;</code> 。</p>
<h3 id="泛型函数-generic-functions"><a class="header" href="#泛型函数-generic-functions">泛型函数 (Generic Functions)</a></h3>
<p>Type parameters for functions are placed after the function name and before the (value) parameter list. The following code defines a generic identity function that takes a value of any type and returns that value unchanged.</p>
<p>函数的类型参数放在函数名称之后和(值)参数列表之前。以下代码定义了一个名为id的泛型函数，该函数接受任何类型的值并返回原值。</p>
<pre><code class="language-move">fun id&lt;T&gt;(x: T): T {
    // this type annotation is unnecessary but valid
    (x: T)
}
</code></pre>
<p>Once defined, the type parameter <code>T</code> can be used in parameter types, return types, and inside the function body.</p>
<p>一旦定义，类型参数 <code>T</code> 就可以在参数类型、返回类型和函数体内使用。</p>
<h3 id="泛型结构体-generic-structs"><a class="header" href="#泛型结构体-generic-structs">泛型结构体 (Generic Structs)</a></h3>
<p>Type parameters for structs are placed after the struct name, and can be used to name the types of the fields.</p>
<p>结构体的类型参数放在结构名称之后，并可用于命名字段的类型。</p>
<pre><code class="language-move">struct Foo&lt;T&gt; has copy, drop { x: T }

struct Bar&lt;T1, T2&gt; has copy, drop {
    x: T1,
    y: vector&lt;T2&gt;,
}
</code></pre>
<p><a href="generics.html#unused-type-parameters">Note that type parameters do not have to be used</a></p>
<p>请注意，<a href="generics.html#unused-type-parameters">未使用的类型参数</a></p>
<h2 id="类型参数-type-arguments"><a class="header" href="#类型参数-type-arguments">类型参数 (Type Arguments)</a></h2>
<h3 id="调用泛型函数-calling-generic-functions"><a class="header" href="#调用泛型函数-calling-generic-functions">调用泛型函数 (Calling Generic Functions)</a></h3>
<p>When calling a generic function, one can specify the type arguments for the function's type parameters in a list enclosed by a pair of angle brackets.</p>
<p>调用泛型函数时，可以在由一对尖括号括起来的列表中指定函数类型参数。</p>
<pre><code class="language-move">fun foo() {
    let x = id&lt;bool&gt;(true);
}
</code></pre>
<p>If you do not specify the type arguments, Move's <a href="generics.html#type-inference">type inference</a> will supply them for you.</p>
<p>如果您不指定类型参数，Move语言的<a href="generics.html#type-inference">类型推断</a>功能将为您匹配正确的类型</p>
<h3 id="使用泛型结构-using-generic-structs"><a class="header" href="#使用泛型结构-using-generic-structs">使用泛型结构 (Using Generic Structs)</a></h3>
<p>Similarly, one can attach a list of type arguments for the struct's type parameters when constructing or destructing values of generic types.</p>
<p>类似地，在构造或销毁泛型类型的值时，可以为结构体的类型参数附加一个参数列表。</p>
<pre><code class="language-move">fun foo() {
    let foo = Foo&lt;bool&gt; { x: true };
    let Foo&lt;bool&gt; { x } = foo;
}
</code></pre>
<p>If you do not specify the type arguments, Move's <a href="generics.html#type-inference">type inference</a> will supply them for you.</p>
<p>如果您不指定类型参数，Move 语言的<a href="generics.html#type-inference">类型推断</a>功能将为您自动补充(supply)。</p>
<h3 id="类型参数不匹配-type-argument-mismatch"><a class="header" href="#类型参数不匹配-type-argument-mismatch">类型参数不匹配 (Type Argument Mismatch)</a></h3>
<p>If you specify the type arguments and they conflict with the actual values supplied, an error will be given</p>
<p>如果您指定类型参数与实际提供的值不匹配，则会报错</p>
<pre><code class="language-move">fun foo() {
    let x = id&lt;u64&gt;(true); // error! true is not a u64
}
</code></pre>
<p>同样地</p>
<pre><code class="language-move">fun foo() {
    let foo = Foo&lt;bool&gt; { x: 0 }; // error! 0 is not a bool
    let Foo&lt;address&gt; { x } = foo; // error! bool is incompatible with address
}
</code></pre>
<h2 id="type-inference-类型推断"><a class="header" href="#type-inference-类型推断">Type Inference (类型推断)</a></h2>
<p>In most cases, the Move compiler will be able to infer the type arguments so you don't have to write them down explicitly. Here's what the examples above would look like if we omit the type arguments.</p>
<p>在大多数情况下，Move 编译器能够推断类型参数，因此您不必显式地写下它们。这是上面例子中省略类型参数写法的示例。</p>
<pre><code class="language-move">fun foo() {
    let x = id(true);
    //        ^ &lt;bool&gt; is inferred

    let foo = Foo { x: true };
    //           ^ &lt;bool&gt; is inferred

    let Foo { x } = foo;
    //     ^ &lt;bool&gt; is inferred
}
</code></pre>
<p>Note: when the compiler is unable to infer the types, you'll need annotate them manually. A common scenario is to call a function with type parameters appearing only at return positions.</p>
<p>注意：当编译器无法推断类型时，您需要手动标注它们(类型参数)。一个常见的场景是调用一个类型参数只出现在返回位置的函数。</p>
<pre><code class="language-move">address 0x2 {
    module m {
        using std::vector;

        fun foo() {
            // let v = vector::new();
            //                    ^ The compiler cannot figure out the element type.

            let v = vector::new&lt;u64&gt;();
            //                 ^~~~~ Must annotate manually.
        }
    }
}
</code></pre>
<p>However, the compiler will be able to infer the type if that return value is used later in that function</p>
<p>但是，如果稍后在该函数中使用该返回值，编译器将能够推断其类型。</p>
<pre><code class="language-move">address 0x2 {
    module m {
        using std::vector;

        fun foo() {
            let v = vector::new();
            //                 ^ &lt;u64&gt; is inferred
            vector::push_back(&amp;mut v, 42);
        }
    }
}
</code></pre>
<h2 id="unused-type-parameters-未使用的类型参数"><a class="header" href="#unused-type-parameters-未使用的类型参数">Unused Type Parameters (未使用的类型参数)</a></h2>
<p>For a struct definition, an unused type parameter is one that
does not appear in any field defined in the struct, but is checked statically at compile time.
Move allows unused type parameters so the following struct definition is valid:</p>
<p>对于结构体定义，未使用的类型参数是没有出现在结构体中定义的任何字段中，但在编译时会静态检查的类型参数。Move语言允许未使用的类型参数，因此以下结构定义是有效的：</p>
<pre><code class="language-move">struct Foo&lt;T&gt; {
    foo: u64
}
</code></pre>
<p>This can be convenient when modeling certain concepts. Here is an example:</p>
<p>这在对某些概念进行建模时会很方便。这是一个例子：</p>
<pre><code class="language-move">address 0x2 {
    module m {
        // Currency Specifiers
        struct Currency1 {}
        struct Currency2 {}

        // A generic coin type that can be instantiated using a currency
        // specifier type.
        //   e.g. Coin&lt;Currency1&gt;, Coin&lt;Currency2&gt; etc.
        struct Coin&lt;Currency&gt; has store {
            value: u64
        }

        // Write code generically about all currencies
        public fun mint_generic&lt;Currency&gt;(value: u64): Coin&lt;Currency&gt; {
            Coin { value }
        }

        // Write code concretely about one currency
        public fun mint_concrete(value: u64): Coin&lt;Currency1&gt; {
            Coin { value }
        }
    }
}
</code></pre>
<p>In this example, <code>struct Coin&lt;Currency&gt;</code> is generic on the <code>Currency</code> type parameter,
which specifies the currency of the coin and allows code to be written either generically on any currency or
concretely on a specific currency.
This genericity applies even when the <code>Currency</code> type parameter does not appear in any of the fields defined in <code>Coin</code>.</p>
<p>在此示例中， <code>struct Coin&lt;Currency&gt;</code> 是类型参数为 <code>Currency</code> 的泛型结构体，它指定 <code>Coin</code> 的类型参数是 <code>Currency</code>，这样就允许代码选择是使用任意类型 <code>Currency</code> 或者是指定的具体类型 <code>Currency</code> 。即使 <code>Currency</code> 类型参数没有出现在定义的任何字段中，这种泛型性也适用结构体 <code>Coin</code>。</p>
<h3 id="phantom-type-parameters"><a class="header" href="#phantom-type-parameters">Phantom Type Parameters</a></h3>
<p>In the example above, although <code>struct Coin</code> asks for the <code>store</code> ability, neither <code>Coin&lt;Currency1&gt;</code> nor <code>Coin&lt;Currency2&gt;</code> will have the <code>store</code> ability.
This is because of the rules for <a href="abilities.html#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a> and the fact that <code>Currency1</code> and <code>Currency2</code> don't have the <code>store</code> ability, despite the fact that they are not even used in the body of <code>struct Coin</code>.
This might cause some unpleasant consequences.
For example, we are unable to put <code>Coin&lt;Currency1&gt;</code> into a wallet in the global storage.</p>
<p>在上面的例子中，虽然 <code>struct Coin</code> 要求有 <code>store</code> 能力，但 <code>Coin&lt;Currency1&gt;</code> 和 <code>Coin&lt;Currency2&gt;</code> 都没有 <code>store</code> 能力。这是因为 <a href="./chatper_19_abilities.html#conditional-abilities-and-generic-types">条件能力与泛型类型</a>的规则, 而实际上 <code>Currency1</code>和 <code>Currency2</code> 本身都没有 <code>store</code> 能力，尽管它们甚至没有在<code>struct Coin</code> 的主体中使用. 这可能会导致一些不好的后果。例如，我们无法将 <code>Coin&lt;Currency1&gt;</code> 放入全局存储的一个钱包中。</p>
<p>One possible solution would be to add spurious ability annotations to <code>Currency1</code> and <code>Currency2</code> (i.e., <code>struct Currency1 has store {}</code>).
But, this might lead to bugs or security vulnerabilities because it weakens the types with unnecessary ability declarations.
For example, we would never expect a resource in the global storage to have a field in type <code>Currency1</code>, but this would be possible with the spurious <code>store</code> ability.
Moreover, the spurious annotations would be infectious, requiring many functions generic on the unused type parameter to also include the necessary constraints.</p>
<p>一种可能的解决方案是向 <code>Currency1</code> 和 <code>Currency2</code> 添加虚假能力标注(例如：<code>struct Currency1 has store {}</code>) 。但是，这可能会导致 bugs 或安全漏洞，因为它削弱了类型安全，声明了不必要的能力。例如，我们永远不会期望全局存储中的资源具有 <code>Currency1</code> 类型的字段，但这对于虚假 <code>store</code> 能力是可能发生的。
此外，虚假标注具有传染性，需要在许多未使用类型参数的泛型函数上也引入必要的约束。</p>
<p>Phantom type parameters solve this problem. Unused type parameters can be marked as <em>phantom</em> type parameters,
which do not participate in the ability derivation for structs.
In this way, arguments to phantom type parameters are not considered when deriving the abilities for generic types, thus avoiding the need for spurious ability annotations.
For this relaxed rule to be sound, Move's type system guarantees that a parameter declared as phantom is either not used at all in the struct definition, or it is only used as an argument to type parameters also declared as phantom.</p>
<p>Phantom 类型参数解决了这个问题。未使用的类型参数可以标记为 <em>phantom</em> 类型参数，不参与结构体的能力推导。这样，在派生泛型类型的能力时，不考虑 phantom type 的参数，从而避免了对虚假能力标注的需要。为了使这个宽松的规则合理，Move 的类型系统保证声明为 <code>phantom</code> 的参数要么不在结构定义中使用，要么仅用作声明为 <code>phantom</code> 的类型参数的参数。</p>
<h4 id="声明-declaration-2"><a class="header" href="#声明-declaration-2">声明 (Declaration)</a></h4>
<p>In a struct definition a type parameter can be declared as phantom by adding the <code>phantom</code> keyword before its declaration.
If a type parameter is declared as phantom we say it is a phantom type parameter.
When defining a struct, Move's type checker ensures that every phantom type parameter is either not used inside the struct definition
or it is only used as an argument to a phantom type parameter.</p>
<p><code>phantom</code> 在结构定义中，可以通过在声明之前添加关键字来将类型参数声明为幻影。如果一个类型参数被声明为 phantom，我们就说它是 phantom 类型参数。
定义结构体时，Move语言的类型检查器确保每个 phantom 类型参数要么不在结构定义中使用，要么仅用作 phantom 类型参数的参数。</p>
<p>More formally, if a type is used as an argument to a phantom type parameter we say the type appears in <em>phantom position</em>.
With this definition in place, the rule for the correct use of phantom parameters can be specified as follows: <strong>A phantom type parameter can only appear in phantom position</strong>.</p>
<p>更正式地说，如果将类型用作 phantom 类型参数的输入参数，我们说该类型出现在 <em>phantom 位置</em>。有了这个定义，正确使用  phantom 参数的规则可以指定如下： ** phantom 类型参数只能出现在 phantom 位置**。</p>
<p>The following two examples show valid uses of phantom parameters.
In the first one, the parameter <code>T1</code> is not used at all inside the struct definition.
In the second one, the parameter <code>T1</code> is only used as an argument to a phantom type parameter.</p>
<p>以下两个示例显示了 phantom 参数的 合法用法。在第一个中，<code>T1</code> 在结构体定义中根本不使用参数。在第二种情况下，参数 <code>T1</code> 仅用作 phantom 类型参数的参数。</p>
<pre><code class="language-move">struct S1&lt;phantom T1, T2&gt; { f: u64 }
                  ^^
                  Ok: T1 does not appear inside the struct definition


struct S2&lt;phantom T1, T2&gt; { f: S1&lt;T1, T2&gt; }
                                  ^^
                                  Ok: T1 appears in phantom position
</code></pre>
<p>The following code shows examples of violations of the rule:</p>
<p>以下代码展示违反规则的示例：</p>
<pre><code class="language-move">struct S1&lt;phantom T&gt; { f: T }
                          ^
                          Error: Not a phantom position

struct S2&lt;T&gt; { f: T }

struct S3&lt;phantom T&gt; { f: S2&lt;T&gt; }
                             ^
                             Error: Not a phantom position
</code></pre>
<h4 id="实例化-instantiation"><a class="header" href="#实例化-instantiation">实例化 (Instantiation)</a></h4>
<p>When instantiating a struct, the arguments to phantom parameters are excluded when deriving the struct abilities.
For example, consider the following code:</p>
<p>实例化结构时，派生结构功能时会排除幻影参数的输入参数。例如，考虑以下代码：</p>
<pre><code class="language-move">struct S&lt;T1, phantom T2&gt; has copy { f: T1 }
struct NoCopy {}
struct HasCopy has copy {}
</code></pre>
<p>Consider now the type <code>S&lt;HasCopy, NoCopy&gt;</code>. Since <code>S</code> is defined with <code>copy</code> and all non-phantom arguments have copy then <code>S&lt;HasCopy, NoCopy&gt;</code> also has copy.</p>
<p>现在考虑类型 <code>S&lt;HasCopy, NoCopy&gt;</code>。由于 <code>S</code> 用 <code>copy</code> 定义，且所有非 phantom 参数  具有 <code>copy</code> 能力，所以 <code>S&lt;HasCopy, NoCopy&gt;</code> 也具有 <code>copy</code> 能力。</p>
<h4 id="具有能力约束的-phantom-类型参数-phantom-type-parameters-with-ability-constraints"><a class="header" href="#具有能力约束的-phantom-类型参数-phantom-type-parameters-with-ability-constraints">具有能力约束的 Phantom 类型参数 (Phantom Type Parameters with Ability Constraints)</a></h4>
<p>Ability constraints and phantom type parameters are orthogonal features in the sense that phantom parameters can be declared with ability constraints.
When instantiating a phantom type parameter with an ability constraint, the type argument has to satisfy that constraint, even though the parameter is phantom.
For example, the following definition is perfectly valid:</p>
<p>能力约束和 phantom 类型参数是正交特征，因此 phantom 参数声明时可以用能力进行约束。当使用能力约束实例化一个 phantom 类型参数时，类型参数必须满足该约束，即使参数是。
例如，以下定义是完全有效的：</p>
<pre><code class="language-move">struct S&lt;phantom T: copy&gt; {}
</code></pre>
<p>The usual restrictions apply and <code>T</code> can only be instantiated with arguments having <code>copy</code>.</p>
<p>应用(phantom)通常的限制并且 <code>T</code> 只能用具有 <code>copy</code> 的参数实例化。</p>
<h2 id="约束-constraints"><a class="header" href="#约束-constraints">约束 (Constraints)</a></h2>
<p>In the examples above, we have demonstrated how one can use type parameters to define &quot;unknown&quot; types that can be plugged in by callers at a later time. This however means the type system has little information about the type and has to perform checks in a very conservative way. In some sense, the type system must assume the worst case scenario for an unconstrained generic. Simply put, by default generic type parameters have no <a href="abilities.html">abilities</a>.</p>
<p>This is where constraints come into play: they offer a way to specify what properties these unknown types have so the type system can allow operations that would otherwise be unsafe.</p>
<p>在上面的例子中，我们已经演示了如何使用类型参数来定义“未知”类型，这些类型可以在稍后被调用者插入。然而，这意味着类型系统几乎没有关于类型的信息，并且必须以非常保守的方式执行检查。从某种意义上说，类型系统必须假设不受约束的泛型时的最坏场景。简单地说，默认情况下泛型类型参数没有<a href="abilities.html">能力</a>。</p>
<p>这就是约束发挥作用的地方：它们提供了一种方法来指定这些未知类型具有哪些属性，因此类型系统可以允许相应的操作，否则会不安全。</p>
<h3 id="声明约束-declaring-constraints"><a class="header" href="#声明约束-declaring-constraints">声明约束 (Declaring Constraints)</a></h3>
<p>Constraints can be imposed on type parameters using the following syntax.</p>
<p>可以使用以下语法对类型参数施加约束。</p>
<pre><code class="language-move">// T is the name of the type parameter
T: &lt;ability&gt; (+ &lt;ability&gt;)*
</code></pre>
<p>The <code>&lt;ability&gt;</code> can be any of the four <a href="abilities.html">abilities</a>, and a type parameter can be constrained with multiple <a href="abilities.html">abilities</a> at once. So all of the following would be valid type parameter declarations</p>
<p><code>&lt;ability&gt;</code> 可以是四种<a href="abilities.html">能力</a>中的任何一种，一个类型参数可以同时被多个能力约束。因此，以下所有内容都是有效的类型参数声明</p>
<pre><code class="language-move">T: copy
T: copy + drop
T: copy + drop + store + key
</code></pre>
<h3 id="验证约束-verifying-constraints"><a class="header" href="#验证约束-verifying-constraints">验证约束 (Verifying Constraints)</a></h3>
<p>Constraints are checked at call sites so the following code won't compile.</p>
<p>在调用的地方会检查约束，因此以下代码无法编译。</p>
<pre><code class="language-move">struct Foo&lt;T: key&gt; { x: T }

struct Bar { x: Foo&lt;u8&gt; }
//                  ^ error! u8 does not have 'key'

struct Baz&lt;T&gt; { x: Foo&lt;T&gt; }
//                     ^ error! T does not have 'key'
</code></pre>
<pre><code class="language-move">struct R {}

fun unsafe_consume&lt;T&gt;(x: T) {
    // error! x does not have 'drop'
}

fun consume&lt;T: drop&gt;(x: T) {
    // valid!
    // x will be dropped automatically
}

fun foo() {
    let r = R {};
    consume&lt;R&gt;(r);
    //      ^ error! R does not have 'drop'
}
</code></pre>
<pre><code class="language-move">struct R {}

fun unsafe_double&lt;T&gt;(x: T) {
    (copy x, x)
    // error! x does not have 'copy'
}

fun double&lt;T: copy&gt;(x: T) {
    (copy x, x) // valid!
}

fun foo(): (R, R) {
    let r = R {};
    double&lt;R&gt;(r)
    //     ^ error! R does not have copy
}
</code></pre>
<p>For more information, see the abilities section on <a href="./abilities.html#conditional-abilities-and-generic-types">conditional abilities and generic types</a></p>
<p>有关更多信息，请参阅有关<a href="abilities.html#conditional-abilities-and-generic-types">条件能力与泛型类型</a></p>
<h2 id="递归的限制-limitations-on-recursions"><a class="header" href="#递归的限制-limitations-on-recursions">递归的限制 (Limitations on Recursions)</a></h2>
<h3 id="递归结构-recursive-structs"><a class="header" href="#递归结构-recursive-structs">递归结构 (Recursive Structs)</a></h3>
<p>Generic structs can not contain fields of the same type, either directly or indirectly, even with different type arguments. All of the following struct definitions are invalid:</p>
<p>泛型结构不能直接或间接包含相同类型的字段，即使使用不同的类型参数也是如此。以下所有结构定义均无效：</p>
<pre><code class="language-move">struct Foo&lt;T&gt; {
    x: Foo&lt;u64&gt; // error! 'Foo' containing 'Foo'
}

struct Bar&lt;T&gt; {
    x: Bar&lt;T&gt; // error! 'Bar' containing 'Bar'
}

// error! 'A' and 'B' forming a cycle, which is not allowed either.
struct A&lt;T&gt; {
    x: B&lt;T, u64&gt;
}

struct B&lt;T1, T2&gt; {
    x: A&lt;T1&gt;
    y: A&lt;T2&gt;
}
</code></pre>
<h3 id="高级主题类型-级别递归-advanced-topic-type-level-recursions"><a class="header" href="#高级主题类型-级别递归-advanced-topic-type-level-recursions">高级主题：类型-级别递归 (Advanced Topic: Type-level Recursions)</a></h3>
<p>Move allows generic functions to be called recursively. However, when used in combination with generic structs, this could create an infinite number of types in certain cases, and allowing this means adding unnecessary complexity to the compiler, vm and other language components. Therefore, such recursions are forbidden.</p>
<p>Move语言允许递归调用泛型函数。但是，当与泛型结构体结合使用时，在某些情况下可能会创建无限数量的类型，这意味着会给编译器、vm 和其他语言组件增加不必要的复杂性。因此，这种递归是被禁止的。</p>
<p>被允许的用法:</p>
<pre><code class="language-move">address 0x2 {
    module m {
        struct A&lt;T&gt; {}

        // Finitely many types -- allowed.
        // foo&lt;T&gt; -&gt; foo&lt;T&gt; -&gt; foo&lt;T&gt; -&gt; ... is valid
        fun foo&lt;T&gt;() {
            foo&lt;T&gt;();
        }

        // Finitely many types -- allowed.
        // foo&lt;T&gt; -&gt; foo&lt;A&lt;u64&gt;&gt; -&gt; foo&lt;A&lt;u64&gt;&gt; -&gt; ... is valid
        fun foo&lt;T&gt;() {
            foo&lt;A&lt;u64&gt;&gt;();
        }
    }
}
</code></pre>
<p>不被允许的用法:</p>
<pre><code class="language-move">address 0x2 {
    module m {
        struct A&lt;T&gt; {}

        // Infinitely many types -- NOT allowed.
        // error!
        // foo&lt;T&gt; -&gt; foo&lt;A&lt;T&gt;&gt; -&gt; foo&lt;A&lt;A&lt;T&gt;&gt;&gt; -&gt; ...
        fun foo&lt;T&gt;() {
            foo&lt;Foo&lt;T&gt;&gt;();
        }
    }
}

address 0x2 {
    module n {
        struct A&lt;T&gt; {}

        // Infinitely many types -- NOT allowed.
        // error!
        // foo&lt;T1, T2&gt; -&gt; bar&lt;T2, T1&gt; -&gt; foo&lt;T2, A&lt;T1&gt;&gt;
        //   -&gt; bar&lt;A&lt;T1&gt;, T2&gt; -&gt; foo&lt;A&lt;T1&gt;, A&lt;T2&gt;&gt;
        //   -&gt; bar&lt;A&lt;T2&gt;, A&lt;T1&gt;&gt; -&gt; foo&lt;A&lt;T2&gt;, A&lt;A&lt;T1&gt;&gt;&gt;
        //   -&gt; ...
        fun foo&lt;T1, T2&gt;() {
            bar&lt;T2, T1&gt;();
        }

        fun bar&lt;T1, T2&gt; {
            foo&lt;T1, A&lt;T2&gt;&gt;();
        }
    }
}
</code></pre>
<p>Note, the check for type level recursions is based on a conservative analysis on the call sites and does NOT take control flow or runtime values into account.</p>
<p>请注意，类型级别递归的检查是基于对调用现场的保守分析，并且不考虑控制流或运行时值。</p>
<pre><code class="language-move">address 0x2 {
    module m {
        struct A&lt;T&gt; {}

        fun foo&lt;T&gt;(n: u64) {
            if (n &gt; 0) {
                foo&lt;A&lt;T&gt;&gt;(n - 1);
            };
        }
    }
}
</code></pre>
<p>The function in the example above will technically terminate for any given input and therefore only creating finitely many types, but it is still considered invalid by Move's type system.</p>
<p>上例中的函数将在技术上给定有限的输入，因此只会创建有限多的类型，但仍然会被 Move 语言的类型系统认为是无效的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="能力-abilities"><a class="header" href="#能力-abilities">能力 (abilities)</a></h1>
<p>Abilities are a typing feature in Move that control what actions are permissible for values of a given type. This system grants fine grained control over the &quot;linear&quot; typing behavior of values, as well as if and how values are used in global storage. This is implemented by gating access to certain bytecode instructions so that for a value to be used with the bytecode instruction, it must have the ability required (if one is required at all—not every instruction is gated by an ability).</p>
<p>能力是 Move 语言中的一种类型特性，用于控制对给定类型的值允许哪些操作。 该系统对值的“线性”类型行为以及值如何在全局存储中使用提供细粒度控制。这是通过对某些字节码指令的进行访问控制来实现的，因此对于要与字节码指令一起使用的值，它必须具有所需的能力(如果需要的话，并非每条指令都由能力控制)</p>
<h2 id="四种能力-the-four-abilities"><a class="header" href="#四种能力-the-four-abilities">四种能力 (The Four Abilities)</a></h2>
<p>The four abilities are:</p>
<ul>
<li><a href="abilities.html#copy"><code>copy</code></a>
<ul>
<li>Allows values of types with this ability to be copied.</li>
</ul>
</li>
<li><a href="abilities.html#drop"><code>drop</code></a>
<ul>
<li>Allows values of types with this ability to be popped/dropped.</li>
</ul>
</li>
<li><a href="abilities.html#store"><code>store</code></a>
<ul>
<li>Allows values of types with this ability to exist inside a struct in global storage.</li>
</ul>
</li>
<li><a href="abilities.html#key"><code>key</code></a>
<ul>
<li>Allows the type to serve as a key for global storage operations.</li>
</ul>
</li>
</ul>
<p>这四种能力分别是：</p>
<ul>
<li>
<p><a href="abilities.html#copy"><code>copy</code></a> 复制</p>
<ul>
<li>允许此类型的值被复制</li>
</ul>
</li>
<li>
<p><a href="abilities.html#drop"><code>drop</code></a> 丢弃</p>
<ul>
<li>允许此类型的值被弹出/丢弃</li>
</ul>
</li>
<li>
<p><a href="abilities.html#store"><code>store</code></a> 存储</p>
<ul>
<li>允许此类型的值存在于全局存储的某个结构体中</li>
</ul>
</li>
<li>
<p><a href="abilities.html#key"><code>key</code></a> 键值</p>
<ul>
<li>允许此类型作为全局存储中的键(具有 <code>key</code> 能力的类型才能保存到全局存储中)</li>
</ul>
</li>
</ul>
<h3 id="copy"><a class="header" href="#copy"><code>copy</code></a></h3>
<p>The <code>copy</code> ability allows values of types with that ability to be copied. It gates the ability to copy values out of local variables with the <a href="./variables.html#move-and-copy"><code>copy</code></a> operator and to copy values via references with <a href="./references.html#%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5">dereference <code>*e</code></a>.</p>
<p>If a value has <code>copy</code>, all values contained inside of that value have <code>copy</code>.</p>
<p><code>copy</code> 能力允许具有此能力的类型的值被复制。 它限制了从本地变量通过 <a href="./variables.html#.move-and-copy"><code>copy</code></a>能力复制值以及通过 <a href="./references.html#%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5"><code>dereference *e</code></a>复制值这两种情况之外的复制操作。</p>
<p>如果一个值具有 <code>copy</code> 能力，那么这个值内部的所有值都有 <code>copy</code> 能力。</p>
<h3 id="drop"><a class="header" href="#drop"><code>drop</code></a></h3>
<p>The <code>drop</code> ability allows values of types with that ability to be dropped. By dropped, we mean that value is not transferred and is effectively destroyed as the Move program executes. As such, this ability gates the ability to ignore values in a multitude of locations, including:</p>
<ul>
<li>not using the value in a local variable or parameter</li>
<li>not using the value in a <a href="./variables.html#expression-blocks">sequence via <code>;</code></a></li>
<li>overwriting values in variables in <a href="./variables.html#assignments">assignments</a></li>
<li>overwriting values via references when <a href="./references.html#reading-and-writing-through-references">writing <code>*e1 = e2</code></a>.</li>
</ul>
<p>If a value has <code>drop</code>, all values contained inside of that value have <code>drop</code>.</p>
<p><code>drop</code> 能力允许类型的值被丢弃。丢弃的意思程序执行后值会被有效的销毁而不必被转移。因此，这个能力限制在多个位置忽略使用值的可能性，包括：</p>
<ul>
<li>未被使用的局部变量或者参数</li>
<li>未被使用的 <a href="./variables.html#expression-blocks"><code>sequence</code> via <code>;</code></a>中的值</li>
<li>覆盖<a href="./variables.html#assignments">赋值(assignments)</a>变量中的值</li>
<li><a href="https://move-language.github.io/move/references.html#reading-and-writing-through-references">写入(writing) <code>*e1 = e2</code></a> 时通过引用覆盖的值。</li>
</ul>
<p>如果一个值具有 <code>drop</code> 能力，那么这个值内部的所有值都有 <code>drop</code> 能力。</p>
<h3 id="store"><a class="header" href="#store"><code>store</code></a></h3>
<p>The <code>store</code> ability allows values of types with this ability to exist inside of a struct (resource) in global storage, <em>but</em> not necessarily as a top-level resource in global storage. This is the only ability that does not directly gate an operation. Instead it gates the existence in global storage when used in tandem with <code>key</code>.</p>
<p>If a value has <code>store</code>, all values contained inside of that value have <code>store</code></p>
<p><code>store</code> 能力允许具有这种能力的类型的值位于<a href="./global-storage-operators.html">全局存储</a>中的结构体(资源)内, <em>但不一定是</em> 全局存储中的顶级资源。这是唯一不直接限制操作的能力。相反，当(<code>store</code>)与 <code>key</code> 一起使用时，它对全局存储中的可行性进行把关。。</p>
<p>如果一个值具有 <code>store</code> 能力，那么这个值内部的所有值都有 <code>store</code> 能力。</p>
<h3 id="key"><a class="header" href="#key"><code>key</code></a></h3>
<p>The <code>key</code> ability allows the type to serve as a key for <a href="./global-storage-operators.html">global storage operations</a>. It gates all global storage operations, so in order for a type to be used with <code>move_to</code>, <code>borrow_global</code>, <code>move_from</code>, etc., the type must have the <code>key</code> ability. Note that the operations still must be used in the module where the <code>key</code> type is defined (in a sense, the operations are private to the defining module).</p>
<p>If a value has <code>key</code>, all values contained inside of that value have <code>store</code>. This is the only ability with this sort of asymmetry.</p>
<p><code>key</code> 能力允许此类型作为<a href="./global-storage-operators.html">全局存储</a>中的键。它会限制所有<a href="./global-storage-operators.html">全局存储</a>中的操作，因此一个类型如果与 <code>move_to</code>, <code>borrow_global</code>, <code>move_from</code> 等一起使用，那么这个类型必须具备 <code>key</code> 能力。请注意，这些操作仍然必须在定义 <code>key</code> 类型的模块中使用(从某种意义上说，这些操作是此模块的私有操作)。</p>
<p>如果有一个值有 <code>key</code> 能力，那么这个值包含的所有字段值也都具有 <code>store</code> 能力，<code>key</code> 能力是唯一一个具有非对称的能力。</p>
<h2 id="builtin-types-内置类型"><a class="header" href="#builtin-types-内置类型">Builtin Types (内置类型)</a></h2>
<p>Most primitive, builtin types have <code>copy</code>, <code>drop</code>, and <code>store</code> with the exception of <code>signer</code>, which just has <code>store</code></p>
<ul>
<li><code>bool</code>, <code>u8</code>, <code>u64</code>, <code>u128</code>, and <code>address</code> all have <code>copy</code>, <code>drop</code>, and <code>store</code>.</li>
<li><code>signer</code> has <code>drop</code>
<ul>
<li>Cannot be copied and cannot be put into global storage</li>
</ul>
</li>
<li><code>vector&lt;T&gt;</code> may have <code>copy</code>, <code>drop</code>, and <code>store</code> depending on the abilities of <code>T</code>.
<ul>
<li>See <a href="abilities.html#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a> for more details.</li>
</ul>
</li>
<li>Immutable references <code>&amp;</code> and mutable references <code>&amp;mut</code> both have <code>copy</code> and <code>drop</code>.
<ul>
<li>This refers to copying and dropping the reference itself, not what they refer to.</li>
<li>References cannot appear in global storage, hence they do not have <code>store</code>.</li>
</ul>
</li>
</ul>
<p>None of the primitive types have <code>key</code>, meaning none of them can be used directly with the <a href="./global-storage-operators.html">global storage operations</a>.</p>
<p>几乎所有内置的基本类型具都有 <code>copy</code>，<code>drop</code>，以及 <code>store</code> 能力，<code>singer</code> 除外，它只有 <code>drop</code> 能力(原文是 <code>store</code> 有误，译者注)</p>
<ul>
<li><code>bool</code>, <code>u8</code>, <code>u64</code>, <code>u128</code>, <code>address</code> 都具有 <code>copy</code>, <code>drop</code>, 以及 <code>store</code> 能力。</li>
<li><code>signer</code> 具有 <code>drop</code> 能力。 不能被复制以及不能被存放在全局存储中</li>
<li><code>vector&lt;T&gt;</code> 可能具有 <code>copy</code>，<code>drop</code>，以及<code>store</code> 能力，这依赖于 <code>T</code> 具有的能力。 查看 <a href="abilities.html#conditional-abilities-and-generic-types">条件能力与泛型类型</a>获取详情</li>
<li>不可变引用 <code>&amp;</code> 和可变引用 <code>&amp;mut</code> 都具有 <code>copy</code> 和 <code>drop</code> 能力。
<ul>
<li>这是指复制和删除引用本身，而不是它们所引用的内容。</li>
<li>引用不能出现在全局存储中，因此它们没有 <code>store</code> 能力。</li>
</ul>
</li>
</ul>
<p>所有基本类型都没有 <code>key</code>，这意味着它们都不能直接用于<a href="./global-storage-operators.html">全局存储操作</a>。</p>
<h2 id="annotating-structs-标注结构体"><a class="header" href="#annotating-structs-标注结构体">Annotating Structs (标注结构体)</a></h2>
<p>To declare that a <code>struct</code> has an ability, it is declared with <code>has &lt;ability&gt;</code> after the struct name but before the fields. For example:</p>
<p>要声明一个 <code>struct</code> 具有某个能力，它在结构体名称之后, 在字段之前用 <code>has &lt;ability&gt;</code> 声明。例如：</p>
<pre><code class="language-move">struct Ignorable has drop { f: u64 }
struct Pair has copy, drop, store { x: u64, y: u64 }
</code></pre>
<p>In this case: <code>Ignorable</code> has the <code>drop</code> ability. <code>Pair</code> has <code>copy</code>, <code>drop</code>, and <code>store</code>.</p>
<p>在这个例子中：<code>Ignorable</code> 具有 <code>drop</code> 能力。 <code>Pair</code> 具有 <code>copy</code>、<code>drop</code> 和 <code>store</code> 能力。</p>
<p>All of these abilities have strong guarantees over these gated operations. The operation can be performed on the value only if it has that ability; even if the value is deeply nested inside of some other collection!</p>
<p>所有这些能力对这些访问操作都有强有力的保证。只有具有该能力，才能对值执行对应的操作；即使该值深层嵌套在其他集合中！</p>
<p>As such: when declaring a struct’s abilities, certain requirements are placed on the fields. All fields must satisfy these constraints. These rules are necessary so that structs satisfy the reachability rules for the abilities given above. If a struct is declared with the ability...</p>
<ul>
<li><code>copy</code>, all fields must have <code>copy</code>.</li>
<li><code>drop</code>, all fields must have <code>drop</code>.</li>
<li><code>store</code>, all fields must have <code>store</code>.</li>
<li><code>key</code>, all fields must have <code>store</code>.
<ul>
<li><code>key</code> is the only ability currently that doesn’t require itself.</li>
</ul>
</li>
</ul>
<p>因此：在声明结构体的能力时，对字段提出了某些要求。所有字段都必须满足这些约束。这些规则是必要的，以便结构体满足上述功能的可达性规则。如果一个结构被声明为具有某能力：</p>
<ul>
<li><code>copy</code>， 所有的字段必须具有 <code>copy</code> 能力。</li>
<li><code>drop</code>，所有的字段必须具有 <code>drop</code> 能力。</li>
<li><code>store</code>，所有的字段必须具有 <code>store</code> 能力。</li>
<li><code>key</code>，所有的字段必须具有 <code>store</code> 能力。<code>key</code> 是目前唯一不需要包含自身的能力。</li>
</ul>
<p>例如:</p>
<pre><code class="language-move">// A struct without any abilities
struct NoAbilities {}

struct WantsCopy has copy {
    f: NoAbilities, // ERROR 'NoAbilities' does not have 'copy'
}
</code></pre>
<p>and similarly:</p>
<p>类似的：</p>
<pre><code class="language-move">// A struct without any abilities
struct NoAbilities {}

struct MyResource has key {
    f: NoAbilities, // Error 'NoAbilities' does not have 'store'
}
</code></pre>
<h2 id="conditional-abilities-and-generic-types-条件能力与泛型类型"><a class="header" href="#conditional-abilities-and-generic-types-条件能力与泛型类型">Conditional Abilities and Generic Types (条件能力与泛型类型)</a></h2>
<p>When abilities are annotated on a generic type, not all instances of that type are guaranteed to have that ability. Consider this struct declaration:</p>
<p>在泛型类型上标注能力时，并非该类型的所有实例都保证具有该能力。考虑这个结构体声明：</p>
<pre><code class="language-move">struct Cup&lt;T&gt; has copy, drop, store, key { item: T }
</code></pre>
<p>It might be very helpful if <code>Cup</code> could hold any type, regardless of its abilities. The type system can <em>see</em> the type parameter, so it should be able to remove abilities from <code>Cup</code> if it <em>sees</em> a type parameter that would violate the guarantees for that ability.</p>
<p>This behavior might sound a bit confusing at first, but it might be more understandable if we think about collection types. We could consider the builtin type <code>vector</code> to have the following type declaration:</p>
<p>如果 <code>Cup</code> 可以容纳任何类型，可能会很有帮助，不管它的能力如何。类型系统可以 <em>看到</em> 类型参数，因此，如果它 <em>发现</em> 一个类型参数违反了对该能力的保证，它应该能够从 <code>Cup</code> 中删除能力。</p>
<p>这种行为一开始可能听起来有点令人困惑，但如果我们考虑一下集合类型，它可能会更容易理解。我们可以认为内置类型 <code>Vector</code> 具有以下类型声明：</p>
<pre><code class="language-move">vector&lt;T&gt; has copy, drop, store;
</code></pre>
<p>We want <code>vector</code>s to work with any type. We don't want separate <code>vector</code> types for different abilities. So what are the rules we would want? Precisely the same that we would want with the field rules above.  So, it would be safe to copy a <code>vector</code> value only if the inner elements can be copied. It would be safe to ignore a <code>vector</code> value only if the inner elements can be ignored/dropped. And, it would be safe to put a <code>vector</code> in global storage only if the inner elements can be in global storage.</p>
<p>To have this extra expressiveness, a type might not have all the abilities it was declared with depending on the instantiation of that type; instead, the abilities a type will have depends on both its declaration <strong>and</strong> its type arguments. For any type, type parameters are pessimistically assumed to be used inside of the struct, so the abilities are only granted if the type parameters meet the requirements described above for fields. Taking <code>Cup</code> from above as an example:</p>
<ul>
<li><code>Cup</code> has the ability <code>copy</code> only if <code>T</code> has <code>copy</code>.</li>
<li>It has <code>drop</code> only if <code>T</code> has <code>drop</code>.</li>
<li>It has <code>store</code> only if <code>T</code> has <code>store</code>.</li>
<li>It has <code>key</code> only if <code>T</code> has <code>store</code>.</li>
</ul>
<p>我们希望 <code>vector</code> 适用于任何类型。我们不希望针对不同的能力使用不同的 <code>vector</code> 类型。那么我们想要的规则是什么？与上面的字段规则完全相同。因此，仅当可以复制内部元素时，复制<code>vector</code> 值才是安全的。仅当可以忽略/丢弃内部元素时，忽略 <code>vector</code> 值才是安全的。而且，仅当内部元素可以在全局存储中时，将向量放入全局存储中才是安全的。</p>
<p>为了具有这种额外的表现力，一个类型可能不具备它声明的所有能力，具体取决于该类型的实例化；相反，一个类型的能力取决于它的声明 <strong>和</strong> 它的类型参数。对于任何类型，类型参数都被悲观地假定为在结构体内部使用，因此只有在类型参数满足上述字段要求时才授予这些能力。以上面的 <code>Cup</code> 为例：</p>
<ul>
<li><code>Cup</code> 拥有 <code>copy</code> 能力 仅当 <code>T</code> 拥有 <code>copy</code> 能力时。</li>
<li><code>Cup</code> 拥有 <code>drop</code> 能力 仅当 <code>T</code> 拥有 <code>drop</code> 能力时。</li>
<li><code>Cup</code> 拥有 <code>store</code> 能力 仅当 <code>T</code> 拥有 <code>store</code> 能力时。</li>
<li><code>Cup</code> 拥有 <code>key</code> 能力 仅当 <code>T</code> 拥有 <code>store</code> 能力时。</li>
</ul>
<p>Here are examples for this conditional system for each ability:</p>
<p>以下是每个能力的条件系统的示例：</p>
<h3 id="example-conditional-copy"><a class="header" href="#example-conditional-copy">Example: conditional <code>copy</code></a></h3>
<pre><code class="language-move">struct NoAbilities {}
struct S has copy, drop { f: bool }
struct Cup&lt;T&gt; has copy, drop, store { item: T }

fun example(c_x: Cup&lt;u64&gt;, c_s: Cup&lt;S&gt;) {
    // Valid, 'Cup&lt;u64&gt;' has 'copy' because 'u64' has 'copy'
    let c_x2 = copy c_x;
    // Valid, 'Cup&lt;S&gt;' has 'copy' because 'S' has 'copy'
    let c_s2 = copy c_s;
}

fun invalid(c_account: Cup&lt;signer&gt;, c_n: Cup&lt;NoAbilities&gt;) {
    // Invalid, 'Cup&lt;signer&gt;' does not have 'copy'.
    // Even though 'Cup' was declared with copy, the instance does not have 'copy'
    // because 'signer' does not have 'copy'
    let c_account2 = copy c_account;
    // Invalid, 'Cup&lt;NoAbilities&gt;' does not have 'copy'
    // because 'NoAbilities' does not have 'copy'
    let c_n2 = copy c_n;
}
</code></pre>
<h3 id="example-conditional-drop"><a class="header" href="#example-conditional-drop">Example: conditional <code>drop</code></a></h3>
<pre><code class="language-move">struct NoAbilities {}
struct S has copy, drop { f: bool }
struct Cup&lt;T&gt; has copy, drop, store { item: T }

fun unused() {
    Cup&lt;bool&gt; { item: true }; // Valid, 'Cup&lt;bool&gt;' has 'drop'
    Cup&lt;S&gt; { item: S { f: false }}; // Valid, 'Cup&lt;S&gt;' has 'drop'
}

fun left_in_local(c_account: Cup&lt;signer&gt;): u64 {
    let c_b = Cup&lt;bool&gt; { item: true };
    let c_s = Cup&lt;S&gt; { item: S { f: false }};
    // Valid return: 'c_account', 'c_b', and 'c_s' have values
    // but 'Cup&lt;signer&gt;', 'Cup&lt;bool&gt;', and 'Cup&lt;S&gt;' have 'drop'
    0
}

fun invalid_unused() {
    // Invalid, Cannot ignore 'Cup&lt;NoAbilities&gt;' because it does not have 'drop'.
    // Even though 'Cup' was declared with 'drop', the instance does not have 'drop'
    // because 'NoAbilities' does not have 'drop'
    Cup&lt;NoAbilities&gt; { item: NoAbilities {}};
}

fun invalid_left_in_local(): u64 {
    let n = Cup&lt;NoAbilities&gt; { item: NoAbilities {}};
    // Invalid return: 'c_n' has a value
    // and 'Cup&lt;NoAbilities&gt;' does not have 'drop'
    0
}
</code></pre>
<h3 id="example-conditional-store"><a class="header" href="#example-conditional-store">Example: conditional <code>store</code></a></h3>
<pre><code class="language-move">struct Cup&lt;T&gt; has copy, drop, store { item: T }

// 'MyInnerResource' is declared with 'store' so all fields need 'store'
struct MyInnerResource has store {
    yes: Cup&lt;u64&gt;, // Valid, 'Cup&lt;u64&gt;' has 'store'
    // no: Cup&lt;signer&gt;, Invalid, 'Cup&lt;signer&gt;' does not have 'store'
}

// 'MyResource' is declared with 'key' so all fields need 'store'
struct MyResource has key {
    yes: Cup&lt;u64&gt;, // Valid, 'Cup&lt;u64&gt;' has 'store'
    inner: Cup&lt;MyInnerResource&gt;, // Valid, 'Cup&lt;MyInnerResource&gt;' has 'store'
    // no: Cup&lt;signer&gt;, Invalid, 'Cup&lt;signer&gt;' does not have 'store'
}
</code></pre>
<h3 id="example-conditional-key"><a class="header" href="#example-conditional-key">Example: conditional <code>key</code></a></h3>
<pre><code class="language-move">struct NoAbilities {}
struct MyResource&lt;T&gt; has key { f: T }

fun valid(account: &amp;signer) acquires MyResource {
    let addr = signer::address_of(account);
     // Valid, 'MyResource&lt;u64&gt;' has 'key'
    let has_resource = exists&lt;MyResource&lt;u64&gt;&gt;(addr);
    if (!has_resource) {
         // Valid, 'MyResource&lt;u64&gt;' has 'key'
        move_to(account, MyResource&lt;u64&gt; { f: 0 })
    };
    // Valid, 'MyResource&lt;u64&gt;' has 'key'
    let r = borrow_global_mut&lt;MyResource&lt;u64&gt;&gt;(addr)
    r.f = r.f + 1;
}

fun invalid(account: &amp;signer) {
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   let has_it = exists&lt;MyResource&lt;NoAbilities&gt;&gt;(addr);
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   let NoAbilities {} = move_from&lt;NoAbilities&gt;(addr);
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   move_to(account, NoAbilities {});
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   borrow_global&lt;NoAbilities&gt;(addr);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用与别名uses-and-aliases"><a class="header" href="#使用与别名uses-and-aliases">使用与别名（Uses and Aliases）</a></h1>
<p>The <code>use</code> syntax can be used to create aliases to members in other modules. <code>use</code> can be used to
create aliases that last either for the entire module, or for a given expression block scope.</p>
<p><code>use</code> 语法可用于为其他模块中的成员创建别名。 <code>use</code> 可用于创建持续整个模块或给定表达式块范围的别名。</p>
<h2 id="语法syntax"><a class="header" href="#语法syntax">语法（Syntax）</a></h2>
<p>There are several different syntax cases for <code>use</code>. Starting with the most simple, we have the
following for creating aliases to other modules</p>
<p>这里有几种不同的语法案例可供使用。从最简单的开始，我们有以下例子用于为其他模块创建别名</p>
<pre><code class="language-move">use &lt;address&gt;::&lt;module name&gt;;
use &lt;address&gt;::&lt;module name&gt; as &lt;module alias name&gt;;
</code></pre>
<p>For example
举例</p>
<pre><code class="language-move">use std::vector;
use std::vector as V;
</code></pre>
<p><code>use std::vector;</code> introduces an alias <code>vector</code> for <code>std::vector</code>. This means that anywhere you
would want to use the module name <code>std::vector</code> (assuming this <code>use</code> is in scope), you could use
<code>vector</code> instead. <code>use std::vector;</code> is equivalent to <code>use std::vector as vector;</code></p>
<p><code>use std::vector；</code>为 <code>std::vector</code> 引入别名向量。这意味着在任何您想使用模块名称 <code>std::vector</code> 的地方（假设此<code>use</code>在作用域内），您都可以使用 <code>vector</code> 代替使用<code>std::vector</code>;</p>
<p>Similarly <code>use std::vector as V;</code> would let you use <code>V</code> instead of <code>std::vector</code></p>
<p>同样使用 <code>std::vector as V</code>;会让你使用 <code>V</code> 代替 <code>std::vector</code></p>
<pre><code class="language-move">use std::vector;
use std::vector as V;

fun new_vecs(): (vector&lt;u8&gt;, vector&lt;u8&gt;, vector&lt;u8&gt;) {
    let v1 = std::vector::empty();
    let v2 = vector::empty();
    let v3 = V::empty();
    (v1, v2, v3)
}
</code></pre>
<p>If you want to import a specific module member (such as a function, struct, or constant). You can
use the following syntax.</p>
<p>如果要导入特定的模块成员（例如函数、结构或常量）。您可以使用以下语法。</p>
<pre><code class="language-move">use &lt;address&gt;::&lt;module name&gt;::&lt;module member&gt;;
use &lt;address&gt;::&lt;module name&gt;::&lt;module member&gt; as &lt;member alias&gt;;
</code></pre>
<p>For example
举例</p>
<pre><code class="language-move">use std::vector::empty;
use std::vector::empty as empty_vec;
</code></pre>
<p>This would let you use the function <code>std::vector::empty</code> without full qualification. Instead you
could use <code>empty</code> and <code>empty_vec</code> respectively. Again, <code>use std::vector::empty;</code> is equivalent to
<code>use std::vector::empty as empty;</code></p>
<p>这将允许您在没有前缀限定的情况下使用函数 <code>std::vector::empty</code>。相反，您可以分别使用 <code>empty</code> 和 <code>empty_vec</code>，使用 <code>std::vector::empty;</code>使用<code>empty</code> 相当于使用<code>std::vector::empty</code>;</p>
<pre><code class="language-move">use std::vector::empty;
use std::vector::empty as empty_vec;

fun new_vecs(): (vector&lt;u8&gt;, vector&lt;u8&gt;, vector&lt;u8&gt;) {
    let v1 = std::vector::empty();
    let v2 = empty();
    let v3 = empty_vec();
    (v1, v2, v3)
}
</code></pre>
<p>If you want to add aliases for multiple module members at once, you can do so with the following
syntax</p>
<p>如果要一次为多个模块成员添加别名，可以使用以下语法</p>
<pre><code class="language-move">use &lt;address&gt;::&lt;module name&gt;::{&lt;module member&gt;, &lt;module member&gt; as &lt;member alias&gt; ... };
</code></pre>
<p>For example
举例</p>
<pre><code class="language-move">use std::vector::{push_back, length as len, pop_back};

fun swap_last_two&lt;T&gt;(v: &amp;mut vector&lt;T&gt;) {
    assert!(len(v) &gt;= 2, 42);
    let last = pop_back(v);
    let second_to_last = pop_back(v);
    push_back(v, last);
    push_back(v, second_to_last)
}
</code></pre>
<p>If you need to add an alias to the Module itself in addition to module members, you can do that in a
single <code>use</code> using <code>Self</code>. <code>Self</code> is a member of sorts that refers to the module.</p>
<p>如果除了模块成员之外，您还需要为模块本身添加别名，您可以使用 <code>Self</code> 在一次<code>use</code>中完成。 <code>Self</code> 是指模块的各种成员。</p>
<pre><code class="language-move">use std::vector::{Self, empty};
For clarity, all of the following are equivalent:
</code></pre>
<p>For clarity, all of the following are equivalent:</p>
<p>为清晰起见，以下所有内容都是等效的：</p>
<pre><code class="language-move">use std::vector;
use std::vector as vector;
use std::vector::Self;
use std::vector::Self as vector;
use std::vector::{Self};
use std::vector::{Self as vector};
</code></pre>
<p>If needed, you can have as many aliases for any item as you like</p>
<p>如果需要，您可以为任何项目设置任意数量的别名</p>
<pre><code class="language-move">use std::vector::{
    Self,
    Self as V,
    length,
    length as len,
};

fun pop_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): (T, T) {
    // all options available given the `use` above
    assert!(vector::length(v) &gt; 1, 42);
    assert!(V::length(v) &gt; 1, 42);
    assert!(length(v) &gt; 1, 42);
    assert!(len(v) &gt; 1, 42);

    (vector::pop_back(v), vector::pop_back(v))
}
</code></pre>
<h2 id="模块内部inside-a-module"><a class="header" href="#模块内部inside-a-module">模块内部（Inside a <code>module</code>）</a></h2>
<p>Inside of a <code>module</code> all <code>use</code> declarations are usable regardless of the order of declaration.</p>
<p>在模块内部，无论声明顺序如何，所有 <code>use</code> 声明都是可用的。</p>
<pre><code class="language-move">address 0x42 {
module example {
    use std::vector;

    fun example(): vector&lt;u8&gt; {
        let v = empty();
        vector::push_back(&amp;mut v, 0);
        vector::push_back(&amp;mut v, 10);
        v
    }

    use std::vector::empty;
}
}
</code></pre>
<p>The aliases declared by <code>use</code> in the module usable within that module.</p>
<p>在该模块中可用的模块中使用声明的别名。</p>
<p>Additionally, the aliases introduced cannot conflict with other module members. See
<a href="uses.html#uniqueness">Uniqueness</a> for more details</p>
<p>此外，引入的别名不能与其他模块成员冲突。有关详细信息，请参阅<a href="uses.html#uniqueness">唯一性</a>。</p>
<h2 id="表达式内部inside-an-expression"><a class="header" href="#表达式内部inside-an-expression">表达式内部（Inside an expression）</a></h2>
<p>You can add <code>use</code> declarations to the beginning of any expression block</p>
<p>您可以将 <code>use</code> 声明添加到任何表达式块的开头</p>
<pre><code class="language-move">address 0x42 {
module example {

    fun example(): vector&lt;u8&gt; {
        use std::vector::{empty, push_back};

        let v = empty();
        push_back(&amp;mut v, 0);
        push_back(&amp;mut v, 10);
        v
    }
}
}
</code></pre>
<p>As with <code>let</code>, the aliases introduced by <code>use</code> in an expression block are removed at the end of that
block.</p>
<p>与 <code>let</code> 一样，在表达式块中使用 <code>use</code> 引入的别名在该块的末尾被删除。</p>
<pre><code class="language-move">address 0x42 {
module example {

    fun example(): vector&lt;u8&gt; {
        let result = {
            use std::vector::{empty, push_back};
            let v = empty();
            push_back(&amp;mut v, 0);
            push_back(&amp;mut v, 10);
            v
        };
        result
    }

}
}
</code></pre>
<p>Attempting to use the alias after the block ends will result in an error</p>
<p>在块结束后尝试使用别名将导致错误</p>
<pre><code class="language-move">fun example(): vector&lt;u8&gt; {
    let result = {
        use std::vector::{empty, push_back};
        let v = empty();
        push_back(&amp;mut v, 0);
        push_back(&amp;mut v, 10);
        v
    };
    let v2 = empty(); // 错误!
//           ^^^^^ 未绑定的函数 'empty'
    结果
}
</code></pre>
<p>Any <code>use</code> must be the first item in the block. If the <code>use</code> comes after any expression or <code>let</code>, it
will result in a parsing error</p>
<p>任何使用都必须是块中的第一项。如果 use 出现在任何表达式或 let 之后，则会导致解析错误</p>
<pre><code class="language-move">{
    let x = 0;
    use std::vector; // 错误!
    let v = vector::empty();
}
</code></pre>
<h2 id="命名规则naming-rules"><a class="header" href="#命名规则naming-rules">命名规则（Naming rules）</a></h2>
<p>Aliases must follow the same rules as other module members. This means that aliases to structs or
constants must start with <code>A</code> to <code>Z</code></p>
<p>别名必须遵循与其他模块成员相同的规则。这意味着结构或常量的别名必须以 <code>A</code> 到 <code>Z</code> 开头</p>
<pre><code class="language-move">address 0x42 {
module data {
    struct S {}
    const FLAG: bool = false;
    fun foo() {}
}
module example {
    use 0x42::data::{
        S as s, // 错误!
        FLAG as fLAG, // 错误!
        foo as FOO,  // 有效
        foo as bar, // 有效
    };
}
}
</code></pre>
<h2 id="唯一性uniqueness"><a class="header" href="#唯一性uniqueness">唯一性（Uniqueness）</a></h2>
<p>Inside a given scope, all aliases introduced by <code>use</code> declarations must be unique.</p>
<p>在给定范围内，所有由 use 声明引入的别名必须是唯一的。</p>
<p>For a module, this means aliases introduced by <code>use</code> cannot overlap</p>
<p>对于一个模块，这意味着使用引入的别名不能重复</p>
<pre><code class="language-move">address 0x42 {
module example {

    use std::vector::{empty as foo, length as foo}; // ERROR!
    //                                        ^^^ duplicate 'foo'

    use std::vector::empty as bar;

    use std::vector::length as bar; // 错误!
    //                         ^^^ 重复的 'bar'

}
}
</code></pre>
<p>And, they cannot overlap with any of the module's other members</p>
<p>而且，它们不能与模块的任何其他成员重复</p>
<pre><code class="language-move">address 0x42 {
module data {
    struct S {}
}
module example {
    use 0x42::data::S;

    struct S { value: u64 } // ERROR!
    //     ^ conflicts with alias 'S' above
}
}
</code></pre>
<p>Inside of an expression block, they cannot overlap with each other, but they can
<a href="uses.html#shadowing">shadow</a> other aliases or names from an outer scope</p>
<p>在表达式块内部，它们不能相互重复，但它们可以遮蔽外部作用域中的其他别名或名称</p>
<h2 id="遮蔽shadowing-1"><a class="header" href="#遮蔽shadowing-1">遮蔽（Shadowing）</a></h2>
<p><code>use</code> aliases inside of an expression block can shadow names (module members or aliases) from the
outer scope. As with shadowing of locals, the shadowing ends at the end of the expression block;</p>
<p>在表达式块内使用别名可以覆盖外部作用域的名称（模块成员或别名）。当遮蔽局部变量时，遮蔽会在表达式块的末尾结束；</p>
<pre><code class="language-move">address 0x42 {
module example {

    struct WrappedVector { vec: vector&lt;u64&gt; }

    fun empty(): WrappedVector {
        WrappedVector { vec: std::vector::empty() }
    }

    fun example1(): (WrappedVector, WrappedVector) {
        let vec = {
            use std::vector::{empty, push_back};
            // 'empty' 现在指向 std::vector::empty

            let v = empty();
            push_back(&amp;mut v, 0);
            push_back(&amp;mut v, 1);
            push_back(&amp;mut v, 10);
            v
        };
        // 'empty' 现在指向 Self::empty

        (empty(), WrappedVector { vec })
    }

    fun example2(): (WrappedVector, WrappedVector) {
        use std::vector::{empty, push_back};
        let w: WrappedVector = {
            use 0x42::example::empty;
            empty()
        };
        push_back(&amp;mut w.vec, 0);
        push_back(&amp;mut w.vec, 1);
        push_back(&amp;mut w.vec, 10);

        let vec = empty();
        push_back(&amp;mut vec, 0);
        push_back(&amp;mut vec, 1);
        push_back(&amp;mut vec, 10);

        (w, WrappedVector { vec })
    }
}
}
</code></pre>
<h2 id="未使用的use或别名unused-use-or-alias"><a class="header" href="#未使用的use或别名unused-use-or-alias">未使用的Use或别名（Unused Use or Alias）</a></h2>
<p>An unused <code>use</code> will result in an error</p>
<p>未使用的 <code>use</code> 会导致错误</p>
<pre><code class="language-move">address 0x42 {
module example {
    use std::vector::{empty, push_back}; // ERROR!
    //                       ^^^^^^^^^ 未使用的别名 'push_back'

    fun example(): vector&lt;u8&gt; {
        empty()
    }
}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="友元函数friends"><a class="header" href="#友元函数friends">友元函数（Friends）</a></h1>
<p>The <code>friend</code> syntax is used to declare modules that are trusted by the current module.
A trusted module is allowed to call any function defined in the current module that have the <code>public(friend)</code> visibility.
For details on function visibilities, please refer to the <em>Visibility</em> section in <a href="functions.html">Functions</a>.</p>
<p>友元语法用于声明当前模块信任的其它模块。受信任的模块可以调用当前模块中定义的任何具有<code>公开（友元）</code>可见性的函数。有关函数可见性的详细信息，请参阅<a href="functions.html">函数</a>中的可见性部分。</p>
<h2 id="友元声明friend-declaration"><a class="header" href="#友元声明friend-declaration">友元声明（Friend declaration）</a></h2>
<p>A module can declare other modules as friends via friend declaration statements, in the format of</p>
<p>一个模块可以通过友元声明语句将其他模块声明为友元，格式为：</p>
<ul>
<li>
<p><code>friend &lt;address::name&gt;</code> — friend declaration using fully qualified module name like the example below, or</p>
</li>
<li>
<p><code>friend &lt;address::name&gt;—</code> 使用完全合格的模块名称的友元声明，如下例所示，或</p>
<pre><code>address 0x42 {
module a {
    friend 0x42::b;
}
}
</code></pre>
</li>
<li>
<p><code>friend &lt;module-name-alias&gt;</code> — friend declaration using a module name alias, where the module alias is introduced via the <code>use</code> statement.</p>
</li>
<li>
<p><code>friend &lt;module-name-alias&gt;—</code> 使用模块名称别名的友元声明，其中模块别名是通过use语句引入的。</p>
<pre><code class="language-move">address 0x42 {
module a {
   use 0x42::b;
   friend b;
}
}
</code></pre>
</li>
</ul>
<p>A module may have multiple friend declarations, and the union of all the friend modules forms the friend list.
In the example below, both <code>0x42::B</code> and <code>0x42::C</code> are considered as friends of <code>0x42::A</code>.</p>
<p>一个模块可能有多个友元声明，所有好友模块的并集形成友元列表。在下面的示例中<code>，0x42::B</code>和<code>0x42::C</code>都被视为 的友元函数<code>0x42::A</code>。</p>
<pre><code class="language-move"> address 0x42 {
 module a {
     friend 0x42::b;
     friend 0x42::c;
 }
 }
</code></pre>
<p>Unlike <code>use</code> statements, <code>friend</code> can only be declared in the module scope and not in the expression block scope.
<code>friend</code> declarations may be located anywhere a top-level construct (e.g., <code>use</code>, <code>function</code>, <code>struct</code>, etc.) is allowed.
However, for readability, it is advised to place friend declarations near the beginning of the module definition.</p>
<p>与<code>use</code>语句不同，<code>friend</code>只能在模块作用域内声明，而不能在表达式块的作用域内声明。<code>friend</code>声明可以位于允许顶层构造的任何位置（例如， <code>use</code>， <code>function，struct</code>等）是被允许的。但是，为了可读性，建议将友元声明放在模块定义的开头附近。</p>
<p>Note that the concept of friendship does not apply to Move scripts:</p>
<ul>
<li>A Move script cannot declare <code>friend</code> modules as doing so is considered meaningless: there is no mechanism to call the function defined in a script.</li>
<li>A Move module cannot declare <code>friend</code> scripts as well because scripts are ephemeral code snippets that are never published to global storage.</li>
</ul>
<p>请注意，友元关系（friendship）的概念不适用于 Move 脚本：</p>
<ul>
<li><code>Move</code> 脚本不能声明<code>friend</code>模块，因为这样做被认为是无意义的：没有机制可以调用脚本中定义的函数。</li>
<li><code>Move</code> 模块也不能声明<code>friend</code>脚本，因为脚本是永远不会发布到全局存储的临时代码片段。</li>
</ul>
<h3 id="友元声明规则friend-declaration-rules"><a class="header" href="#友元声明规则friend-declaration-rules">友元声明规则（Friend declaration rules）</a></h3>
<p>Friend declarations are subject to the following rules:
友元声明须遵守以下规则：</p>
<ul>
<li>
<p>A module cannot declare itself as a friend</p>
</li>
<li>
<p>一个模块不能将自己声明为友元。</p>
<pre><code class="language-move=">address 0x42 {
module m { friend Self; // 错误! }
//                ^^^^ 不能将自己声明为友元
}

address 0x43 {
module m { friend 0x43::M; // 错误! }
//                ^^^^^^^ 不能将自己声明为友元
}
</code></pre>
</li>
<li>
<p>Friend modules must be known by the compiler</p>
</li>
<li>
<p>编译器必须知道友元模块</p>
<pre><code class="language-move=">address 0x42 {
module m { friend 0x42::nonexistent; // 错误! }
//                ^^^^^^^^^^^^^^^^^ 未绑定的模块 '0x42::nonexistent'
}
</code></pre>
</li>
<li>
<p>Friend modules must be within the same account address. (Note: this is not a technical requirement but rather a policy decision which <em>may</em> be relaxed later.)</p>
</li>
<li>
<p>友元模块必须在同一个账号地址内。（注：这不是技术要求，而是以后可能放宽的决策。)</p>
<pre><code class="language-move">address 0x42 {
module m {}
}

address 0x43 {
module n { friend 0x42::m; // 错误! }
//                ^^^^^^^ 不能声明当前地址外的模块作为友元
}
</code></pre>
</li>
<li>
<p>友元关系不能创建循环模块依赖关系（Friends relationships cannot create cyclic module dependencies）</p>
</li>
</ul>
<p>Cycles are not allowed in the friend relationships, e.g., the relation <code>0x2::a</code> friends <code>0x2::b</code> friends <code>0x2::c</code> friends <code>0x2::a</code> is not allowed.
More generally, declaring a friend module adds a dependency upon the current module to the friend module (because the purpose is for the friend to call functions in the current module).
If that friend module is already used, either directly or transitively, a cycle of dependencies would be created.</p>
<p>友元关系中不允许循环，例如 <code>0x2::a</code> 友元 <code>0x2::b</code> 友元 <code>0x2::c</code> 友元<code>0x2::a</code>是不允许的。更普遍地，声明一个友元模块会将对当前模块的依赖添加到友元模块（因为目的是让友元调用当前模块中的函数）。如果该友元模块已被直接或传递地使用，则将形成一个依赖循环。</p>
<pre><code class="language-move">address 0x2 {
module a {
   use 0x2::c;
   friend 0x2::b;

   public fun a() {
       c::c()
   }
}

module b {
   friend 0x2::c; // 错误!
//         ^^^^^^ 这个友元关系形成了一个依赖循环:  '0x2::a' 使用了 '0x2::c' 但'0x2::b' 同时是 '0x2::a'和'0x2::b' 的友元
}

module c {
   public fun c() {}
}
}
</code></pre>
<ul>
<li>The friend list for a module cannot contain duplicates.</li>
<li>模块的友元列表不能包含重复项。</li>
</ul>
<pre><code class="language-move=">address 0x42 {
module a {}

module m {
   use 0x42::a as aliased_a;
   friend 0x42::A;
   friend aliased_a; // 错误!
//         ^^^^^^^^^ 重复的友元声明 '0x42::a'. 模块内的友元声明必须是唯一的
}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序包packages"><a class="header" href="#程序包packages">程序包(packages)</a></h1>
<p>Packages allow Move programmers to more easily re-use code and share it
across projects. The Move package system allows programmers to easily:</p>
<ul>
<li>Define a package containing Move code;</li>
<li>Parameterize a package by <a href="address.html">named addresses</a>;</li>
<li>Import and use packages in other Move code and instantiate named addresses;</li>
<li>Build packages and generate associated compilation artifacts from packages; and</li>
<li>Work with a common interface around compiled Move artifacts.</li>
</ul>
<p>包允许 <code>Move</code> 程序员更轻松地重用代码并在项目之间共享。<code>Move</code> 包系统允许程序员轻松地：</p>
<ul>
<li>定义一个包含 <code>Move</code>代码的包；</li>
<li>通过命名地址参数化包；</li>
<li>在其他 <code>Move</code> 代码中导入和使用包并实例化命名地址；</li>
<li>构建包并从包中生成相关的编译源代码；</li>
<li>使用围绕已编译 <code>Move</code> 工件的通用接口。</li>
</ul>
<h2 id="包布局和清单语法package-layout-and-manifest-syntax"><a class="header" href="#包布局和清单语法package-layout-and-manifest-syntax">包布局和清单语法（Package Layout and Manifest Syntax）</a></h2>
<p>A Move package source directory contains a <code>Move.toml</code> package manifest
file along with a set of subdirectories:</p>
<p><code>Move</code> 包源目录包含一个<code>Move.toml</code>包清单文件以及一组子目录：</p>
<pre><code>     a_move_package
        ├── Move.toml      (required)（需要的）
        ├── sources        (required)（需要的）
        ├── examples       (optional, test &amp; dev mode)（可选的，测试 &amp; 开发者模式）
        ├── scripts        (optional)（可选的）
        ├── doc_templates  (optional)（可选的）
        └── tests          (optional, test mode)（可选的，测试模式）
</code></pre>
<p>The directories marked <code>required</code> <em>must</em> be present in order for the directory
to be considered a Move package and to be compiled. Optional directories can
be present, and if so will be included in the compilation process. Depending on
the mode that the package is built with (<code>test</code> or <code>dev</code>), the <code>tests</code> and
<code>examples</code> directories will be included as well.</p>
<p>标记为<code>required</code> 的目录必须存在才可以将该目录作为 <code>Move</code> 包并进行编译。可选目录被视为可存在的，如果存在，将包含在编译过程里。根据使用 （<code>test</code>或<code>dev</code>）构建包的模式，<code>tests</code>和<code>examples</code> 目录也将包含在内。</p>
<p>The <code>sources</code> directory can contain both Move modules and Move scripts (both
transaction scripts and modules containing script functions). The <code>examples</code>
directory can hold additional code to be used only for development and/or
tutorial purposes that will not be included when compiled outside <code>test</code> or
<code>dev</code> mode.</p>
<p><code>sources</code>目录可以包含 <code>Move</code> 模块和 <code>Move</code> 脚本（事务脚本和包含脚本函数的模块）。<code>Example</code>目录可以保留仅用于开发和/或用作教程目的附加代码，当在 <code>test</code> 或者<code>dev</code>模式之外时，这些附加代码编译时不会被包括进来。</p>
<p>A <code>scripts</code> directory is supported so transaction scripts can be separated
from modules if that is desired by the package author. The <code>scripts</code>
directory will always be included for compilation if it is present.
Documentation will be built using any documentation templates present in
the <code>doc_templates</code> directory.</p>
<p><code>scripts</code>目录是被支持的，如果包作者需要，事物脚本可以从模块中分离。如果该<code>scripts</code>目录存在，则编译时将始终包含该目录。
Move将使用存在于<code>doc_templates</code> 目录的任何模板构建文档。</p>
<h3 id="包清单-movetoml"><a class="header" href="#包清单-movetoml">包清单 Move.toml</a></h3>
<p>The Move package manifest is defined within the <code>Move.toml</code> file and has the
following syntax. Optional fields are marked with <code>*</code>, <code>+</code> denotes
one or more elements:</p>
<p>Move 包清单在<code>Move.toml</code>文件中定义，并具有以下语法。可选字段标有<code>*</code>，<code>+</code>表示一个或多个元素：</p>
<pre><code>    [package]
    name = &lt;string&gt;                  # e.g., &quot;MoveStdlib&quot;
    version = &quot;&lt;uint&gt;.&lt;uint&gt;.&lt;uint&gt;&quot; # e.g., &quot;0.1.1&quot;
    license* = &lt;string&gt;              # e.g., &quot;MIT&quot;, &quot;GPL&quot;, &quot;Apache 2.0&quot;
    authors* = [&lt;string&gt;]            # e.g., [&quot;Joe Smith (joesmith@noemail.com)&quot;, &quot;Jane Smith (janesmith@noemail.com)&quot;]

    [addresses]  # (Optional section) Declares named addresses in this package and instantiates named addresses in the package graph
    # One or more lines declaring named addresses in the following format
    &lt;addr_name&gt; = &quot;_&quot; | &quot;&lt;hex_address&gt;&quot; # e.g., std = &quot;_&quot; or my_addr = &quot;0xC0FFEECAFE&quot;

    [dependencies] # (Optional section) Paths to dependencies and instantiations or renamings of named addresses from each dependency
    # One or more lines declaring dependencies in the following format
    &lt;string&gt; = { local = &lt;string&gt;, addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &quot;&lt;hex_address&gt;&quot;))+ } } # local dependencies
    &lt;string&gt; = { git = &lt;URL ending in .git&gt;, subdir=&lt;path to dir containing Move.toml inside git repo&gt;, rev=&lt;git commit hash&gt;, addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &quot;&lt;hex_address&gt;&quot;))+ } } # git dependencies

    [dev-addresses] # (Optional section) Same as [addresses] section, but only included in &quot;dev&quot; and &quot;test&quot; modes
    # One or more lines declaring dev named addresses in the following format
    &lt;addr_name&gt; = &quot;_&quot; | &quot;&lt;hex_address&gt;&quot; # e.g., std = &quot;_&quot; or my_addr = &quot;0xC0FFEECAFE&quot;

    [dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in &quot;dev&quot; and &quot;test&quot; modes
    # One or more lines declaring dev dependencies in the following format
    &lt;string&gt; = { local = &lt;string&gt;, addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &lt;address&gt;))+ } }
</code></pre>
<p>An example of a minimal package manifest with one local dependency and one git dependency:</p>
<p>一个具有局部依赖项和一个 git 依赖项的最小包清单示例：</p>
<pre><code>    [package]
    name = &quot;AName&quot;
    version = &quot;0.0.0&quot;
</code></pre>
<p>An example of a more standard package manifest that also includes the Move
standard library and instantiates the named address <code>Std</code> from it with the
address value <code>0x1</code>:</p>
<p>一个包括 Move 标准库并从中使用地址值<code>0x1</code>实例化命名地址<code>Std</code>的更标准的包清单示例：</p>
<pre><code>    [package]
    name = &quot;AName&quot;
    version = &quot;0.0.0&quot;
    license = &quot;Apache 2.0&quot;

    [addresses]
    address_to_be_filled_in = &quot;_&quot;
    specified_address = &quot;0xB0B&quot;

    [dependencies]
    # Local dependency
    LocalDep = { local = &quot;projects/move-awesomeness&quot;, addr_subst = { &quot;std&quot; = &quot;0x1&quot; } }
    # Git dependency
    MoveStdlib = { git = &quot;https://github.com/diem/diem.git&quot;, subdir=&quot;language/move-stdlib&quot;, rev = &quot;56ab033cc403b489e891424a629e76f643d4fb6b&quot; }

    [dev-addresses] # For use when developing this module
    address_to_be_filled_in = &quot;0x101010101&quot;
</code></pre>
<p>Most of the sections in the package manifest are self explanatory, but named
addresses can be a bit difficult to understand so it's worth examining them in
a bit more detail.</p>
<p>包清单中的大部分段落都是不言自明的，但命名地址可能有点难以理解，因此值得更详细地检查它们。</p>
<h2 id="编译期间的命名地址named-addresses-during-compilation"><a class="header" href="#编译期间的命名地址named-addresses-during-compilation">编译期间的命名地址（Named Addresses During Compilation）</a></h2>
<p>Recall that Move has <a href="address.html">named addresses</a> and that
named addresses cannot be declared in Move. Because of this, until now
named addresses and their values needed to be passed to the compiler on the
command line. With the Move package system this is no longer needed, and
you can declare named addresses in the package, instantiate other named
addresses in scope, and rename named addresses from other packages within
the Move package system manifest file. Let's go through each of these
individually:</p>
<p>回想一下，Move 具有命名地址，并且不能在 Move 中声明命名地址。正因为如此，到目前为止，命名地址及其值都需要在命令行上传递给编译器。但使用 Move 包系统时这将不再需要，您可以在包中声明命名地址，实例化范围内的其他命名地址，并从 Move 包系统清单文件中的其他包重命名命名地址，让我们分别来看看这些:</p>
<h3 id="声明declaration"><a class="header" href="#声明declaration">声明（Declaration）</a></h3>
<p>Let's say we have a Move module in <code>example_pkg/sources/A.move</code> as follows:</p>
<p>假设我们有一个Move模块，<code>example_pkg/sources/A.move</code>如下所示:</p>
<pre><code class="language-move">    module named_addr::A {
        public fun x(): address { @named_addr }
    }
</code></pre>
<p>We could in <code>example_pkg/Move.toml</code> declare the named address <code>named_addr</code> in
two different ways. The first:</p>
<p>我们可以用两种不同<code>example_pkg/Move.toml</code>的方式声明命名地址<code>named_addr</code>。首先：</p>
<pre><code>    [package]
    name = &quot;ExamplePkg&quot;
    ...
    [addresses]
    named_addr = &quot;_&quot;
</code></pre>
<p>Declares <code>named_addr</code> as a named address in the package <code>ExamplePkg</code> and
that <em>this address can be any valid address value</em>. Therefore an importing
package can pick the value of the named address <code>named_addr</code> to be any address
it wishes. Intuitively you can think of this as parameterizing the package
<code>ExamplePkg</code> by the named address <code>named_addr</code>, and the package can then be
instantiated later on by an importing package.</p>
<p>声明<code>named_addr</code>为包<code>ExamplePkg</code>中的命名地址，并且 <em>该地址可以是任何有效的地址值</em>。因此，导入包可以选择命名地址的值作为<code>named_addr</code>它希望的任何地址。直观地，您可以将其视为通过命名地址<code>named_addr</code>参数化包 <code>ExamplePkg</code>，然后稍后通过导入包使包被实例化。</p>
<p><code>named_addr</code> can also be declared as:</p>
<p><code>named_addr</code>也可以声明为：</p>
<pre><code>    [package]
    name = &quot;ExamplePkg&quot;
    ...
    [addresses]
    named_addr = &quot;0xCAFE&quot;
</code></pre>
<p>which states that the named address <code>named_addr</code> is exactly <code>0xCAFE</code> and cannot be
changed. This is useful so other importing packages can use this named
address without needing to worry about the exact value assigned to it.</p>
<p>这表明命名的地址<code>named_addr</code>是准确的<code>0xCAFE</code>并且不能更改。这很有用，因此其他导入包可以使用这个命名地址，而无需担心分配给它的确切值。</p>
<p>With these two different declaration methods, there are two ways that
information about named addresses can flow in the package graph:</p>
<ul>
<li>The former (&quot;unassigned named addresses&quot;) allows named address values to flow
from the importation site to the declaration site.</li>
<li>The latter (&quot;assigned named addresses&quot;) allows named address values to flow
from the declaration site upwards in the package graph to usage sites.</li>
</ul>
<p>使用这两种不同的声明方法，有关命名地址的信息可以通过两种方式在包图中流动：</p>
<ul>
<li>前者（“未分配的命名地址”）允许命名地址值从进口站点流向申报站点。</li>
<li>后者（“分配的命名地址”）允许命名地址值从包图中的声明站点向上流动到使用站点。</li>
</ul>
<p>With these two methods for flowing named address information throughout the
package graph the rules around scoping and renaming become important to
understand.</p>
<p>通过这两种在整个包图中流动命名地址信息的方法，了解范围和重命名的规则变得很重要。</p>
<h2 id="命名地址的作用域和重命名scoping-and-renaming-of-named-addresses"><a class="header" href="#命名地址的作用域和重命名scoping-and-renaming-of-named-addresses">命名地址的作用域和重命名（Scoping and Renaming of Named Addresses）</a></h2>
<p>A named address <code>N</code> in a package <code>P</code> is in scope if:</p>
<ol>
<li>It declares a named address <code>N</code>; or</li>
<li>A package in one of <code>P</code>'s transitive dependencies declares the named address
<code>N</code> and there is a dependency path in the package graph between between <code>P</code> and the
declaring package of <code>N</code> with no renaming of <code>N</code>.</li>
</ol>
<p>在包<code>P</code>中的命名地址<code>N</code>如果满足以下条件，则在作用域内：</p>
<ol>
<li>它声明了一个命名地址<code>N</code>；或者</li>
<li><code>P</code>的传递依赖项之一中的包声明了命名地址<code>N</code>，并且封装图在<code>P</code>和没有重命名的声明包<code>N</code>之间有一个依赖路径。</li>
</ol>
<p>Additionally, every named address in a package is exported. Because of this and
the above scoping rules each package can be viewed as coming with a set of
named addresses that will be brought into scope when the package is imported,
e.g., if the <code>ExamplePkg</code> package was imported, that importation would bring
into scope the <code>named_addr</code> named address. Because of this, if <code>P</code> imports two
packages <code>P1</code> and <code>P2</code> both of which declare a named address <code>N</code> an issue
arises in <code>P</code>: which &quot;<code>N</code>&quot; is meant when <code>N</code> is referred to in <code>P</code>? The one
from <code>P1</code> or <code>P2</code>? To prevent this ambiguity around which package a named
address is coming from, we enforce that the sets of scopes introduced by all
dependencies in a package are disjoint, and provide a way to <em>rename named
addresses</em> when the package that brings them into scope is imported.</p>
<p>此外，包中的每个命名地址都会被导出。由于这个和上面的范围规则，每个包都可以被视为带有一组命名地址，当包被导入时，这些地址将被带入作用域，例如，如果包<code>ExamplePkg</code>被导入，则该导入会将命名地址<code>named_addr</code>带入作用域。 因此，如果<code>P</code>导入两个包<code>P1</code>并且<code>P2</code>都声明了一个命名地址<code>N</code>，在<code>P</code>中则会出现以下问题：当<code>N</code>被引用于<code>P</code>时我们指的是哪个<code>N</code>？来自<code>P1</code>或来自<code>P2</code>的<code>N</code>？ 为了防止命名地址来自哪个包的这种歧义，我们强制一个包中所有依赖项引入的范围集是不相交的，并提供一种在将命名地址带入范围的包被导入时重命名命名地址的方法。</p>
<p>Renaming a named address when importing can be done as follows in our <code>P</code>,
<code>P1</code>, and <code>P2</code> example above:</p>
<p>导入时重命名一个命名地址可以在我们的<code>P</code>,<code>P1</code>和<code>P2</code>上面的示例中完成：</p>
<pre><code>    [package]
    name = &quot;P&quot;
    ...
    [dependencies]
    P1 = { local = &quot;some_path_to_P1&quot;, addr_subst = { &quot;P1N&quot; = &quot;N&quot; } }
    P2 = { local = &quot;some_path_to_P2&quot;  }
</code></pre>
<p>With this renaming <code>N</code> refers to the <code>N</code> from <code>P2</code> and <code>P1N</code> will refer to <code>N</code>
coming from <code>P1</code>:</p>
<p>这种重命名<code>N</code>指的是<code>P2</code>中的<code>N</code>并且<code>P1N</code>将指 <code>P1</code>中的<code>N</code>：</p>
<pre><code>    module N::A {
        public fun x(): address { @P1N }
    }
</code></pre>
<p>It is important to note that <em>renaming is not local</em>: once a named address <code>N</code>
has been renamed to <code>N2</code> in a package <code>P</code> all packages that import <code>P</code> will not
see <code>N</code> but only <code>N2</code> unless <code>N</code> is reintroduced from outside of <code>P</code>. This is
why rule (2) in the scoping rules at the start of this section specifies a
&quot;dependency path in the package graph between between <code>P</code> and the declaring
package of <code>N</code> with no renaming of <code>N</code>.&quot;</p>
<p>重要的是要注意 <em>重命名不是局部的</em>：一旦一个命名地址<code>N</code>在一个包<code>P</code>中被重命名为<code>N2</code>，所有导入<code>P</code>的包都不会看到<code>N</code>但只会看到<code>N2</code>，除非<code>N</code>是从<code>P</code>外引入的。这就是为什么本节开头的范围规则中的规则 (2) 特别说明了“在<code>P</code>和没有重命名的声明包<code>N</code> 的封装图中的依赖路径” 。</p>
<h3 id="实例化instantiation"><a class="header" href="#实例化instantiation">实例化（Instantiation）</a></h3>
<p>Named addresses can be instantiated multiple times across the package graph as
long as it is always with the same value. It is an error if the same named
address (regardless of renaming) is instantiated with differing values across
the package graph.</p>
<p>只要命名地址始终具有相同的值，就可以在封装图中多次实例化命名地址。如果在整个封装图中使用不同的值实例化相同的命名地址（无论是否重命名），则会出现错误。</p>
<p>A Move package can only be compiled if all named addresses resolve to a value.
This presents issues if the package wishes to expose an uninstantiated named
address. This is what the <code>[dev-addresses]</code> section solves. This section can
set values for named addresses, but cannot introduce any named addresses.
Additionally, only the <code>[dev-addresses]</code> in the root package are included in
<code>dev</code> mode. For example a root package with the following manifest would not compile
outside of <code>dev</code> mode since <code>named_addr</code> would be uninstantiated:</p>
<p>只有当所有命名地址都解析为一个值时，才能编译 Move 包。如果包希望公开未实例化的命名地址，则会出现问题。这就是<code>[dev-addresses]</code>段要解决的问题。此段可以设置命名地址的值，但不能引入任何命名地址。此外， <code>dev</code>模式下仅根包中的<code>[dev-addresses]</code>会被包括进来。例如，具有以下清单的根包将不会在<code>dev</code>模式之外编译，因为<code>named_addr</code>不会被实例化：</p>
<pre><code>[package]
name = &quot;ExamplePkg&quot;
...
[addresses]
named_addr = &quot;_&quot;

[dev-addresses]
named_addr = &quot;0xC0FFEE&quot;
</code></pre>
<h2 id="用法源代码和数据结构-usage-artifacts-and-data-structures"><a class="header" href="#用法源代码和数据结构-usage-artifacts-and-data-structures">用法、源代码和数据结构（ Usage, Artifacts, and Data Structures）</a></h2>
<p>The Move package system comes with a command line option as part of the Move
CLI <code>move &lt;flags&gt; &lt;command&gt; &lt;command_flags&gt;</code>. Unless a
particular path is provided, all package commands will run in the current working
directory. The full list of commands and flags for the Move CLI can be found by
running <code>move --help</code>.</p>
<p>Move 软件包系统带有一个命令行选项，作为 Move CLI 的一部分move <code>&lt;flags&gt; &lt;command&gt;</code> <code>&lt;command_flags&gt;</code>。除非提供特定路径，否则所有包命令都将在当前工作目录中运行。可以通过运行<code>move --help</code>找到 Move CLI 的命令和标志的完整列表。</p>
<h3 id="用法usage"><a class="header" href="#用法usage">用法（Usage）</a></h3>
<p>A package can be compiled either through the Move CLI commands, or as a library
command in Rust with the function <code>compile_package</code>. This will create a
<code>CompiledPackage</code> that holds the compiled bytecode along with other compilation
artifacts (source maps, documentation, ABIs) in memory. This <code>CompiledPackage</code>
can be converted to an <code>OnDiskPackage</code> and vice versa -- the latter being the data of
the <code>CompiledPackage</code> laid out in the file system in the following format:</p>
<p>一个包可以通过 Move CLI 命令，或是当作Rust函数<code>compile_package</code>的库命令来编译。 这种编译方法将创建一个编译包<code>CompiledPackage</code> 保存已编译的字节码以及其他编译内存中的源代码（源映射、文档、ABIs）。这个<code>CompiledPackage</code>可以转换为<code>OnDiskPackage</code>，反之亦然——后者是文件系统中的编译包 <code>CompiledPackage</code>数据，它的格式如下：</p>
<pre><code>a_move_package
├── Move.toml
...
└── build
    ├── &lt;dep_pkg_name&gt;
    │   ├── BuildInfo.yaml
    │   ├── bytecode_modules
    │   │   └── *.mv
    │   ├── source_maps
    │   │   └── *.mvsm
    │   ├── bytecode_scripts
    │   │   └── *.mv
    │   ├── abis
    │   │   ├── *.abi
    │   │   └── &lt;module_name&gt;/*.abi
    │   └── sources
    │       └── *.move
    ...
    └── &lt;dep_pkg_name&gt;
        ├── BuildInfo.yaml
        ...
        └── sources
</code></pre>
<p>See the <code>move-package</code> crate for more information on these data structures and
how to use the Move package system as a Rust library.</p>
<p>有关这些数据结构和如何将 Move 包系统用作 Rust 库的更多信息，请参阅 <code>move-package</code> 箱（crate） 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="单元测试-unit-tests"><a class="header" href="#单元测试-unit-tests">单元测试 (Unit Tests)</a></h1>
<p>Unit testing for Move adds three new annotations to the Move source language:</p>
<p>Move 语言中存在三种单元测试标注：</p>
<ul>
<li><code>#[test]</code></li>
<li><code>#[test_only]</code>, and</li>
<li><code>#[expected_failure]</code>.</li>
</ul>
<p>They respectively mark a function as a test, mark a module or module member (<code>use</code>, function, or struct) as code to be included for testing only, and mark that a test is expected to fail. These annotations can be placed on a function with any visibility. Whenever a module or module member is annotated as <code>#[test_only]</code> or <code>#[test]</code>, it will not be included in the compiled bytecode unless it is compiled for testing.</p>
<p>它们分别把函数、模块或模块成员（<code>use</code> 声明，函数 function，或结构体 struct）标记为只用于测试的代码，同时也标记期望失败的测试。这些标注可以用在任何可见性（visibility）函数上。无论何种情况，被标注为 <code>#[test_only]</code> 或 <code>#[test]</code> 的模块或模块成员除非用于测试，其它情况都不会被编译成字节码。</p>
<h2 id="测试注解含义和使用方法testing-annotations-their-meaning-and-usage"><a class="header" href="#测试注解含义和使用方法testing-annotations-their-meaning-and-usage">测试注解：含义和使用方法（Testing Annotations: Their Meaning and Usage）</a></h2>
<p>Both the <code>#[test]</code> and <code>#[expected_failure]</code> annotations can be used either with or without arguments.</p>
<p><code>#[test]</code> 和 <code>#[expected_failure]</code> 两个注解均可以在有、无参数情况下使用。</p>
<p>Without arguments, the <code>#[test]</code> annotation can only be placed on a function with no parameters. This annotation simply marks this function as a test to be run by the unit testing harness.</p>
<p>没有参数的 <code>#[test]</code> 标记只能用于没有参数的函数。表示该函数作为单元测试函数被运行。</p>
<pre><code>#[test] // 正确 // OK
fun this_is_a_test() { ... }

#[test] // 编译失败，因为函数需要参数 // Will fail to compile since the test takes an argument
fun this_is_not_correct(arg: signer) { ... }
</code></pre>
<p>A test can also be annotated as an <code>#[expected_failure]</code>. This annotation marks that the test should is expected to raise an error. You can ensure that a test is aborting with a specific abort code by annotating it with <code>#[expected_failure(abort_code = &lt;code&gt;)]</code>, if it then fails with a different abort code or with a non-abort error the test will fail. Only functions that have the <code>#[test]</code> annotation can also be annotated as an #<code>[expected_failure]</code>.</p>
<p>测试也可以使用 <code>#[expected_failure]</code> 标注，表示该函数会抛出错误。你可以使用 <code>#[expected_failure(abort_code = &lt;code&gt;)]</code> 这种方式方式确保此测试会被指定错误码打断，如果抛出不同错误码或没有抛出错误测试将失败。只有被 <code>#[test]</code> 标注的函数才能使用 <code>#[expected_failure]</code> 标注。</p>
<pre><code>#[test]
#[expected_failure]
public fun this_test_will_abort_and_pass() { abort 1 }

#[test]
#[expected_failure]
public fun test_will_error_and_pass() { 1/0; }

#[test]
#[expected_failure(abort_code = 0)]
public fun test_will_error_and_fail() { 1/0; }

#[test, expected_failure] // 可以合并多个属性。测试将会通过。 // Can have multiple in one attribute. This test will pass.
public fun this_other_test_will_abort_and_pass() { abort 1 }
</code></pre>
<p>With arguments, a test annotation takes the form <code>#[test(&lt;param_name_1&gt; = &lt;address&gt;, ..., &lt;param_name_n&gt; = &lt;address&gt;)]</code>. If a function is annotated in such a manner, the function's parameters must be a permutation of the parameters &lt;<code>param_name_1&gt;, ..., &lt;param_name_n&gt;</code>, i.e., the order of these parameters as they occur in the function and their order in the test annotation do not have to be the same, but they must be able to be matched up with each other by name.</p>
<p>测试标注可以采用 <code>#[test(&lt;param_name_1&gt; = &lt;address&gt;, ..., &lt;param_name_n&gt; = &lt;address&gt;)]</code> 这种形式指定参数。如果函数使用这样的标注，函数的参数则必须为 <code>&lt;param_name_1&gt;, ..., &lt;param_name_n&gt;</code> 的形式。参数在函数中的顺序不必与注解中顺序一致，但必须要能根据参数名匹配。</p>
<p>Only parameters with a type of <code>signer</code> are supported as test parameters. If a non-<code>signer</code> parameter is supplied, the test will result in an error when run.</p>
<p>只有 <code>signer</code> 类型可以用作测试参数。使用非 <code>signer</code> 类型参数，测试将会失败。</p>
<pre><code>#[test(arg = @0xC0FFEE)] // 正确 // OK
fun this_is_correct_now(arg: signer) { ... }

#[test(wrong_arg_name = @0xC0FFEE)] // 不正确: 参数名不匹配 // Not correct: arg name doesn't match
fun this_is_incorrect(arg: signer) { ... }

#[test(a = @0xC0FFEE, b = @0xCAFE)] // 正确，多参数情况下必须为每个参数提供值。 // OK. We support multiple signer arguments, but you must always provide a value for that argument
fun this_works(a: signer, b: signer) { ... }

// 在某处声明一个命名地址（named address） // somewhere a named address is declared
#[test_only] // 命名地址支持 test-only 注解 // test-only named addresses are supported
address TEST_NAMED_ADDR = @0x1;
...
#[test(arg = @TEST_NAMED_ADDR)] // 支持命名地址！ // Named addresses are supported!
fun this_is_correct_now(arg: signer) { ... }
</code></pre>
<p>An expected failure annotation can also take the form <code>#[expected_failure(abort_code = &lt;u64&gt;)]</code>. If a test function is annotated in such a way, the test must abort with an abort code equal to <code>&lt;u64&gt;</code>. Any other failure or abort code will result in a test failure.</p>
<p>预期失败的标注使用 <code>#[expected_failure(abort_code = &lt;u64&gt;)]</code> 这种形式。如果函数被这样标注，测试错误码必须为 <code>&lt;u64&gt;</code>。任何其它的错误或错误码都会失败。</p>
<pre><code>#[test, expected_failure(abort_code = 1)] // 这个测试会失败 // This test will fail
fun this_test_should_abort_and_fail() { abort 0 }

#[test]
#[expected_failure(abort_code = 0)] // 这个测试会通过 // This test will pass
fun this_test_should_abort_and_pass_too() { abort 0 }
</code></pre>
<p>A module and any of its members can be declared as test only. In such a case the item will only be included in the compiled Move bytecode when compiled in test mode. Additionally, when compiled outside of test mode, any non-test <code>use</code>s of a <code>#[test_only]</code> module will raise an error during compilation.</p>
<p>模块和它的成员可以被声明为仅测试用。这种情况它们只会在测试模式下编译。此外，在非测试模式下，任何被 <code>#[test_only]</code> 标记的模块都会在编译时报错。</p>
<pre><code>#[test_only] // test only 属性可以用于模块  // test only attributes can be attached to modules
module abc { ... }

#[test_only] // test only 属性可以用于命名地址 // test only attributes can be attached to named addresses
address ADDR = @0x1;

#[test_only] // .. 用于 use 声明 // .. to uses
use 0x1::some_other_module;

#[test_only] // .. 用于结构体 // .. to structs
struct SomeStruct { ... }

#[test_only] // .. 用于函数。只能在测试函数中调用，但自身不是测试 // .. and functions. Can only be called from test code, but not a test
fun test_only_function(...) { ... }
</code></pre>
<h2 id="运行单元测试running-unit-tests"><a class="header" href="#运行单元测试running-unit-tests">运行单元测试（Running Unit Tests）</a></h2>
<p>Unit tests for a Move package can be run with the <a href="packages.html"><code>move test</code>
command</a>.</p>
<p>使用 <a href="packages.html"><code>move test</code> 命令</a>运行包中的单元测试。</p>
<p>When running tests, every test will either <code>PASS</code>, <code>FAIL</code>, or <code>TIMEOUT</code>. If a test case fails, the location of the failure along with the function name that caused the failure will be reported if possible. You can see an example of this below.</p>
<p>运行测试的结果包括 <code>PASS</code>、<code>FAIL</code> 或 <code>TIMEOUT</code>。如果测试失败，将会尽可能的提供执行失败的位置及函数名信息。请看下面的例子。</p>
<p>A test will be marked as timing out if it exceeds the maximum number of instructions that can be executed for any single test. This bound can be changed using the options below, and its default value is set to 5000 instructions. Additionally, while the result of a test is always deterministic, tests are run in parallel by default, so the ordering of test results in a test run is non-deterministic unless running with only one thread (see <code>OPTIONS</code> below).</p>
<p>任何测试执行超过最大数量指令限制将会标记成超时。可以通过参数调整此限制，默认值为 5000 条指令。此外，虽然测试结果是确定的，但由于测试默认并行执行，所以测试结果的顺序是不确定的，除非使用单线程模式（见下述参数）。</p>
<p>There are also a number of options that can be passed to the unit testing binary to fine-tune testing and to help debug failing tests. These can be found using the the help flag:</p>
<p>存在大量参数细粒度调整测试工具的行为，帮助调试失败的测试。可以通过 help 参数查看。</p>
<pre><code>$ move -h
</code></pre>
<h2 id="示例example"><a class="header" href="#示例example">示例（Example）</a></h2>
<p>A simple module using some of the unit testing features is shown in the following example:</p>
<p>下面例子展示了一个简单的使用了单元测试特性的模块：</p>
<p>First create an empty package and change directory into it:</p>
<p>首先创建一个空 package 进入目录：</p>
<pre><code>$ move new TestExample; cd TestExample
</code></pre>
<p>Next add the following to the <code>Move.toml</code>:</p>
<p>接下来添加下面内容到 <code>Move.toml</code> 文件：</p>
<pre><code>[dependencies]
MoveStdlib = { git = &quot;https://github.com/diem/diem.git&quot;, subdir=&quot;language/move-stdlib&quot;, rev = &quot;56ab033cc403b489e891424a629e76f643d4fb6b&quot;, addr_subst = { &quot;std&quot; = &quot;0x1&quot; } }
</code></pre>
<p>Next add the following module under the <code>sources</code> directory:</p>
<p>接下来在 <code>sources</code> 目录下添加下述模块：</p>
<pre><code>// 文件路径: sources/my_module.move // filename: sources/my_module.move
module 0x1::my_module {

    struct MyCoin has key { value: u64 }

    public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {
        assert!(coin.value &gt; 0, 0);
        coin
    }

    public fun has_coin(addr: address): bool {
        exists&lt;MyCoin&gt;(addr)
    }

    #[test]
    fun make_sure_non_zero_coin_passes() {
        let coin = MyCoin { value: 1 };
        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);
    }

    #[test]
    // 如果不关心错误码也可以使用 #[expected_failure] // Or #[expected_failure] if we don't care about the abort code
    #[expected_failure(abort_code = 0)]
    fun make_sure_zero_coin_fails() {
        let coin = MyCoin { value: 0 };
        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);
    }

    #[test_only] // 仅用作测试的帮助方法 // test only helper function
    fun publish_coin(account: &amp;signer) {
        move_to(account, MyCoin { value: 1 })
    }

    #[test(a = @0x1, b = @0x2)]
    fun test_has_coin(a: signer, b: signer) {
        publish_coin(&amp;a);
        publish_coin(&amp;b);
        assert!(has_coin(@0x1), 0);
        assert!(has_coin(@0x2), 1);
        assert!(!has_coin(@0x3), 1);
    }
}
</code></pre>
<h3 id="运行测试running-tests"><a class="header" href="#运行测试running-tests">运行测试（Running Tests）</a></h3>
<p>You can then run these tests with the <code>move test</code> command:</p>
<p>你可以使用 <code>move test</code> 命令运行测试。</p>
<pre><code>$ move test
BUILDING MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x1::my_module::test_has_coin
Test result: OK. Total tests: 3; passed: 3; failed: 0
</code></pre>
<h3 id="使用测试参数using-test-flags"><a class="header" href="#使用测试参数using-test-flags">使用测试参数（Using Test Flags）</a></h3>
<h4 id="-f-str-或---filter-str-f-str-or---filter-str"><a class="header" href="#-f-str-或---filter-str-f-str-or---filter-str"><code>-f &lt;str&gt;</code> 或 <code>--filter &lt;str&gt;</code>（<code>-f &lt;str&gt;</code> or <code>--filter &lt;str&gt;</code>）</a></h4>
<p>This will only run tests whose fully qualified name contains <code>&lt;str&gt;</code>. For example if we wanted to only run tests with <code>&quot;zero_coin&quot;</code> in their name:</p>
<p>仅运行名字包含 <code>&lt;str&gt;</code> 字符的测试。例如只想运行名字包含 <code>&quot;zero_coin&quot;</code> 的测试：</p>
<pre><code>$ move test -f zero_coin
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
Test result: OK. Total tests: 2; passed: 2; failed: 0
</code></pre>
<h4 id="-i-bound-或---instructions-bound-i-bound-or---instructions-bound"><a class="header" href="#-i-bound-或---instructions-bound-i-bound-or---instructions-bound"><code>-i &lt;bound&gt;</code> 或 <code>--instructions &lt;bound&gt;</code>（<code>-i &lt;bound&gt;</code> or <code>--instructions &lt;bound&gt;</code>）</a></h4>
<p>This bounds the number of instructions that can be executed for any one test to <code>&lt;bound&gt;</code>:</p>
<p>调整测试指令限制为 <code>&lt;bound&gt;</code>：</p>
<pre><code>$ move test -i 0
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ TIMEOUT ] 0x1::my_module::make_sure_non_zero_coin_passes
[ TIMEOUT ] 0x1::my_module::make_sure_zero_coin_fails
[ TIMEOUT ] 0x1::my_module::test_has_coin

Test failures:

Failures in 0x1::my_module:

┌── make_sure_non_zero_coin_passes ──────
│ Test timed out
└──────────────────


┌── make_sure_zero_coin_fails ──────
│ Test timed out
└──────────────────


┌── test_has_coin ──────
│ Test timed out
└──────────────────

Test result: FAILED. Total tests: 3; passed: 0; failed: 3
</code></pre>
<h4 id="-s-或---statistics-s-or---statistics"><a class="header" href="#-s-或---statistics-s-or---statistics"><code>-s</code> 或 <code>--statistics</code>（<code>-s</code> or <code>--statistics</code>）</a></h4>
<p>With these flags you can gather statistics about the tests run and report the runtime and instructions executed for each test. For example, if we wanted to see the statistics for the tests in the example above:</p>
<p>使用此参数你可以得到每个测试的运行报告及执行指令的统计信息。例如查看上述示例的统计数据：</p>
<pre><code>$ move test -s
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x1::my_module::test_has_coin

Test Statistics:

┌────────────────────────────────────────────────┬────────────┬───────────────────────────┐
│                   Test Name                    │    Time    │   Instructions Executed   │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x1::my_module::make_sure_non_zero_coin_passes │   0.009    │             1             │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x1::my_module::make_sure_zero_coin_fails      │   0.008    │             1             │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x1::my_module::test_has_coin                  │   0.008    │             1             │
└────────────────────────────────────────────────┴────────────┴───────────────────────────┘

Test result: OK. Total tests: 3; passed: 3; failed: 0
</code></pre>
<h4 id="-g-或---state-on-error-g-or---state-on-error"><a class="header" href="#-g-或---state-on-error-g-or---state-on-error"><code>-g</code> 或 <code>--state-on-error</code>（<code>-g</code> or <code>--state-on-error</code>）</a></h4>
<p>These flags will print the global state for any test failures. e.g., if we added the following (failing) test to the <code>my_module</code> example:</p>
<p>这个参数会在测试失败情况下打印全局状态。如在 <code>my_module</code> 模块中添加下述失败测试：</p>
<pre><code>module 0x1::my_module {
    ...
    #[test(a = @0x1)]
    fun test_has_coin_bad(a: signer) {
        publish_coin(&amp;a);
        assert!(has_coin(@0x1), 0);
        assert!(has_coin(@0x2), 1);
    }
}
</code></pre>
<p>we would get get the following output when running the tests:</p>
<p>当运行测试时我们将得到下面的输出：</p>
<pre><code>$ move test -g
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x1::my_module::test_has_coin
[ FAIL    ] 0x1::my_module::test_has_coin_bad

Test failures:

Failures in 0x1::my_module:

┌── test_has_coin_bad ──────
│ error[E11001]: test failure
│    ┌─ /home/tzakian/TestExample/sources/my_module.move:47:10
│    │
│ 44 │      fun test_has_coin_bad(a: signer) {
│    │          ----------------- In this function in 0x1::my_module
│    ·
│ 47 │          assert!(has_coin(@0x2), 1);
│    │          ^^^^^^^^^^^^^^^^^^^^^^^^^^ Test was not expected to abort but it aborted with 1 here
│
│
│ ────── Storage state at point of failure ──────
│ 0x1:
│       =&gt; key 0x1::my_module::MyCoin {
│           value: 1
│       }
│
└──────────────────

Test result: FAILED. Total tests: 4; passed: 3; failed: 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局存储--结构"><a class="header" href="#全局存储--结构">全局存储 —— 结构</a></h1>
<p>Move 程序的目的是<a href="global-storage-operators.html">读取和写入</a>树形的持久全局存储。程序不能访问文件系统、网络或任何此树以外的数据。</p>
<p>在伪代码中，全局存储看起来像：</p>
<pre><code class="language-move">struct GlobalStorage {
  resources: Map&lt;(address, ResourceType), ResourceValue&gt;
  modules: Map&lt;(address, ModuleName), ModuleBytecode&gt;
}
</code></pre>
<p>从结构上讲，全局存储是一个<a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)">森林（forest）</a>，这个森林由以账户<a href="address.html">地址（<code>address</code>）</a>为根的树组成。每个地址可以存储<a href="structs-and-resources.html">资源（resource）</a>数据和<a href="modules-and-scripts.html">模块（module）</a>代码。如上面的伪代码所示，每个地址（<code>address</code>）最多可以存储一个给定类型的资源值，最多可以存储一个给定名称的模块。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局存储---操作global-storage---operators"><a class="header" href="#全局存储---操作global-storage---operators">全局存储 - 操作（Global Storage - Operators）</a></h1>
<p>Move programs can create, delete, and update <a href="structs-and-resources.html">resources</a> in global storage using the following five instructions:</p>
<p>Move程序可以使用下面五种指令创建、删除、更新全局存储中的<a href="structs-and-resources.html">资源</a>：</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Description</th><th>Aborts?</th></tr></thead><tbody>
<tr><td><code>move_to&lt;T&gt;(&amp;signer,T)</code></td><td>Publish <code>T</code> under <code>signer.address</code></td><td>If <code>signer.address</code> already holds a <code>T</code></td></tr>
<tr><td><code>move_from&lt;T&gt;(address): T</code></td><td>Remove <code>T</code> from <code>address</code> and return it</td><td>If <code>address</code> does not hold a <code>T</code></td></tr>
<tr><td><code>borrow_global_mut&lt;T&gt;(address): &amp;mut T</code></td><td>Return a mutable reference to the <code>T</code> stored under <code>address</code></td><td>If <code>address</code> does not hold a <code>T</code></td></tr>
<tr><td><code>borrow_global&lt;T&gt;(address): &amp;T</code></td><td>Return an immutable reference to the <code>T</code> stored under <code>address</code></td><td>If <code>address</code> does not hold a <code>T</code></td></tr>
<tr><td><code>exists&lt;T&gt;(address): bool</code></td><td>Return <code>true</code> if a <code>T</code> is stored under <code>address</code></td><td>Never</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>出错</th></tr></thead><tbody>
<tr><td><code>move_to&lt;T&gt;(&amp;signer,T)</code></td><td>在 <code>signer.address</code> 下发布 <code>T</code></td><td>如果 <code>signer.address</code> 已经存在 <code>T</code></td></tr>
<tr><td><code>move_from&lt;T&gt;(address): T</code></td><td>从 <code>address</code> 下删除 <code>T</code> 并返回</td><td>如果 <code>address</code> 下没有 <code>T</code></td></tr>
<tr><td><code>borrow_global_mut&lt;T&gt;(address): &amp;mut T</code></td><td>返回 <code>address</code> 下 <code>T</code> 的可变引用 mutable reference</td><td>如果 <code>address</code> 下没有 <code>T</code></td></tr>
<tr><td><code>borrow_global&lt;T&gt;(address): &amp;T</code></td><td>返回 <code>address</code> 下 <code>T</code> 的不可变引用 immutable reference</td><td>如果 <code>address</code> 下没有 <code>T</code></td></tr>
<tr><td><code>exists&lt;T&gt;(address): bool</code></td><td>返回 <code>address</code> 下的 <code>T</code></td><td>永远不会</td></tr>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>Each of these instructions is parameterized by a type <code>T</code> with the <a href="abilities.html"><code>key</code> ability</a>. However, each type <code>T</code> <em>must be declared in the current module</em>. This ensures that a resource can only be manipulated via the API exposed by its defining module. The instructions also take either an <a href="address.html"><code>address</code></a> or <a href="signer.html"><code>&amp;signer</code></a> representing the account address where the resource of type <code>T</code> is stored.</p>
<p>每个指令的参数 <code>T</code> 都具有 <a href="abilities.html"><code>key</code> 能力</a>。然而，类型 <code>T</code> <em>必须在当前模块</em>中声明。这确保资源只能通过当前模块暴露的 API 来操作。指令在存储 <code>T</code> 类型资源的同时，使用 <a href="address.html"><code>address</code></a> 或 <a href="signer.html"><code>&amp;signer</code></a> 表示账户地址。</p>
<h2 id="资源参考references-to-resources"><a class="header" href="#资源参考references-to-resources">资源参考（References to resources）</a></h2>
<p>References to global resources returned by <code>borrow_global</code> or <code>borrow_global_mut</code> mostly behave like references to local storage: they can be extended, read, and written using ordinary <a href="references.html">reference operators</a> and passed as arguments to other function. However, there is one important difference between local and global references: <strong>a function cannot return a reference that points into global storage</strong>. For example, these two functions will each fail to compile:</p>
<p><code>borrow_global</code> 或 <code>borrow_global_mut</code> 指令返回的全局资源引用在大多数情况下类似本地存储的引用：它们可以通过<a href="references.html">引用操作</a>进行拓展、读和写，也可以作为其它函数的参数。然而本地引用和全局引用有个重要差异：<strong>函数不能返回指向全局存储的引用</strong>。例如，下面两个函数编译会失败：</p>
<pre><code class="language-move">struct R has key { f: u64 }
// 不能编译 // will not compile
fun ret_direct_resource_ref_bad(a: address): &amp;R {
    borrow_global&lt;R&gt;(a) // error!
}
// 也不能编译 // also will not compile
fun ret_resource_field_ref_bad(a: address): &amp;u64 {
    &amp;borrow_global&lt;R&gt;(a).f // error!
}
</code></pre>
<p>Move must enforce this restriction to guarantee absence of dangling references to global storage. <a href="global-storage-operators.html#reference-safety-for-global-resources">This</a> section contains much more detail for the interested reader.</p>
<p>Move必须强制这种限制来保证全局存储引用不会出现空引用。对于感兴趣的读者，<a href="global-storage-operators.html#%E5%85%A8%E5%B1%80%E8%B5%84%E6%BA%90%E5%BC%95%E7%94%A8%E5%AE%89%E5%85%A8">此节</a>包含了更多的细节。</p>
<h2 id="使用泛型的全局存储操作global-storage-operators-with-generics"><a class="header" href="#使用泛型的全局存储操作global-storage-operators-with-generics">使用泛型的全局存储操作（Global storage operators with generics）</a></h2>
<p>Global storage operations can be applied to generic resources with both instantiated and uninstantiated generic type parameters:</p>
<p>全局存储操作可以与实例化和未实例化的泛型资源参数使用：</p>
<pre><code class="language-move">struct Container&lt;T&gt; has key { t: T }

/// 发布用于存储调用者提供 T 类型对象的 Container /// Publish a Container storing a type T of the caller's choosing
fun publish_generic_container&lt;T&gt;(account: &amp;signer, t: T) {
    move_to&lt;Container&lt;T&gt;&gt;(account, Container { t })
}

/// 发布存储 u64 类型的 Container /// Publish a container storing a u64
fun publish_instantiated_generic_container(account: &amp;signer, t: u64) {
    move_to&lt;Container&lt;u64&gt;&gt;(account, Container { t })
}
</code></pre>
<p>The ability to index into global storage via a type parameter chosen at runtime is a powerful Move feature known as <em>storage polymorphism</em>. For more on the design patterns enabled by this feature, see <a href="generics.html">Move generics</a>.</p>
<p>能够通过参数类型在运行时中索引全局存储的能力是 Move 的强大特性，该特性称之为<em>存储多态性</em>。关于此特性更多的设计模式，请参考<a href="generics.html">Move泛型</a>这节。</p>
<h2 id="示例-counter-example-counter"><a class="header" href="#示例-counter-example-counter">示例： <code>Counter</code> （Example: <code>Counter</code>）</a></h2>
<p>The simple <code>Counter</code> module below exercises each of the five global storage operators. The API exposed by this module allows:</p>
<ul>
<li>Anyone to publish a <code>Counter</code> resource under their account</li>
<li>Anyone to check if a <code>Counter</code> exists under any address</li>
<li>Anyone to read or increment the value of a <code>Counter</code> resource under any address</li>
<li>An account that stores a <code>Counter</code> resource to reset it to zero</li>
<li>An account that stores a <code>Counter</code> resource to remove and delete it</li>
</ul>
<p>下面简单的 <code>Counter</code> 模块使用五种全局存储操作。该模块暴露的API允许：</p>
<ul>
<li>任何人可以在他们的账户下发布 <code>Counter</code> 资源。</li>
<li>任何人可以检查任何地址下是否包含 <code>Counter</code>。</li>
<li>任何人可以读或增加任何地址下的 <code>Counter</code> 值。</li>
<li>存储 <code>Counter</code> 资源的账号可以将其重置为 0。</li>
<li>存储 <code>Counter</code> 资源的账号可以删除该对象。</li>
</ul>
<pre><code class="language-move">address 0x42 {
module counter {
    use std::signer;

    /// 包含整数的资源 /// Resource that wraps an integer counter
    struct Counter has key { i: u64 }

    /// 给定账户下发布带有 `i` 值的 `Counter` 资源 /// Publish a `Counter` resource with value `i` under the given `account`
    public fun publish(account: &amp;signer, i: u64) {
      // “打包&quot;（创建）Counter 资源。这是需要授权的操作，只能在声明 `Counter` 资源的此模块内执行。 // &quot;Pack&quot; (create) a Counter resource. This is a privileged operation that can only be done inside the module that declares the `Counter` resource
      move_to(account, Counter { i })
    }

    /// 读取 `addr` 地址下 `Counter` 内的值 /// Read the value in the `Counter` resource stored at `addr`
    public fun get_count(addr: address): u64 acquires Counter {
        borrow_global&lt;Counter&gt;(addr).i
    }

    /// 增加 `addr` 地址下 `Counter` 内的值 /// Increment the value of `addr`'s `Counter` resource
    public fun increment(addr: address) acquires Counter {
        let c_ref = &amp;mut borrow_global_mut&lt;Counter&gt;(addr).i;
        *c_ref = *c_ref + 1
    }

    /// 将 `account` 的 `Counter` 重置为 0 /// Reset the value of `account`'s `Counter` to 0
    public fun reset(account: &amp;signer) acquires Counter {
        let c_ref = &amp;mut borrow_global_mut&lt;Counter&gt;(signer::address_of(account)).i;
        *c_ref = 0
    }

    /// 删除 `account` 的 `Counter` 资源并返回其内值 /// Delete the `Counter` resource under `account` and return its value
    public fun delete(account: &amp;signer): u64 acquires Counter {
        // 删除 Counter 资源 // remove the Counter resource
        let c = move_from&lt;Counter&gt;(signer::address_of(account));
        // 将 `Counter` 资源“拆”为字段。这是需要授权的操作，只能在声明 `Counter` 资源的此模块内执行。 // &quot;Unpack&quot; the `Counter` resource into its fields. This is a privileged operation that can only be done inside the module that declares the `Counter` resource
        let Counter { i } = c;
        i
    }

    /// 如果 `addr` 下包含 `Counter` 资源，则返回 `true`。 /// Return `true` if `addr` contains a `Counter` resource
    public fun exists(addr: address): bool {
        exists&lt;Counter&gt;(addr)
    }
}
}
</code></pre>
<h2 id="acquires-函数标注annotating-functions-with-acquires"><a class="header" href="#acquires-函数标注annotating-functions-with-acquires"><code>acquires</code> 函数标注（Annotating functions with <code>acquires</code>）</a></h2>
<p>In the <code>counter</code> example, you might have noticed that the <code>get_count</code>, <code>increment</code>, <code>reset</code>, and <code>delete</code> functions are annotated with <code>acquires Counter</code>. A Move function <code>m::f</code> must be annotated with <code>acquires T</code> if and only if:</p>
<ul>
<li>The body of <code>m::f</code> contains a <code>move_from&lt;T&gt;</code>, <code>borrow_global_mut&lt;T&gt;</code>, or <code>borrow_global&lt;T&gt;</code> instruction, or</li>
<li>The body of <code>m::f</code> invokes a function <code>m::g</code> declared in the same module that is annotated with <code>acquires</code></li>
</ul>
<p>在 <code>counter</code> 例子中，可以注意到 <code>get_count</code>、<code>increment</code>、<code>reset</code> 和 <code>delete</code> 方法都使用 <code>acquires Counter</code> 进行标注。函数 <code>m::f</code> 在且仅在下述情况必须使用 <code>acquires T</code> 进行标注：</p>
<ul>
<li><code>m::f</code> 的主体包含 <code>move_from&lt;T&gt;</code>、<code>borrow_global_mut&lt;T&gt;</code> 或 <code>borrow_global&lt;T&gt;</code> 指令调用</li>
<li><code>m::f</code> 的主体调用了同模块内被 <code>acquires</code> 注解的 <code>m::g</code> 的函数</li>
</ul>
<p>For example, the following function inside <code>Counter</code> would need an <code>acquires</code> annotation:</p>
<p>例如，下面 <code>Counter</code> 内的函数需要使用 <code>acquires</code> 标注：</p>
<pre><code class="language-move">// 由于 `increment` 使用了 `acquires` 标注，所以函数需要 `acquires` // Needs `acquires` because `increment` is annotated with `acquires`
fun call_increment(addr: address): u64 acquires Counter {
    counter::increment(addr)
}
</code></pre>
<p>However, the same function <em>outside</em> <code>Counter</code> would not need an annotation:</p>
<p>然而，在 <code>Counter</code> <em>外面</em>的函数则不需要进行标注：</p>
<pre><code class="language-move">address 0x43 {
module m {
   use 0x42::counter;

   // 可以，仅在函数声明在同一模块内时需要标注 // Ok. Only need annotation when resource acquired by callee is declared in the same module
   fun call_increment(addr: address): u64 {
       counter::increment(addr)
   }
}
}
</code></pre>
<p>If a function touches multiple resources, it needs multiple <code>acquires</code>:</p>
<p>如果函数需要多个资源，<code>acquires</code> 则需要多个参数：</p>
<pre><code class="language-move=">address 0x42 {
module two_resources {
    struct R1 has key { f: u64 }
    struct R2 has key { g: u64 }

    fun double_acquires(a: address): u64 acquires R1, R2 {
        borrow_global&lt;R1&gt;(a).f + borrow_global&lt;R2&gt;.g
    }
}
}
</code></pre>
<p>The <code>acquires</code> annotation does not take generic type parameters into account:</p>
<p><code>acquires</code> 标注不会将泛型类型参数纳入声明中：</p>
<pre><code class="language-move=">address 0x42 {
module m {
    struct R&lt;T&gt; has key { t: T }

    // 效果为 `acquires R` 而不是 `acquires R&lt;T&gt;` // `acquires R`, not `acquires R&lt;T&gt;`
    fun acquire_generic_resource&lt;T: store&gt;(a: addr) acquires R {
        let _ = borrow_global&lt;R&lt;T&gt;&gt;(a);
    }

    // 效果为 `acquires R` 而不是 `acquiresR&lt;u64&gt;` // `acquires R`, not `acquires R&lt;u64&gt;
    fun acquire_instantiated_generic_resource(a: addr) acquires R {
        let _ = borrow_global&lt;R&lt;u64&gt;&gt;(a);
    }
}
}
</code></pre>
<p>Finally: redundant <code>acquires</code> are not allowed. Adding this function inside <code>Counter</code> will result in a compilation error:</p>
<p>最后：不允许使用不必要的 <code>acquires</code>。在 <code>Counter</code> 内添加下述方法将会导致编译错误：</p>
<pre><code class="language-move">// 下面代码不会编译，因为函数体没有使用全局存储指令也没调用使用 `acquires` 注解的函数 // This code will not compile because the body of the function does not use a global storage instruction or invoke a function with `acquires`
fun redundant_acquires_bad() acquires Counter {}
</code></pre>
<p>For more information on <code>acquires</code>, see <a href="functions.html">Move functions</a>.</p>
<p>关于 <code>acquires</code> 更多信息，参见 <a href="functions.html">Move 函数</a>。</p>
<h2 id="全局资源引用安全reference-safety-for-global-resources"><a class="header" href="#全局资源引用安全reference-safety-for-global-resources">全局资源引用安全（Reference Safety For Global Resources）</a></h2>
<p>Move prohibits returning global references and requires the <code>acquires</code> annotation to prevent dangling references. This allows Move to live up to its promise of static reference safety (i.e., no dangling references, no <code>null</code> or <code>nil</code> dereferences) for all <a href="references.html">reference</a> types.</p>
<p>Move 禁止返回全局引用并且需要使用 <code>acquires</code> 标注来防止空引用。这使 Move 保证了所有<a href="references.html">引用</a>类型的静态引用安全性（例如，没有空引用、不会解引用 <code>null</code> 或 <code>nil</code> 对象）。</p>
<p>This example illustrates how the Move type system uses <code>acquires</code> to prevent a dangling reference:</p>
<p>这个例子展示了 Move 类型系统如何通过使用 <code>acquires</code> 来防止空引用：</p>
<pre><code class="language-move=">address 0x42 {
module dangling {
    struct T has key { f: u64 }

    fun borrow_then_remove_bad(a: address) acquires T {
        let t_ref: &amp;mut T = borrow_global_mut&lt;T&gt;(a);
        let t = remove_t(a); // 类型系统不允许 t_ref 这种空引用 // type system complains here
        // t_ref now dangling!
        let uh_oh = *&amp;t_ref.f
    }

    fun remove_t(a: address): T acquires T {
        move_from&lt;T&gt;(a)
    }

}
}
</code></pre>
<p>In this code, line 6 acquires a reference to the <code>T</code> stored at address <code>a</code> in global storage. The callee <code>remove_t</code> then removes the value, which makes <code>t_ref</code> a dangling reference.</p>
<p>代码中第六行获取了 <code>a</code> 地址在全局存储中 <code>T</code> 类型资源的引用。<code>remove_t</code> 调用删除了该值，使 <code>t_ref</code> 变成空引用。</p>
<p>Fortunately, this cannot happen because the type system will reject this program. The <code>acquires</code> annotation on <code>remove_t</code> lets the type system know that line 7 is dangerous, without having to recheck or introspect the body of <code>remove_t</code> separately!</p>
<p>幸运的是，由于类型系统拒绝编译程序导致这种情况不会发生。<code>remove_t</code> 方法的 <code>acquires</code> 标注让类型系统知道第七行是危险的，不需要再分析 <code>remove_t</code> 的函数体。</p>
<p>The restriction on returning global references prevents a similar, but even more insidious problem:</p>
<p>禁止返回全局引用的限制同时也防止了类似却更隐晦的问题：</p>
<pre><code class="language-move=">address 0x42 {
module m1 {
    struct T has key {}

    public fun ret_t_ref(a: address): &amp;T acquires T {
        borrow_global&lt;T&gt;(a) // 报错 类型系统在这不能继续编译 // error! type system complains here
    }

    public fun remove_t(a: address) acquires T {
        let T {} = move_from&lt;T&gt;(a);
    }
}

module m2 {
    fun borrow_then_remove_bad(a: address) {
        let t_ref = m1::ret_t_ref(a);
        let t = m1::remove_t(a); // t_ref 为空引用 // t_ref now dangling!
    }
}
}
</code></pre>
<p>Line 16 acquires a reference to a global resource <code>m1::T</code>, then line 17 removes that same resource, which makes <code>t_ref</code> dangle. In this case, <code>acquires</code> annotations do not help us because the <code>borrow_then_remove_bad</code> function is outside of the <code>m1</code> module that declares <code>T</code> (recall that <code>acquires</code> annotations can only be used for resources declared in the current module). Instead, the type system avoids this problem by preventing the return of a global reference at line 6.</p>
<p>第十六行获取了全局资源 <code>m1::T</code> 类型的引用，然后第十七行删除了同一资源，这使 <code>t_ref</code> 变成空引用。在这个例子中，<code>acquires</code> 标注没有帮助到我们，因为 <code>borrow_then_remove_bad</code> 函数在声明了 <code>T</code> 类型（回顾 <code>acquires</code> 标注只用在声明此类型的模块内）的 <code>m1</code> 模块外。然而禁止返回全局引用的规则使第六行避免了这个问题。</p>
<p>Fancier type systems that would allow returning global references without sacrificing reference safety are possible, and we may consider them in future iterations of Move. We chose the current design because it strikes a good balance between expressivity, annotation burden, and type system complexity.</p>
<p>允许返回全局引用而尽可能不牺牲引用安全的高级类型系统是可行的，我们将会在 Move 未来的迭代过程中考虑此事。我们选择目前的设计方式是因为它很好的平衡了语言表现力、复杂的标注和复杂的类型系统三者的关系。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标准库standard-library"><a class="header" href="#标准库standard-library">标准库（Standard Library）</a></h1>
<p>The Move standard library exposes interfaces that implement the following functionality:</p>
<ul>
<li><a href="standard-library.html#vector">Basic operations on vectors</a>.</li>
<li><a href="standard-library.html#option">Option types and operations on<code>Option</code> types</a>.</li>
<li><a href="standard-library.html#errors">A common error encoding code interface for abort codes</a>.</li>
<li><a href="standard-library.html#fixed_point32">32-bit precision fixed-point numbers</a>.</li>
</ul>
<p>Move标准库公开了实现以下功能的接口:</p>
<ul>
<li><a href="standard-library.html#%E5%90%91%E9%87%8F">向量的基本操作</a>.</li>
<li><a href="standard-library.html#option">Option类型与基本操作</a>.</li>
<li><a href="standard-library.html#errors">终止码的常见错误编码接口</a>.</li>
<li><a href="standard-library.html#fixed_point32">32位精确定点数字</a>.</li>
</ul>
<h2 id="向量vector"><a class="header" href="#向量vector">向量（vector）</a></h2>
<p>The <code>vector</code> module defines a number of operations over the primitive
<a href="vector.html"><code>vector</code></a> type. The module is published under the
named address <code>Std</code> and consists of a number of native functions, as
well as functions defined in Move. The API for this module is as follows.</p>
<p><code>向量</code>模块在原生类型<a href="vector.html"><code>向量</code></a>上定义了许多操作。该模块以命名地址<code>Std</code>发布，并由许多原生函数以及在Move中定义的函数组成。此模块的API如下所示:</p>
<h3 id="函数functions"><a class="header" href="#函数functions">函数（Functions）</a></h3>
<hr />
<p>Create an empty <a href="vector.html"><code>vector</code></a>.
The <code>Element</code> type can be both a <code>resource</code> or <code>copyable</code> type.</p>
<p>创建一个空的<a href="vector.html"><code>向量</code></a>。
<code>Element</code>类型可以是<code>资源</code>或<code>可复制</code>类型。</p>
<pre><code class="language-move">    native public fun empty&lt;Element&gt;(): vector&lt;Element&gt;;
</code></pre>
<hr />
<p>Create a vector of length <code>1</code> containing the passed in <code>element</code>.</p>
<p>创建一个长度为<code>1</code>的vector，并且包含传入的<code>element</code>。</p>
<pre><code class="language-move">    public fun singleton&lt;Element&gt;(e: Element): vector&lt;Element&gt;;
</code></pre>
<hr />
<p>Destroy (deallocate) the vector <code>v</code>. Will abort if <code>v</code> is non-empty.
<em>Note</em>: The emptiness restriction is due to the fact that <code>Element</code> can be a
resource type, and destruction of a non-empty vector would violate
<a href="structs-and-resources.html">resource conservation</a>.</p>
<p>销毁(释放)向量<code>v</code>。如果<code>v</code>非空操作将终止。
<em>注意</em>:空的限制是由于<code>Element</code>可以是资源类型，而销毁非空的向量会违反<a href="structs-and-resources.html">资源保护机制</a>。</p>
<pre><code class="language-move">    native public fun destroy_empty&lt;Element&gt;(v: vector&lt;Element&gt;);
</code></pre>
<hr />
<p>Acquire an <a href="references.html">immutable reference</a> to the <code>i</code>th element of the vector <code>v</code>.  Will abort if
the index <code>i</code> is out of bounds for the vector <code>v</code>.</p>
<p>获取向量<code>v</code>的第<code>i</code>个元素的<a href="references.html">不可变引用</a>。如果索引<code>i</code>超出了向量<code>v</code>的范围，操作将会终止。</p>
<pre><code class="language-move">    native public fun borrow&lt;Element&gt;(v: &amp;vector&lt;Element&gt;, i: u64): &amp;Element;
</code></pre>
<hr />
<p>Acquire a <a href="references.html">mutable reference</a>
to the <code>i</code>th element of the vector <code>v</code>.  Will abort if
the index <code>i</code> is out of bounds for the vector <code>v</code>.</p>
<p>获取向量<code>v</code>的第<code>i</code>个元素的<a href="references.html">可变引用</a>。如果索引<code>i</code>超出了向量<code>v</code>的范围，操作将会终止。</p>
<pre><code class="language-move">    native public fun borrow_mut&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64): &amp;mut Element;
</code></pre>
<hr />
<p>Empty and destroy the <code>other</code> vector, and push each of the elements in
the <code>other</code> vector onto the <code>lhs</code> vector in the same order as they occurred in <code>other</code>.</p>
<p>清空并销毁<code>other</code>动态数组，并将<code>other</code>向量中的每个元素按顺序添加到<code>lhs</code>动态数组。</p>
<pre><code class="language-move">    public fun append&lt;Element&gt;(lhs: &amp;mut vector&lt;Element&gt;, other: vector&lt;Element&gt;);
</code></pre>
<hr />
<p>Push an element <code>e</code> of type <code>Element</code> onto the end of the vector <code>v</code>. May
trigger a resizing of the underlying vector's memory.</p>
<p>将类型为<code>Element</code>的元素<code>e</code>添加到向量<code>v</code>的末尾。可能触发底层向量内存的大小调整。</p>
<pre><code class="language-move">    native public fun push_back&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, e: Element);
</code></pre>
<hr />
<p>Pop an element from the end of the vector <code>v</code> in-place and return the owned
value. Will abort if <code>v</code> is empty.</p>
<p>从向量<code>v</code>的末尾取出一个元素并返回。如果<code>v</code>为空将终止操作。</p>
<pre><code class="language-move">    native public fun pop_back&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;): Element;
</code></pre>
<hr />
<p>Remove the element at index <code>i</code> in the vector <code>v</code> and return the owned value
that was previously stored at <code>i</code> in <code>v</code>. All elements occurring at indices
greater than <code>i</code> will be shifted down by 1. Will abort if <code>i</code> is out of bounds
for <code>v</code>.</p>
<p>移除向量<code>v</code>中索引<code>i</code>处的元素，并返回之前存储在<code>v</code>中的<code>i</code>处的值。所有下标大于<code>i</code>的元素将向前移动1个位置。如果<code>i</code>超出了<code>v</code>的范围，操作将会终止。</p>
<pre><code class="language-move">    public fun remove&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64): Element;
</code></pre>
<hr />
<p>Swap the <code>i</code>th element of the vector <code>v</code> with the last element and then pop
this element off of the back of the vector and return the owned value that
was previously stored at index <code>i</code>.
This operation is O(1), but does not preserve ordering of elements in the vector.
Aborts if the index <code>i</code> is out of bounds for the vector <code>v</code>.</p>
<p>将向量<code>v</code>的第<code>i</code>个元素与最后一个元素交换，然后将这个元素从向量的后面取出，并返回之前存储在索引<code>i</code>处的所有元素的值。
这个操作时间复杂度是O(1)，但是不保持向量容器中元素的顺序。
如果索引<code>i</code>超出了向量<code>v</code>的边界，则操作终止。</p>
<pre><code class="language-move">    public fun swap_remove&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64): Element;
</code></pre>
<hr />
<p>Swap the elements at the <code>i</code>'th and <code>j</code>'th indices in the vector <code>v</code>. Will
abort if either of <code>i</code> or <code>j</code> are out of bounds for <code>v</code>.</p>
<p>交换向量<code>v</code>中下标为第<code>i</code>和第<code>j</code>的元素。如果<code>i</code>或<code>j</code>中的任何一个超出了<code>v</code>的范围，则操作将终止。</p>
<pre><code class="language-move">    native public fun swap&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64, j: u64);
</code></pre>
<hr />
<p>Reverse the order of the elements in the vector <code>v</code> in-place.</p>
<p>将向量v中的元素顺序颠倒。</p>
<pre><code class="language-move">    public fun reverse&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;);
</code></pre>
<hr />
<p>Return the index of the first occurrence of an element in <code>v</code> that is
equal to <code>e</code>. Returns <code>(true, index)</code> if such an element was found, and
<code>(false, 0)</code> otherwise.</p>
<p>返回<code>v</code>中第一个与<code>e</code>相等的元素的索引。如果找到这样的元素，则返回<code>(true, index)</code>，否则返回<code>(false, 0)</code>。</p>
<pre><code class="language-move">    public fun index_of&lt;Element&gt;(v: &amp;vector&lt;Element&gt;, e: &amp;Element): (bool, u64);
</code></pre>
<hr />
<p>Return if an element equal to <code>e</code> exists in the vector <code>v</code>.</p>
<p>如果向量<code>v</code>中存在等于<code>e</code>的元素，则返回true, 否则返回false。</p>
<pre><code class="language-move">    public fun contains&lt;Element&gt;(v: &amp;vector&lt;Element&gt;, e: &amp;Element): bool;
</code></pre>
<hr />
<p>Return the length of a <code>vector</code>.</p>
<p>返回<code>向量</code>的长度。</p>
<pre><code class="language-move">    native public fun length&lt;Element&gt;(v: &amp;vector&lt;Element&gt;): u64;
</code></pre>
<hr />
<p>Return whether the vector <code>v</code> is empty.</p>
<p>如果向量<code>v</code>中没有元素，则返回true, 否则返回false。</p>
<pre><code class="language-move">    public fun is_empty&lt;Element&gt;(v: &amp;vector&lt;Element&gt;): bool;
</code></pre>
<hr />
<h2 id="选项option"><a class="header" href="#选项option">选项（option）</a></h2>
<p>The <code>option</code> module defines a generic option type <code>Option&lt;T&gt;</code> that represents a
value of type <code>T</code> that may, or may not, be present. It is published under the named address <code>Std</code>.</p>
<p><code>option</code>模块定义了一个泛型option类型<code>Option&lt;T&gt;</code>，它表示类型为<code>T</code>的值可能存在，也可能不存在。它发布在命名地址<code>Std</code>下。</p>
<p>The Move option type is internally represented as a singleton vector, and may
contain a value of <code>resource</code> or <code>copyable</code> kind.  If you are familiar with option
types in other languages, the Move <code>Option</code> behaves similarly to those with a
couple notable exceptions since the option can contain a value of kind <code>resource</code>.
Particularly, certain operations such as <code>get_with_default</code> and
<code>destroy_with_default</code> require that the element type <code>T</code> be of <code>copyable</code> kind.</p>
<p>Move option类型在内部表示为一个单例向量，可能包含<code>资源</code>或<code>可复制</code>类型的值。如果你熟悉其他语言中的option类型，Move <code>Option</code>的行为与那些类似，但有几个显著的例外，因为option可以包含一个类型为<code>资源</code>的值。
特别地，某些操作如<code>get_with_default</code>和<code>destroy_with_default</code>要求元素类型<code>T</code>为<code>可复制</code>类型。</p>
<p>The API for the <code>option</code> module is as as follows</p>
<p><code>option</code>模块的API如下所示:</p>
<h3 id="类型types"><a class="header" href="#类型types">类型（Types）</a></h3>
<p>Generic type abstraction of a value that may, or may not, be present. Can contain
a value of either <code>resource</code> or <code>copyable</code> kind.</p>
<p>一个值的泛型类型的抽象，可能存在，也可能不存在。它可以包含<code>资源</code>或<code>可复制</code>类型的值。</p>
<pre><code class="language-move">    struct Option&lt;T&gt;;
</code></pre>
<h3 id="函数functions-1"><a class="header" href="#函数functions-1">函数（Functions）</a></h3>
<p>Create an empty <code>Option</code> of that can contain a value of <code>Element</code> type.</p>
<p>创建一个可以包含<code>Element</code>类型值的空<code>Option</code>。</p>
<pre><code class="language-move">    public fun none&lt;Element&gt;(): Option&lt;Element&gt;;
</code></pre>
<hr />
<p>Create a non-empty <code>Option</code> type containing a value <code>e</code> of type <code>Element</code>.</p>
<p>创建一个非空的<code>Option</code>类型，包含类型为<code>Element</code>的值<code>e</code>。</p>
<pre><code class="language-move">    public fun some&lt;Element&gt;(e: T): Option&lt;Element&gt;;
</code></pre>
<hr />
<p>Return an immutable reference to the value inside the option <code>opt_elem</code>
Will abort if <code>opt_elem</code> does not contain a value.</p>
<p>返回<code>opt_elem</code>内部值的不可变引用,如果<code>opt_elem</code>不包含值，则将终止操作。</p>
<pre><code class="language-move">    public fun borrow&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;): &amp;Element;
</code></pre>
<hr />
<p>Return a reference to the value inside <code>opt_elem</code> if it contains one. If
<code>opt_elem</code> does not contain a value the passed in <code>default_ref</code> reference will be returned.
Does not abort.</p>
<p>如果<code>opt_elem</code>中包含值，则返回该值的引用。如果<code>opt_elem</code>不包含值，将返回传入的<code>default_ref</code>引用。不会终止操作。</p>
<pre><code class="language-move">    public fun borrow_with_default&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;, default_ref: &amp;Element): &amp;Element;
</code></pre>
<hr />
<p>Return a mutable reference to the value inside <code>opt_elem</code>. Will abort if
<code>opt_elem</code> does not contain a value.</p>
<p>返回<code>opt_elem</code>内部值的可变引用。如果<code>opt_elem</code>不包含值，则操作将终止。</p>
<pre><code class="language-move">    public fun borrow_mut&lt;Element&gt;(opt_elem: &amp;mut Option&lt;Element&gt;): &amp;mut Element;
</code></pre>
<hr />
<p>Convert an option value that contains a value to one that is empty in-place by
removing and returning the value stored inside <code>opt_elem</code>.
Will abort if <code>opt_elem</code> does not contain a value.</p>
<p>通过删除并返回存储在<code>opt_elem</code>中的值，将包含值的<code>opt_elem</code>转换为空option类型。
如果<code>opt_elem</code>不包含值，则将终止。</p>
<pre><code class="language-move">    public fun extract&lt;Element&gt;(opt_elem: &amp;mut Option&lt;Element&gt;): Element;
</code></pre>
<hr />
<p>Return the value contained inside the option <code>opt_elem</code> if it contains one.
Will return the passed in <code>default</code> value if <code>opt_elem</code> does not contain a
value. The <code>Element</code> type that the <code>Option</code> type is instantiated with must be
of <code>copyable</code> kind in order for this function to be callable.</p>
<p>如果<code>opt_elem</code>中包含值，则返回该值。
如果<code>opt_elem</code>不包含值，将返回传入的<code>default</code>值。<code>default</code>类型必须是<code>可复制</code>类型，这样该函数才能被调用。</p>
<pre><code class="language-move">    public fun get_with_default&lt;Element: copyable&gt;(opt_elem: &amp;Option&lt;Element&gt;, default: Element): Element;
</code></pre>
<hr />
<p>Convert an empty option <code>opt_elem</code> to an option value that contains the value <code>e</code>.
Will abort if <code>opt_elem</code> already contains a value.</p>
<p>将空option类型<code>opt_elem</code>转换为包含值<code>e</code>的option类。
如果<code>opt_elem</code>已经包含值，则操作将终止。</p>
<pre><code class="language-move">    public fun fill&lt;Element&gt;(opt_elem: &amp;mut Option&lt;Element&gt;, e: Element);
</code></pre>
<hr />
<p>Swap the value currently contained in <code>opt_elem</code> with <code>new_elem</code> and return the
previously contained value. Will abort if <code>opt_elem</code> does not contain a value.</p>
<p>将<code>opt_elem</code>当前包含的值与<code>new_elem</code>交换，并返回先前包含的值。如果<code>opt_elem</code>不包含值，则操作将终止。</p>
<pre><code class="language-move">    public fun swap&lt;Element&gt;(opt_elem: &amp;mut Option&lt;Element&gt;, e: Element): Element;
</code></pre>
<hr />
<p>Return true if <code>opt_elem</code> contains a value equal to the value of <code>e_ref</code>.
Otherwise, <code>false</code> will be returned.</p>
<p>如果<code>opt_elem</code>包含一个等于<code>e_ref</code>的值，则返回<code>true</code>。否则，将返回<code>false</code>。</p>
<pre><code class="language-move">    public fun contains&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;, e_ref: &amp;Element): bool;
</code></pre>
<hr />
<p>Return <code>true</code> if <code>opt_elem</code> does not contain a value.</p>
<p>如果<code>opt_elem</code>不包含值，则返回<code>true</code>。</p>
<pre><code class="language-move">    public fun is_none&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;): bool;
</code></pre>
<hr />
<p>Return <code>true</code> if <code>opt_elem</code> contains a value.</p>
<p>如果<code>opt_elem</code>包含值，则返回<code>true</code>。</p>
<pre><code class="language-move">    public fun is_some&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;): bool;
</code></pre>
<hr />
<p>Unpack <code>opt_elem</code> and return the value that it contained.
Will abort if <code>opt_elem</code> does not contain a value.</p>
<p>解包<code>opt_elem</code>并返回它所包含的值。
如果<code>opt_elem</code>不包含值，则操作将终止。</p>
<pre><code class="language-move">    public fun destroy_some&lt;Element&gt;(opt_elem: Option&lt;Element&gt;): Element;
</code></pre>
<hr />
<p>Destroys the <code>opt_elem</code> value passed in. If <code>opt_elem</code> contained a value it
will be returned otherwise, the passed in <code>default</code> value will be returned.</p>
<p>销毁传入的<code>opt_elem</code>。如果<code>opt_elem</code>包含值，它将被返回，否则将返回传入的<code>default</code>值。</p>
<pre><code class="language-move">    public fun destroy_with_default&lt;Element: copyable&gt;(opt_elem: Option&lt;Element&gt;, default: Element): Element;
</code></pre>
<hr />
<p>Destroys the <code>opt_elem</code> value passed in, <code>opt_elem</code> must be empty and not
contain a value. Will abort if <code>opt_elem</code> contains a value.</p>
<p>销毁传入的<code>opt_elem</code>，<code>opt_elem</code>必须为空且不包含值。如果<code>opt_elem</code>包含一个值，则会终止操作。</p>
<pre><code class="language-move">    public fun destroy_none&lt;Element&gt;(opt_elem: Option&lt;Element&gt;);
</code></pre>
<h2 id="错误errors"><a class="header" href="#错误errors">错误（errors）</a></h2>
<p>Recall that each abort code in Move is represented as an unsigned 64-bit integer. The <code>errors</code> module defines a common interface that can be used to &quot;tag&quot; each of these abort codes so that they can represent both the error <strong>category</strong> along with an error <strong>reason</strong>.</p>
<p>回想一下，Move中的每个终止代码都表示为无符号64位整数。<code>errors</code>模块定义了一个通用接口，可用于&quot;标记&quot;每个终止代码，以便它们既可以表示错误<strong>类别</strong>，也可以表示错误<strong>原因</strong>。</p>
<p>Error categories are declared as constants in the <code>errors</code> module and are globally unique with respect to this module. Error reasons on the other hand are module-specific error codes, and can provide greater detail (perhaps, even a particular <em>reason</em>) about the specific error condition. This representation of a category and reason for each error code is done by dividing the abort code into two sections.</p>
<p>错误类别在<code>errors</code>模块中声明为常量，并且对该模块来说是全局唯一的。另一方面，错误原因是特定于模块的错误代码，可以提供关于特定错误条件的更详细的信息(甚至可能是一个特定的_reason_)。每个错误代码的类别和原因的这种表示是通过将终止代码分成两部分来完成的。</p>
<p>The lower 8 bits of the abort code hold the <em>error category</em>. The remaining 56 bits of the abort code hold the <em>error reason</em>.
The reason should be a unique number relative to the module which raised the error and can be used to obtain more information about the error at hand. It should mostly be used for diagnostic purposes as error reasons may change over time if the module is updated.</p>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Reason</th></tr></thead><tbody>
<tr><td>8 bits</td><td>56 bits</td></tr>
</tbody></table>
</div>
<p>Since error categories are globally stable, these present the most stable API and should in general be what is used by clients to determine the messages they may present to users (whereas the reason is useful for diagnostic purposes). There are public functions in the <code>errors</code> module for creating an abort code of each error category with a specific <code>reason</code> number (represented as a <code>u64</code>).</p>
<p>终止代码的较低8位保存<em>错误类别</em>。终止代码的其余56位包含<em>错误原因</em>。
原因应该是相对于引发错误的模块的唯一数字，并且可以用来获取关于当前错误的更多信息。它应该主要用于诊断目的，因为如果模块更新，错误原因可能会随着时间的推移而变化。</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>原因</th></tr></thead><tbody>
<tr><td>8 bits</td><td>56 bits</td></tr>
</tbody></table>
</div>
<p>由于错误类别是全局稳定的，所以它们提供了稳定的API，通常应该由客户端用来确定它们可能向用户提供的消息(而原因则用于诊断目的)。在<code>errors</code>模块中有一些公共函数，用于创建每个错误类别的带有特定<code>原因</code>号的终止代码(表示为<code>u64</code>)。</p>
<h3 id="常量constants"><a class="header" href="#常量constants">常量（Constants）</a></h3>
<p>The system is in a state where the performed operation is not allowed.</p>
<p>系统处于不允许操作的状态。</p>
<pre><code class="language-move">    const INVALID_STATE: u8 = 1;
</code></pre>
<hr />
<p>A specific account address was required to perform an operation, but a different address from what was expected was encounterd.</p>
<p>执行操作需要一个特定的帐户地址，但遇到的地址与预期的不同。</p>
<pre><code class="language-move">    const REQUIRES_ADDRESS: u8 = 2;
</code></pre>
<hr />
<p>An account did not have the expected  role for this operation. Useful for Role Based Access Control (RBAC) error conditions.</p>
<p>帐户没有此操作的预期角色。用于基于角色访问控制(RBAC)错误。</p>
<pre><code class="language-move">    const REQUIRES_ROLE: u8 = 3;
</code></pre>
<hr />
<p>An account did not not have a required capability. Useful for RBAC error conditions.</p>
<p>帐户没有所需的能力。用于RBAC错误。</p>
<pre><code class="language-move">    const REQUIRES_CAPABILITY: u8 = 4;
</code></pre>
<hr />
<p>A resource was expected, but did not exist under an address.</p>
<p>地址下不存在期望的资源。</p>
<pre><code class="language-move">    const NOT_PUBLISHED: u8 = 5;
</code></pre>
<hr />
<p>Attempted to publish a resource under an address where one was already published.</p>
<p>试图在已发布资源的地址发布资源。</p>
<pre><code class="language-move">    const ALREADY_PUBLISHED: u8 = 6;
</code></pre>
<hr />
<p>An argument provided for an operation was invalid.</p>
<p>为操作提供的参数无效。</p>
<pre><code class="language-move">    const INVALID_ARGUMENT: u8 = 7;
</code></pre>
<hr />
<p>A limit on a value was exceeded.</p>
<p>超过了一个值的限制。</p>
<pre><code class="language-move">    const LIMIT_EXCEEDED: u8 = 8;
</code></pre>
<hr />
<p>An internal error (bug) has occurred.</p>
<p>发生了内部错误(bug)。</p>
<pre><code class="language-move">    const INTERNAL: u8 = 10;
</code></pre>
<hr />
<p>A custom error category for extension points.</p>
<p>扩展自定义错误类别。</p>
<pre><code class="language-move">    const CUSTOM: u8 = 255;
</code></pre>
<hr />
<h3 id="函数functions-2"><a class="header" href="#函数functions-2">函数（Functions）</a></h3>
<p>Should be used in the case where invalid (global) state is encountered. Constructs an abort code with specified <code>reason</code> and category <code>INVALID_STATE</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>在遇到无效(全局)状态的情况下应使用。构造一个具有指定的<code>reason</code>和类别<code>INVALID_STATE</code>的终止代码。如果<code>reason</code>不适合56位，将会终止操作。</p>
<pre><code class="language-move">    public fun invalid_state(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if an account's address does not match a specific address. Constructs an abort code with specified <code>reason</code> and category <code>REQUIRES_ADDRESS</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>当账户地址与特定地址不匹配时应使用。构造一个具有指定的<code>reason</code>和类别<code>REQUIRES_ADDRESS</code>的终止代码。如果<code>reason</code>不适合56位，将会终止操作。</p>
<pre><code class="language-move">    public fun requires_address(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if a role did not match a required role when using RBAC. Constructs an abort code with specified <code>reason</code> and category <code>REQUIRES_ROLE</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>在使用RBAC时，角色与所需角色不匹配时应使用。构造一个具有指定的<code>reason</code>和类别<code>REQUIRES_ROLE</code>的终止代码。如果<code>reason</code>不适合56位，将会终止操作。</p>
<pre><code class="language-move">    public fun requires_role(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if an account did not have a required capability when using RBAC. Constructs an abort code with specified <code>reason</code> and category <code>REQUIRES_CAPABILITY</code>. Should be Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>在使用RBAC时，帐户没有必要的能力时应使用。构造一个具有指定的<code>reason</code>和类别<code>REQUIRES_CAPABILITY</code>的终止代码。如果<code>reason</code>不适合56位，将会终止操作。</p>
<pre><code class="language-move">    public fun requires_capability(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if a resource did not exist where one was expected. Constructs an abort code with specified <code>reason</code> and category <code>NOT_PUBLISHED</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>在需要资源的地方不存在资源时应使用。构造一个具有指定的<code>reason</code>和类别<code>NOT_PUBLISHED</code>的终止代码。如果<code>reason</code>不适合56位，将会终止操作。</p>
<pre><code class="language-move">    public fun not_published(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if a resource already existed where one was about to be published. Constructs an abort code with specified <code>reason</code> and category <code>ALREADY_PUBLISHED</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>要发布资源的地方已经存在资源时使用。构造一个具有指定的<code>reason</code>和类别<code>ALREADY_PUBLISHED</code>的终止代码。如果<code>reason</code>不适合56位，将会终止操作。</p>
<pre><code class="language-move">    public fun already_published(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if an invalid argument was passed to a function/operation. Constructs an abort code with specified <code>reason</code> and category <code>INVALID_ARGUMENT</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>当向函数/操作传递无效参数时使用。构造一个具有指定的<code>reason</code>和类别<code>INVALID_ARGUMENT</code>的终止代码。如果<code>reason</code>不适合56位，将会终止操作。</p>
<pre><code class="language-move">    public fun invalid_argument(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if a limit on a specific value is reached, e.g., subtracting 1 from a value of 0. Constructs an abort code with specified <code>reason</code> and category <code>LIMIT_EXCEEDED</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>当达到特定值的限制时应使用，例如，0减去1。构造一个具有指定的<code>reason</code>和类别<code>LIMIT_EXCEEDED</code>的终止代码。如果<code>reason</code>不适合56位，将会终止操作。</p>
<pre><code class="language-move">    public fun limit_exceeded(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if an internal error or bug was encountered. Constructs an abort code with specified <code>reason</code> and category <code>INTERNAL</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>在遇到内部错误或错误时使用。构造一个具有指定的<code>reason</code>和类别<code>INTERNAL</code>的终止代码。如果<code>reason</code>不适合56位，将会终止操作。</p>
<pre><code class="language-move">    public fun internal(reason: u64): u64;
</code></pre>
<hr />
<p>Used for extension points, should be not used under most circumstances. Constructs an abort code with specified <code>reason</code> and category <code>CUSTOM</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>用于扩展，大多数情况下不应使用。构造一个具有指定的<code>reason</code>和类别<code>CUSTOM</code>的终止代码。如果<code>reason</code>不适合56位，将会终止操作。</p>
<pre><code class="language-move">    public fun custom(reason: u64): u64;
</code></pre>
<hr />
<h2 id="32位精确定点数字fixed_point32"><a class="header" href="#32位精确定点数字fixed_point32">32位精确定点数字（fixed_point32）</a></h2>
<p>The <code>fixed_point32</code> module defines a fixed-point numeric type with 32 integer bits and 32 fractional bits. Internally, this is represented as a <code>u64</code> integer wrapped in a struct to make a unique <code>fixed_point32</code> type. Since the numeric representation is a binary one, some decimal values may not be exactly representable, but it provides more than 9 decimal digits of precision both before and after the decimal point (18 digits total). For comparison, double precision floating-point has less than 16 decimal digits of precision, so you should be careful about using floating-point to convert these values to decimal.</p>
<p><code>fixed_point32</code>模块定义了一个具有32个整数位和32个小数位的定点数值类型。在内部，它被表示为一个<code>u64</code>整数，包装在一个结构中，形成一个唯一的<code>fixed_point32</code>类型。由于数字表示是二进制的，一些十进制值可能不能完全表示，但它在小数点之前和之后都提供了9位以上的十进制精度(总共18位)。为了进行比较，双精度浮点数的精度小于16位十进制数字，因此在使用浮点数将这些值转换为十进制时应该小心。</p>
<h3 id="类型types-1"><a class="header" href="#类型types-1">类型（Types）</a></h3>
<p>Represents a fixed-point numeric number with 32 fractional bits.</p>
<p>表示具有32个小数位的定点数字。</p>
<pre><code class="language-move">    struct FixedPoint32;
</code></pre>
<h3 id="函数functions-3"><a class="header" href="#函数functions-3">函数（Functions）</a></h3>
<p>Multiply a u64 integer by a fixed-point number, truncating any fractional part of the product. This will abort if the product overflows.</p>
<p>当u64整数乘以定点数，截断乘积的任何小数部分。如果乘积溢出，该操作将终止。</p>
<pre><code class="language-move">    public fun multiply_u64(val: u64, multiplier: FixedPoint32): u64;
</code></pre>
<hr />
<p>Divide a u64 integer by a fixed-point number, truncating any fractional part of the quotient. This will abort if the divisor is zero or if the quotient overflows.</p>
<p>当u64整数除以定点数，截断商的任何小数部分。如果除数为零或商溢出，该操作将终止。</p>
<pre><code class="language-move">    public fun divide_u64(val: u64, divisor: FixedPoint32): u64;
</code></pre>
<hr />
<p>Create a fixed-point value from a rational number specified by its numerator and denominator. Calling this function should be preferred for using <code>fixed_point32::create_from_raw_value</code> which is also available. This will abort if the denominator is zero. It will also abort if the numerator is nonzero and the ratio is not in the range $2^{-32}\ldots2^{32}-1$. When specifying decimal fractions, be careful about rounding errors: if you round to display $N$ digits after the decimal point, you can use a denominator of $10^N$ to avoid numbers where the very small imprecision in the binary representation could change the rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013.</p>
<p>根据分子和分母指定的有理数创建定点值。如果<code>fixed_point32::create_from_raw_value</code>函数可用，应优先使用。如果分母为零，该操作将终止。如果分子非零且比值不在$2^{-32}\ldots2^{32}-1$范围内，该操作将终止。指定小数时，请注意四舍五入错误：如果要对小数点后$N$位进行四舍五入，则可以用$10^N$做分母，这样就能避免精确度丢失问题，例如，0.0125将四舍五入到0.012而不是0.013。</p>
<pre><code class="language-move">    public fun create_from_rational(numerator: u64, denominator: u64): FixedPoint32;
</code></pre>
<hr />
<p>Create a fixedpoint value from a raw <code>u64</code> value.</p>
<p>通过<code>u64</code>原始值创建一个定点值。</p>
<pre><code class="language-move">    public fun create_from_raw_value(value: u64): FixedPoint32;
</code></pre>
<hr />
<p>Returns <code>true</code> if the decimal value of <code>num</code> is equal to zero.</p>
<p>如果<code>num</code>的十进制值等于0，则返回<code>true</code>。</p>
<pre><code class="language-move">    public fun is_zero(num: FixedPoint32): bool;
</code></pre>
<hr />
<p>Accessor for the raw <code>u64</code> value. Other less common operations, such as adding or subtracting <code>FixedPoint32</code> values, can be done using the raw values directly.</p>
<p>获取<code>u64</code>原始值的方法。其他不太常见的操作，例如添加或减去<code>FixedPoint32</code>值，可以直接使用原始值来完成。</p>
<pre><code class="language-move">    public fun get_raw_value(num: FixedPoint32): u64;
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-编码约定"><a class="header" href="#move-编码约定">Move 编码约定</a></h1>
<p>本节列出了 Move 团队认为有用的一些基本的 Move 编码约定。这些只是建议，如果你喜欢其他格式指南和约定，你可以随时使用它们。</p>
<h2 id="命名-1"><a class="header" href="#命名-1">命名</a></h2>
<ul>
<li><strong>模块名称</strong>：应该使用小写的蛇形命名法，例如：<code>fixed_point32</code>、<code>vector</code>。</li>
<li><strong>类型名称</strong>：如果不是原生数据类型，则应使用驼峰命名法，例如：<code>Coin</code>、<code>RoleId</code>。</li>
<li><strong>函数名称</strong>：应该使用小写的蛇形命名法，例如：<code>destroy_empty</code>。</li>
<li><strong>常量名称</strong>：应该使用大写的蛇形命名法，例如：<code>REQUIRES_CAPABILITY</code>。</li>
<li>泛型类型应该具备描述性，当然在适当的情况下也可以是反描述性的，例如：Vector 泛型类型的参数可以是 <code>T</code> 或 <code>Element</code>。大多数情况下，模块中的“主”类型命名应该与模块名相同，例如：<code>option::Option</code>，<code>fixed_point32::FixedPoint32</code>。</li>
<li><strong>模块文件名称</strong>：应该与模块名相同，例如：<code>Option.move</code>。</li>
<li><strong>脚本文件名称</strong>：应该使用小写的蛇形命名法，并且应该与脚本中的“主”函数名匹配。</li>
<li><strong>混合文件名称</strong>：如果文件包含多个模块和/或脚本，文件命名应该使用小写的蛇形命名法，并且不需要与内部的任何特定模块/脚本名匹配。</li>
</ul>
<h2 id="导入"><a class="header" href="#导入">导入</a></h2>
<ul>
<li>所有模块的 <code>use</code> 语句都应该位于模块的顶部。</li>
<li>函数应该从声明它们的模块中完全限定地导入和使用, 而不是在顶部导入。</li>
<li>类型应该在顶部导入。如果存在名称冲突，应使用 <code>as</code> 在本地适当地重命名类型。</li>
</ul>
<p>例如，如果有一个模块：</p>
<pre><code class="language-move">module 0x1::foo {
    struct Foo { }
    const CONST_FOO: u64 = 0;
    public fun do_foo(): Foo { Foo{} }
    ...
}
</code></pre>
<p>此时将被导入并使用：</p>
<pre><code class="language-move">module 0x1::bar {
    use 0x1::foo::{Self, Foo};

    public fun do_bar(x: u64): Foo {
        if (x == 10) {
            foo::do_foo()
        } else {
            abort 0
        }
    }
    ...
}
</code></pre>
<p>并且，如果在导入两个模块时存在本地名称冲突：</p>
<pre><code class="language-move">module other_foo {
    struct Foo {}
    ...
}

module 0x1::importer {
    use 0x1::other_foo::Foo as OtherFoo;
    use 0x1::foo::Foo;
    ...
}
</code></pre>
<h2 id="注释"><a class="header" href="#注释">注释</a></h2>
<ul>
<li>每个模块、结构体和公共函数声明都应该有对应的注释。</li>
<li>Move 有文档注释 <code>///</code>，常规单行注释 <code>//</code>，块注释 <code>/* */</code>，和块文档注释 <code>/** */</code>。</li>
</ul>
<h2 id="格式化"><a class="header" href="#格式化">格式化</a></h2>
<p>Move 团队计划编写一个自动格式化程序来执行格式化约定。然而，在此期间：</p>
<ul>
<li>除 <code>script</code> 和 <code>address</code> 块外，其他的内容应使用四个空格的缩进。</li>
<li>每行代码，如果超过 100 个字符，应该换行。</li>
<li>结构体和常量应该在模块中的所有函数之前声明。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-book-中文版"><a class="header" href="#move-book-中文版">Move Book 中文版</a></h1>
<p>区块链技术的发展经历了两个阶段，比特币（BTC）开启了<em>区块链1.0时代</em>，以太坊（ETH）开启了<em>区块链2.0时代</em>。
以太坊的出现为区块链带来了<em>智能合约</em>这一关键技术，让区块链不只停留在记账这一单的目的，而是带来更多的应用拓展性。
遗憾的是，智能合约如同一把双刃剑，在带来众多丰富功能拓展的同时，也容易让智能合约开发者无意间引入不安全的代码，让链的资产受到威胁。</p>
<p>编写简单、安全、易部署的智能合约应该是<em>区块链3.0时代</em>应该关注的重点，<strong>面向资源编程</strong>的 <a href="https://github.com/move-language/move">Move 语言</a>，无疑给这个问题提供了一个很好的解决方案。</p>
<p>本书是 <a href="https://move-language.github.io/move/">Move Book</a> 的中文版。</p>
<h2 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h2>
<p>本书使用 <a href="https://rust-lang.github.io/mdBook/">mdBook</a> 构建。</p>
<ol>
<li>使用 Cargo 安装 mdBook：</li>
</ol>
<pre><code class="language-shell">cargo install mdbook
cargo install mdbook-i18n
</code></pre>
<ol start="2">
<li>下载</li>
</ol>
<pre><code class="language-shell">git clone https://github.com/move-language/move.git
</code></pre>
<ol start="3">
<li>构建并预览</li>
</ol>
<pre><code class="language-shell">cd language/documentation/book
mdbook serve --open
</code></pre>
<h1 id="参与贡献"><a class="header" href="#参与贡献">参与贡献</a></h1>
<h2 id="如何参与"><a class="header" href="#如何参与">如何参与</a></h2>
<p>《Move Book 中文版》翻译工作还在持续进行中，如果你愿意贡献你的一份力量，欢迎提交 <a href="https://github.com/move-language/move">pr</a> 或 issue。</p>
<p>在贡献之前请阅读<a href="https://github.com/move-language/move/blob/main/CONTRIBUTING.md">官方的贡献指南</a>和《Move Book 中文版》的贡献指南(如下)。</p>
<details>
<summary>《Move Book 中文版》的贡献指南</summary>
<p>本翻译项目由 <a href="https://github.com/move-cc"><em>Move 中文社区（MoveCC）</em></a><a href="https://github.com/move-language/move/issues/353">发起</a>，并与 <a href="https://github.com/move-dao">MoveDAO 社区</a>共同初步完善。
目前工作仍在进行中！</p>
<p>欢迎所有对 Move 感兴趣的朋友一起加入到《Move Book 中文版》的翻译工作中。</p>
<p>感谢您有兴趣为 <strong>《Move Book 中文版》</strong> 做出贡献！有很多方法可以做出贡献，我们感谢所有这些方式。</p>
<h3 id="提交-pr-的-commits-格式"><a class="header" href="#提交-pr-的-commits-格式">提交 PR 的 Commits 格式</a></h3>
<pre><code class="language-text">[move-book-zh] 关于这个 PR 的描述信息
</code></pre>
<h3 id="文档规范"><a class="header" href="#文档规范">文档规范</a></h3>
<p>请参考：<a href="https://github.com/ruanyf/document-style-guide">中文技术文档的写作规范</a></p>
<h4 id="断句"><a class="header" href="#断句">断句</a></h4>
<p>本书使用 Markdown 作为源文件，使用 <a href="https://github.com/rust-lang/mdBook">mdBook</a> 作为渲染引擎。</p>
<p>由于中英文有所区别，换行后渲染引擎会自动追加一个空格。为了优化视觉体验，中文一个段落内不必换行，保持中文的段内容为一个物理行。</p>
<p>英文是由空格分隔的文本，所以不存在上述问题。</p>
<h4 id="中英文混排规范"><a class="header" href="#中英文混排规范">中英文混排规范</a></h4>
<p>文中出现中英文混排时，中文与英文之间需要添加一个空格。如果英文单词结尾，此时单词与标点符号之间不添加空格。</p>
<h4 id="数字规范"><a class="header" href="#数字规范">数字规范</a></h4>
<p>数字之间需要添加一个空格，如果数字带有英文单位，那么数字与英文单位之间不能添加空格。如果数字后带有中文单位，需要添加一个空格。</p>
<pre><code class="language-text">正确：如果一个 1s 的帧被划分为 10 个时隙，每个时隙为 100ms。

错误：如果一个1s的帧被划分为10个时隙，每个时隙为100ms。

错误：如果一个 1 s 的帧被划分为10个时隙，每个时隙为 100 ms。
</code></pre>
<h4 id="逗号问题"><a class="header" href="#逗号问题">逗号问题</a></h4>
<p>英文中，没有顿号这种标点符号，逗号常用分隔并列的句子成分或结构。</p>
<p>英文中，像 <code>and</code> 并列词的前面通常会有一个 <code>,</code>，但在中文里表示对象之间的并列关系时，<code>和</code>的前面不能带逗号。</p>
<pre><code class="language-text">War, famine, and flood are terrible.
战争, 饥荒和洪水都是很可怕的。
</code></pre>
<h4 id="冒号和逗号的使用场景规范"><a class="header" href="#冒号和逗号的使用场景规范">冒号和逗号的使用场景规范</a></h4>
<p>冒号通常用在“问、答、说、指出、宣布、证明、表明、例如”一类动词后面，表示提起下文。
如果在较短的提示句子中，需要将 <code>：</code> 改为 <code>，</code>；如果提示内容比较多，则使用 <code>：</code> 来提起下文：</p>
<p>示例1，提起的内容短少：</p>
<pre><code class="language-text">十六进制字符串是以 x 为前缀的带引号的字符串文字，例如x'48656C6C6F210A'
</code></pre>
<p>示例2，提起的内容多：</p>
<pre><code class="language-text">在这些情况下，vector 的类型是从元素类型或从动态数组的使用上推断出来的。如果无法推断类型或者只是为了更清楚地表示，则可以显式指定类型：

vector&lt;T&gt;[]: vector&lt;T&gt;
vector&lt;T&gt;[e1, ..., en]: vector&lt;T&gt;
</code></pre>
</details>
<h2 id="贡献人员-"><a class="header" href="#贡献人员-">贡献人员 ✨</a></h2>
<p>感谢以下小伙伴为中文版做出贡献 (<a href="https://allcontributors.org/docs/en/emoji-key">emoji key</a>):</p>
<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://github.com/Kusou1"><img src="https://avatars.githubusercontent.com/u/57334674?v=4?s=100" width="100px;" alt=""/><br /><sub><b>zhang</b></sub></a><br /><a href="https://github.com/move-dao/move-book-zh/commits?author=Kusou1" title="Code">💻</a> <a href="https://github.com/move-dao/move-book-zh/commits?author=Kusou1" title="Documentation">📖</a> <a href="contribute.html#translation-Kusou1" title="Translation">🌍</a> <a href="contribute.html#infra-Kusou1" title="Infrastructure (Hosting, Build-Tools, etc)">🚇</a></td>
    <td align="center"><a href="https://github.com/ruy1su"><img src="https://avatars.githubusercontent.com/u/9391802?v=4?s=100" width="100px;" alt=""/><br /><sub><b>ruyisu</b></sub></a><br /><a href="https://github.com/move-dao/move-book-zh/commits?author=ruy1su" title="Code">💻</a> <a href="contribute.html#translation-ruy1su" title="Translation">🌍</a> <a href="https://github.com/move-dao/move-book-zh/commits?author=ruy1su" title="Documentation">📖</a> <a href="https://github.com/move-dao/move-book-zh/pulls?q=is%3Apr+reviewed-by%3Aruy1su" title="Reviewed Pull Requests">🚇</a></td>
    <td align="center"><a href="https://github.com/lshoo"><img src="https://avatars.githubusercontent.com/u/670440?v=4?s=100" width="100px;" alt=""/><br /><sub><b>lshoo</b></sub></a><br /><a href="https://github.com/move-dao/move-book-zh/commits?author=lshoo" title="Code">💻</a> <a href="contribute.html#translation-lshoo" title="Translation">🌍</a> <a href="https://github.com/move-dao/move-book-zh/commits?author=lshoo" title="Documentation">📖</a> <a href="contribute.html#ideas-lshoo" title="Ideas, Planning, & Feedback">🤔</a> <a href="https://github.com/move-dao/move-book-zh/pulls?q=is%3Apr+reviewed-by%3Alshoo" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="https://github.com/Container-00"><img src="https://avatars.githubusercontent.com/u/61052480?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Container</b></sub></a><br /><a href="https://github.com/move-dao/move-book-zh/commits?author=Container-00" title="Code">💻</a> <a href="contribute.html#translation-Container-00" title="Translation">🌍</a> <a href="https://github.com/move-dao/move-book-zh/commits?author=Container-00" title="Documentation">📖</a> <a href="https://github.com/move-dao/move-book-zh/pulls?q=is%3Apr+reviewed-by%3AContainer-00" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="https://github.com/nosalt99"><img src="https://avatars.githubusercontent.com/u/22558493?v=4?s=100" width="100px;" alt=""/><br /><sub><b>nosalt</b></sub></a><br /><a href="https://github.com/move-dao/move-book-zh/commits?author=nosalt99" title="Code">💻</a> <a href="contribute.html#translation-nosalt99" title="Translation">🌍</a> <a href="https://github.com/move-dao/move-book-zh/commits?author=nosalt99" title="Documentation">📖</a> <a href="contribute.html#infra-nosalt99" title="Infrastructure (Hosting, Build-Tools, etc)">🚇</a></td>
    <td align="center"><a href="https://github.com/geometryolife"><img src="https://avatars.githubusercontent.com/u/54882546?v=4?s=100" width="100px;" alt=""/><br /><sub><b>geometryolife</b></sub></a><br /><a href="https://github.com/move-language/move/commits?author=geometryolife" title="Code">💻</a> <a href="contribute.html#translation-geometryolife" title="Translation">🌍</a> <a href="contribute.html#talk-geometryolife" title="Talks">📢</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/666thi"><img src="https://avatars.githubusercontent.com/u/109965699?v=4?s=100" width="100px;" alt=""/><br /><sub><b>666thi</b></sub></a><br /><a href="https://github.com/move-dao/move-book-zh/commits?author=666thi" title="Code">💻</a> <a href="contribute.html#translation-666thi" title="Translation">🌍</a> <a href="contribute.html#talk-666thi" title="Talks">📢</a></td>
    <td align="center"><a href="https://github.com/MagicGordon"><img src="https://avatars.githubusercontent.com/u/19465870?v=4?s=100" width="100px;" alt=""/><br /><sub><b>MagicGordon</b></sub></a><br /><a href="https://github.com/move-dao/move-book-zh/commits?author=MagicGordon" title="Code">💻</a> <a href="contribute.html#translation-MagicGordon" title="Translation">🌍</a> <a href="contribute.html#talk-MagicGordon" title="Talks">📢</a></td>
    <td align="center"><a href="https://github.com/xixifusi1984"><img src="https://avatars.githubusercontent.com/u/39210551?v=4?s=100" width="100px;" alt=""/><br /><sub><b>xixifusi1984</b></sub></a><br /><a href="https://github.com/move-dao/move-book-zh/commits?author=xixifusi1984" title="Code">💻</a> <a href="contribute.html#translation-xixifusi1984" title="Translation">🌍</a> <a href="contribute.html#talk-xixifusi1984" title="Talks">📢</a></td>
    <td align="center"><a href="https://github.com/yvvw"><img src="https://avatars.githubusercontent.com/u/15168529?v=4?s=100" width="100px;" alt=""/><br /><sub><b>yvvw</b></sub></a><br /><a href="https://github.com/move-dao/move-book-zh/commits?author=yvvw" title="Code">💻</a> <a href="contribute.html#translation-yvvw" title="Translation">🌍</a> <a href="contribute.html#talk-yvvw" title="Talks">📢</a></td>
    <td align="center"><a href="https://github.com/xiaochuan891102"><img src="https://avatars.githubusercontent.com/u/109952533?v=4?s=100" width="100px;" alt=""/><br /><sub><b>xiaochuan891102</b></sub></a><br /><a href="https://github.com/move-dao/move-book-zh/commits?author=xiaochuan891102" title="Code">💻</a> <a href="contribute.html#translation-xiaochuan891102" title="Translation">🌍</a> <a href="contribute.html#talk-xiaochuan891102" title="Talks">📢</a></td>
    <td align="center"><a href="https://github.com/stephenLee"><img src="https://avatars.githubusercontent.com/u/1144508?v=4?s=100" width="100px;" alt=""/><br /><sub><b>stephenLee</b></sub></a><br /><a href="https://github.com/move-dao/move-book-zh/commits?author=stephenLee" title="Code">💻</a> <a href="contribute.html#translation-stephenLee" title="Translation">🌍</a> <a href="contribute.html#talk-stephenLee" title="Talks">📢</a></td>
  </tr>
</table>
<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->
<!-- ALL-CONTRIBUTORS-LIST:END -->
<details>
<summary>各章节译者</summary>
<div class="table-wrapper"><table><thead><tr><th></th><th>章节</th><th>译者</th><th>校对</th></tr></thead><tbody>
<tr><td>0</td><td>Intoduction</td><td>Tom</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>1</td><td>Modules and Scripts</td><td><a href="https://github.com/kusou1">@Kusou1</a></td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>2</td><td>Move Tutorial</td><td>loadi、<a href="https://github.com/leego">@leego</a></td><td><a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>3</td><td>Integers</td><td>Tom</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>4</td><td>Bool</td><td>Tom</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>5</td><td>Address</td><td>(<a href="https://github.com/stephenLee">@stephenLee</a>)</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>6</td><td>Vector</td><td>(<a href="https://github.com/stephenLee">@stephenLee</a>)</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>7</td><td>Signer</td><td>(<a href="https://github.com/stephenLee">@stephenLee</a>)</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>8</td><td>References</td><td>container</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>9</td><td>Tuples and Unit</td><td>container</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>10</td><td>Local Variables and Scopes</td><td>@ruyisu</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>11</td><td>Equality</td><td>@ruyisu</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>12</td><td>Abort and Assert</td><td>@ruyisu</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>13</td><td>Conditionals</td><td><a href="https://github.com/kusou1">@Kusou1</a></td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>14</td><td>While and Loop</td><td><a href="https://github.com/kusou1">@Kusou1</a></td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>15</td><td>Functions</td><td>@nosalt99</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>16</td><td>Structs and Resource</td><td>@nosalt99</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>17</td><td>Constants</td><td>@nosalt99</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>18</td><td>Generics</td><td>小川</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>19</td><td>Type Abilities</td><td>小川</td><td><a href="https://github.com/lshoo">@lshoo</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>20</td><td>Uses and Aliases</td><td>小川</td><td><a href="https://github.com/ruy1su">@ruyisu</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>21</td><td>Friends</td><td>@xiaochuan891102</td><td><a href="https://github.com/ruy1su">@ruyisu</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>22</td><td>Packages</td><td>@xiaochuan891102</td><td><a href="https://github.com/ruy1su">@ruyisu</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>23</td><td>Unit Test</td><td><a href="https://github.com/yvvw">@yvvw</a></td><td><a href="https://github.com/ruy1su">@ruyisu</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>24</td><td>Global Storage Structure</td><td><a href="https://github.com/yvvw">@yvvw</a></td><td><a href="https://github.com/ruy1su">@ruyisu</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>25</td><td>Global Storage Operators</td><td><a href="https://github.com/yvvw">@yvvw</a></td><td><a href="https://github.com/ruy1su">@ruyisu</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>26</td><td>Standard Library</td><td>@MagicGordon</td><td><a href="https://github.com/ruy1su">@ruyisu</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
<tr><td>27</td><td>Coding Conventions</td><td>@MagicGordon</td><td><a href="https://github.com/ruy1su">@ruyisu</a>、<a href="https://github.com/geometryolife">@Joe Chen</a></td></tr>
</tbody></table>
</div></details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>

        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

        <script type="text/javascript">
        var langs = [
            'en',
            'zh'
        ];

        (function langs() {
            var html = document.querySelector('html');
            var langToggleButton = document.getElementById('lang-toggle');
            var langPopup = document.getElementById('lang-list');

            function showLangs() {
                langPopup.style.display = 'block';
                langToggleButton.setAttribute('aria-expanded', true);
            }

            function hideLangs() {
                langPopup.style.display = 'none';
                langToggleButton.setAttribute('aria-expanded', false);
                langToggleButton.focus();
            }

            langToggleButton.addEventListener('click', function () {
                if (langPopup.style.display === 'block') {
                    hideLangs();
                } else {
                    showLangs();
                }
            });

            langPopup.addEventListener('click', function (e) {
                var lang = e.target.id || e.target.parentElement.id;
                window.location.pathname = window.location.pathname
                    .split('/')
                    .map((s, idx) => {
                        return idx == 2 ? lang : s;
                    })
                    .join('/');
            });

            langPopup.addEventListener('focusout', function(e) {
                // e.relatedTarget is null in Safari and Firefox on macOS (see workaround below)
                if (!!e.relatedTarget && !langToggleButton.contains(e.relatedTarget) && !langPopup.contains(e.relatedTarget)) {
                    hideLangs();
                }
            });

            // Should not be needed, but it works around an issue on macOS & iOS: https://github.com/rust-lang-nursery/mdBook/issues/628
            document.addEventListener('click', function(e) {
                if (langPopup.style.display === 'block' && !langToggleButton.contains(e.target) && !langPopup.contains(e.target)) {
                    hideLangs();
                }
            });

        })();
        </script>


    </body>
</html>
