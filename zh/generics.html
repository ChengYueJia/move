<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>泛型（Generics） - 《Move Book 中文版》</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">引言（Introduction）</a></li><li class="chapter-item expanded "><a href="modules-and-scripts.html"><strong aria-hidden="true">1.</strong> 模块和脚本（Modules and Scripts）</a></li><li class="chapter-item expanded "><a href="move-tutorial.html"><strong aria-hidden="true">2.</strong> Move 教程（Move Tutorial）</a></li><li class="chapter-item expanded "><a href="integers.html"><strong aria-hidden="true">3.</strong> 整数（Integers）</a></li><li class="chapter-item expanded "><a href="bool.html"><strong aria-hidden="true">4.</strong> 布尔类型（Bool）</a></li><li class="chapter-item expanded "><a href="address.html"><strong aria-hidden="true">5.</strong> 地址（Address）</a></li><li class="chapter-item expanded "><a href="vector.html"><strong aria-hidden="true">6.</strong> 向量（Vector）</a></li><li class="chapter-item expanded "><a href="signer.html"><strong aria-hidden="true">7.</strong> 签名（Signer）</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">8.</strong> 引用（References）</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">9.</strong> 元组和单值（Tuples and Unit）</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">10.</strong> 局部变量和作用域（Local Variables and Scopes）</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">11.</strong> 等式（Equality）</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">12.</strong> 中止和断言（Abort and Assert）</a></li><li class="chapter-item expanded "><a href="conditionals.html"><strong aria-hidden="true">13.</strong> 条件语句（Conditionals）</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">14.</strong> 循环（While and Loop）</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">15.</strong> 函数（Functions）</a></li><li class="chapter-item expanded "><a href="structs-and-resources.html"><strong aria-hidden="true">16.</strong> 结构体和资源（Structs and Resources）</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">17.</strong> 常量（Constants）</a></li><li class="chapter-item expanded "><a href="generics.html" class="active"><strong aria-hidden="true">18.</strong> 泛型（Generics）</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">19.</strong> 类型能力（Type Abilities）</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">20.</strong> 导入和别名（Uses and Aliases）</a></li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">21.</strong> 友元函数（Friends）</a></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">22.</strong> 程序包（Packages）</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">23.</strong> 单元测试（Unit Tests）</a></li><li class="chapter-item expanded "><a href="global-storage-structure.html"><strong aria-hidden="true">24.</strong> 全局存储结构（Global Storage Structure）</a></li><li class="chapter-item expanded "><a href="global-storage-operators.html"><strong aria-hidden="true">25.</strong> 全局存储操作（Global Storage Operators）</a></li><li class="chapter-item expanded "><a href="standard-library.html"><strong aria-hidden="true">26.</strong> 标准库（Standard Library）</a></li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">27.</strong> Move 编码约定（Coding Conventions）</a></li><li class="chapter-item expanded "><a href="contribute.html"><strong aria-hidden="true">28.</strong> 中文版贡献指南</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">《Move Book 中文版》</h1>

                    <div class="right-buttons">
                        <button id="lang-toggle" class="icon-button" type="button" title="Change language" aria-label="Change language" aria-haspopup="true" aria-expanded="false" aria-controls="lang-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="lang-list" class="theme-popup" style="left: auto;" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="en">English</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="zh">Chinese</button></li>
                        </ul>
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="泛型-generics"><a class="header" href="#泛型-generics">泛型 (generics)</a></h1>
<p>Generics can be used to define functions and structs over different input data types. This language feature is sometimes referred to as <em>parametric polymorphism</em>. In Move, we will often use the term generics interchangeably with type parameters and type arguments.</p>
<p>泛型可用于定义具有不同输入数据类型的函数和结构体。这种语言特性被称为参数多态。在 Move语言中，我们经常将交替使用术语泛型与类型参数和类型参数。</p>
<p>Generics are commonly used in library code, such as in vector, to declare code that works over any possible instantiation (that satisfies the specified constraints). In other frameworks, generic code can sometimes be used to interact with global storage many different ways that all still share the same implementation.</p>
<p>泛型通常用于库代码中，例如 <code>vector</code>，以声明适用于任何可实例化(满足指定约束)的代码。在其他框架中，泛型代码有时可用多种不同的方式与全局存储交互，这些方式有着相同的实现。</p>
<h2 id="声明类型参数-declaring-type-parameters"><a class="header" href="#声明类型参数-declaring-type-parameters">声明类型参数 (Declaring Type Parameters)</a></h2>
<p>Both functions and structs can take a list of type parameters in their signatures, enclosed by a pair of angle brackets <code>&lt;...&gt;</code> .</p>
<p>函数和结构体都可以在其签名中采用类型参数列表，由一对尖括号括起来 <code>&lt;...&gt;</code> 。</p>
<h3 id="泛型函数-generic-functions"><a class="header" href="#泛型函数-generic-functions">泛型函数 (Generic Functions)</a></h3>
<p>Type parameters for functions are placed after the function name and before the (value) parameter list. The following code defines a generic identity function that takes a value of any type and returns that value unchanged.</p>
<p>函数的类型参数放在函数名称之后和(值)参数列表之前。以下代码定义了一个名为id的泛型函数，该函数接受任何类型的值并返回原值。</p>
<pre><code class="language-move">fun id&lt;T&gt;(x: T): T {
    // this type annotation is unnecessary but valid
    (x: T)
}
</code></pre>
<p>Once defined, the type parameter <code>T</code> can be used in parameter types, return types, and inside the function body.</p>
<p>一旦定义，类型参数 <code>T</code> 就可以在参数类型、返回类型和函数体内使用。</p>
<h3 id="泛型结构体-generic-structs"><a class="header" href="#泛型结构体-generic-structs">泛型结构体 (Generic Structs)</a></h3>
<p>Type parameters for structs are placed after the struct name, and can be used to name the types of the fields.</p>
<p>结构体的类型参数放在结构名称之后，并可用于命名字段的类型。</p>
<pre><code class="language-move">struct Foo&lt;T&gt; has copy, drop { x: T }

struct Bar&lt;T1, T2&gt; has copy, drop {
    x: T1,
    y: vector&lt;T2&gt;,
}
</code></pre>
<p><a href="#unused-type-parameters">Note that type parameters do not have to be used</a></p>
<p>请注意，<a href="#unused-type-parameters">未使用的类型参数</a></p>
<h2 id="类型参数-type-arguments"><a class="header" href="#类型参数-type-arguments">类型参数 (Type Arguments)</a></h2>
<h3 id="调用泛型函数-calling-generic-functions"><a class="header" href="#调用泛型函数-calling-generic-functions">调用泛型函数 (Calling Generic Functions)</a></h3>
<p>When calling a generic function, one can specify the type arguments for the function's type parameters in a list enclosed by a pair of angle brackets.</p>
<p>调用泛型函数时，可以在由一对尖括号括起来的列表中指定函数类型参数。</p>
<pre><code class="language-move">fun foo() {
    let x = id&lt;bool&gt;(true);
}
</code></pre>
<p>If you do not specify the type arguments, Move's <a href="#type-inference">type inference</a> will supply them for you.</p>
<p>如果您不指定类型参数，Move语言的<a href="#type-inference">类型推断</a>功能将为您匹配正确的类型</p>
<h3 id="使用泛型结构-using-generic-structs"><a class="header" href="#使用泛型结构-using-generic-structs">使用泛型结构 (Using Generic Structs)</a></h3>
<p>Similarly, one can attach a list of type arguments for the struct's type parameters when constructing or destructing values of generic types.</p>
<p>类似地，在构造或销毁泛型类型的值时，可以为结构体的类型参数附加一个参数列表。</p>
<pre><code class="language-move">fun foo() {
    let foo = Foo&lt;bool&gt; { x: true };
    let Foo&lt;bool&gt; { x } = foo;
}
</code></pre>
<p>If you do not specify the type arguments, Move's <a href="#type-inference">type inference</a> will supply them for you.</p>
<p>如果您不指定类型参数，Move 语言的<a href="#type-inference">类型推断</a>功能将为您自动补充(supply)。</p>
<h3 id="类型参数不匹配-type-argument-mismatch"><a class="header" href="#类型参数不匹配-type-argument-mismatch">类型参数不匹配 (Type Argument Mismatch)</a></h3>
<p>If you specify the type arguments and they conflict with the actual values supplied, an error will be given</p>
<p>如果您指定类型参数与实际提供的值不匹配，则会报错</p>
<pre><code class="language-move">fun foo() {
    let x = id&lt;u64&gt;(true); // error! true is not a u64
}
</code></pre>
<p>同样地</p>
<pre><code class="language-move">fun foo() {
    let foo = Foo&lt;bool&gt; { x: 0 }; // error! 0 is not a bool
    let Foo&lt;address&gt; { x } = foo; // error! bool is incompatible with address
}
</code></pre>
<h2 id="type-inference-类型推断"><a class="header" href="#type-inference-类型推断">Type Inference (类型推断)</a></h2>
<p>In most cases, the Move compiler will be able to infer the type arguments so you don't have to write them down explicitly. Here's what the examples above would look like if we omit the type arguments.</p>
<p>在大多数情况下，Move 编译器能够推断类型参数，因此您不必显式地写下它们。这是上面例子中省略类型参数写法的示例。</p>
<pre><code class="language-move">fun foo() {
    let x = id(true);
    //        ^ &lt;bool&gt; is inferred

    let foo = Foo { x: true };
    //           ^ &lt;bool&gt; is inferred

    let Foo { x } = foo;
    //     ^ &lt;bool&gt; is inferred
}
</code></pre>
<p>Note: when the compiler is unable to infer the types, you'll need annotate them manually. A common scenario is to call a function with type parameters appearing only at return positions.</p>
<p>注意：当编译器无法推断类型时，您需要手动标注它们(类型参数)。一个常见的场景是调用一个类型参数只出现在返回位置的函数。</p>
<pre><code class="language-move">address 0x2 {
    module m {
        using std::vector;

        fun foo() {
            // let v = vector::new();
            //                    ^ The compiler cannot figure out the element type.

            let v = vector::new&lt;u64&gt;();
            //                 ^~~~~ Must annotate manually.
        }
    }
}
</code></pre>
<p>However, the compiler will be able to infer the type if that return value is used later in that function</p>
<p>但是，如果稍后在该函数中使用该返回值，编译器将能够推断其类型。</p>
<pre><code class="language-move">address 0x2 {
    module m {
        using std::vector;

        fun foo() {
            let v = vector::new();
            //                 ^ &lt;u64&gt; is inferred
            vector::push_back(&amp;mut v, 42);
        }
    }
}
</code></pre>
<h2 id="unused-type-parameters-未使用的类型参数"><a class="header" href="#unused-type-parameters-未使用的类型参数">Unused Type Parameters (未使用的类型参数)</a></h2>
<p>For a struct definition, an unused type parameter is one that
does not appear in any field defined in the struct, but is checked statically at compile time.
Move allows unused type parameters so the following struct definition is valid:</p>
<p>对于结构体定义，未使用的类型参数是没有出现在结构体中定义的任何字段中，但在编译时会静态检查的类型参数。Move语言允许未使用的类型参数，因此以下结构定义是有效的：</p>
<pre><code class="language-move">struct Foo&lt;T&gt; {
    foo: u64
}
</code></pre>
<p>This can be convenient when modeling certain concepts. Here is an example:</p>
<p>这在对某些概念进行建模时会很方便。这是一个例子：</p>
<pre><code class="language-move">address 0x2 {
    module m {
        // Currency Specifiers
        struct Currency1 {}
        struct Currency2 {}

        // A generic coin type that can be instantiated using a currency
        // specifier type.
        //   e.g. Coin&lt;Currency1&gt;, Coin&lt;Currency2&gt; etc.
        struct Coin&lt;Currency&gt; has store {
            value: u64
        }

        // Write code generically about all currencies
        public fun mint_generic&lt;Currency&gt;(value: u64): Coin&lt;Currency&gt; {
            Coin { value }
        }

        // Write code concretely about one currency
        public fun mint_concrete(value: u64): Coin&lt;Currency1&gt; {
            Coin { value }
        }
    }
}
</code></pre>
<p>In this example, <code>struct Coin&lt;Currency&gt;</code> is generic on the <code>Currency</code> type parameter,
which specifies the currency of the coin and allows code to be written either generically on any currency or
concretely on a specific currency.
This genericity applies even when the <code>Currency</code> type parameter does not appear in any of the fields defined in <code>Coin</code>.</p>
<p>在此示例中， <code>struct Coin&lt;Currency&gt;</code> 是类型参数为 <code>Currency</code> 的泛型结构体，它指定 <code>Coin</code> 的类型参数是 <code>Currency</code>，这样就允许代码选择是使用任意类型 <code>Currency</code> 或者是指定的具体类型 <code>Currency</code> 。即使 <code>Currency</code> 类型参数没有出现在定义的任何字段中，这种泛型性也适用结构体 <code>Coin</code>。</p>
<h3 id="phantom-type-parameters"><a class="header" href="#phantom-type-parameters">Phantom Type Parameters</a></h3>
<p>In the example above, although <code>struct Coin</code> asks for the <code>store</code> ability, neither <code>Coin&lt;Currency1&gt;</code> nor <code>Coin&lt;Currency2&gt;</code> will have the <code>store</code> ability.
This is because of the rules for <a href="abilities.html#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a> and the fact that <code>Currency1</code> and <code>Currency2</code> don't have the <code>store</code> ability, despite the fact that they are not even used in the body of <code>struct Coin</code>.
This might cause some unpleasant consequences.
For example, we are unable to put <code>Coin&lt;Currency1&gt;</code> into a wallet in the global storage.</p>
<p>在上面的例子中，虽然 <code>struct Coin</code> 要求有 <code>store</code> 能力，但 <code>Coin&lt;Currency1&gt;</code> 和 <code>Coin&lt;Currency2&gt;</code> 都没有 <code>store</code> 能力。这是因为 <a href="./chatper_19_abilities.html#conditional-abilities-and-generic-types">条件能力与泛型类型</a>的规则, 而实际上 <code>Currency1</code>和 <code>Currency2</code> 本身都没有 <code>store</code> 能力，尽管它们甚至没有在<code>struct Coin</code> 的主体中使用. 这可能会导致一些不好的后果。例如，我们无法将 <code>Coin&lt;Currency1&gt;</code> 放入全局存储的一个钱包中。</p>
<p>One possible solution would be to add spurious ability annotations to <code>Currency1</code> and <code>Currency2</code> (i.e., <code>struct Currency1 has store {}</code>).
But, this might lead to bugs or security vulnerabilities because it weakens the types with unnecessary ability declarations.
For example, we would never expect a resource in the global storage to have a field in type <code>Currency1</code>, but this would be possible with the spurious <code>store</code> ability.
Moreover, the spurious annotations would be infectious, requiring many functions generic on the unused type parameter to also include the necessary constraints.</p>
<p>一种可能的解决方案是向 <code>Currency1</code> 和 <code>Currency2</code> 添加虚假能力标注(例如：<code>struct Currency1 has store {}</code>) 。但是，这可能会导致 bugs 或安全漏洞，因为它削弱了类型安全，声明了不必要的能力。例如，我们永远不会期望全局存储中的资源具有 <code>Currency1</code> 类型的字段，但这对于虚假 <code>store</code> 能力是可能发生的。
此外，虚假标注具有传染性，需要在许多未使用类型参数的泛型函数上也引入必要的约束。</p>
<p>Phantom type parameters solve this problem. Unused type parameters can be marked as <em>phantom</em> type parameters,
which do not participate in the ability derivation for structs.
In this way, arguments to phantom type parameters are not considered when deriving the abilities for generic types, thus avoiding the need for spurious ability annotations.
For this relaxed rule to be sound, Move's type system guarantees that a parameter declared as phantom is either not used at all in the struct definition, or it is only used as an argument to type parameters also declared as phantom.</p>
<p>Phantom 类型参数解决了这个问题。未使用的类型参数可以标记为 <em>phantom</em> 类型参数，不参与结构体的能力推导。这样，在派生泛型类型的能力时，不考虑 phantom type 的参数，从而避免了对虚假能力标注的需要。为了使这个宽松的规则合理，Move 的类型系统保证声明为 <code>phantom</code> 的参数要么不在结构定义中使用，要么仅用作声明为 <code>phantom</code> 的类型参数的参数。</p>
<h4 id="声明-declaration"><a class="header" href="#声明-declaration">声明 (Declaration)</a></h4>
<p>In a struct definition a type parameter can be declared as phantom by adding the <code>phantom</code> keyword before its declaration.
If a type parameter is declared as phantom we say it is a phantom type parameter.
When defining a struct, Move's type checker ensures that every phantom type parameter is either not used inside the struct definition
or it is only used as an argument to a phantom type parameter.</p>
<p><code>phantom</code> 在结构定义中，可以通过在声明之前添加关键字来将类型参数声明为幻影。如果一个类型参数被声明为 phantom，我们就说它是 phantom 类型参数。
定义结构体时，Move语言的类型检查器确保每个 phantom 类型参数要么不在结构定义中使用，要么仅用作 phantom 类型参数的参数。</p>
<p>More formally, if a type is used as an argument to a phantom type parameter we say the type appears in <em>phantom position</em>.
With this definition in place, the rule for the correct use of phantom parameters can be specified as follows: <strong>A phantom type parameter can only appear in phantom position</strong>.</p>
<p>更正式地说，如果将类型用作 phantom 类型参数的输入参数，我们说该类型出现在 <em>phantom 位置</em>。有了这个定义，正确使用  phantom 参数的规则可以指定如下： ** phantom 类型参数只能出现在 phantom 位置**。</p>
<p>The following two examples show valid uses of phantom parameters.
In the first one, the parameter <code>T1</code> is not used at all inside the struct definition.
In the second one, the parameter <code>T1</code> is only used as an argument to a phantom type parameter.</p>
<p>以下两个示例显示了 phantom 参数的 合法用法。在第一个中，<code>T1</code> 在结构体定义中根本不使用参数。在第二种情况下，参数 <code>T1</code> 仅用作 phantom 类型参数的参数。</p>
<pre><code class="language-move">struct S1&lt;phantom T1, T2&gt; { f: u64 }
                  ^^
                  Ok: T1 does not appear inside the struct definition


struct S2&lt;phantom T1, T2&gt; { f: S1&lt;T1, T2&gt; }
                                  ^^
                                  Ok: T1 appears in phantom position
</code></pre>
<p>The following code shows examples of violations of the rule:</p>
<p>以下代码展示违反规则的示例：</p>
<pre><code class="language-move">struct S1&lt;phantom T&gt; { f: T }
                          ^
                          Error: Not a phantom position

struct S2&lt;T&gt; { f: T }

struct S3&lt;phantom T&gt; { f: S2&lt;T&gt; }
                             ^
                             Error: Not a phantom position
</code></pre>
<h4 id="实例化-instantiation"><a class="header" href="#实例化-instantiation">实例化 (Instantiation)</a></h4>
<p>When instantiating a struct, the arguments to phantom parameters are excluded when deriving the struct abilities.
For example, consider the following code:</p>
<p>实例化结构时，派生结构功能时会排除幻影参数的输入参数。例如，考虑以下代码：</p>
<pre><code class="language-move">struct S&lt;T1, phantom T2&gt; has copy { f: T1 }
struct NoCopy {}
struct HasCopy has copy {}
</code></pre>
<p>Consider now the type <code>S&lt;HasCopy, NoCopy&gt;</code>. Since <code>S</code> is defined with <code>copy</code> and all non-phantom arguments have copy then <code>S&lt;HasCopy, NoCopy&gt;</code> also has copy.</p>
<p>现在考虑类型 <code>S&lt;HasCopy, NoCopy&gt;</code>。由于 <code>S</code> 用 <code>copy</code> 定义，且所有非 phantom 参数  具有 <code>copy</code> 能力，所以 <code>S&lt;HasCopy, NoCopy&gt;</code> 也具有 <code>copy</code> 能力。</p>
<h4 id="具有能力约束的-phantom-类型参数-phantom-type-parameters-with-ability-constraints"><a class="header" href="#具有能力约束的-phantom-类型参数-phantom-type-parameters-with-ability-constraints">具有能力约束的 Phantom 类型参数 (Phantom Type Parameters with Ability Constraints)</a></h4>
<p>Ability constraints and phantom type parameters are orthogonal features in the sense that phantom parameters can be declared with ability constraints.
When instantiating a phantom type parameter with an ability constraint, the type argument has to satisfy that constraint, even though the parameter is phantom.
For example, the following definition is perfectly valid:</p>
<p>能力约束和 phantom 类型参数是正交特征，因此 phantom 参数声明时可以用能力进行约束。当使用能力约束实例化一个 phantom 类型参数时，类型参数必须满足该约束，即使参数是。
例如，以下定义是完全有效的：</p>
<pre><code class="language-move">struct S&lt;phantom T: copy&gt; {}
</code></pre>
<p>The usual restrictions apply and <code>T</code> can only be instantiated with arguments having <code>copy</code>.</p>
<p>应用(phantom)通常的限制并且 <code>T</code> 只能用具有 <code>copy</code> 的参数实例化。</p>
<h2 id="约束-constraints"><a class="header" href="#约束-constraints">约束 (Constraints)</a></h2>
<p>In the examples above, we have demonstrated how one can use type parameters to define &quot;unknown&quot; types that can be plugged in by callers at a later time. This however means the type system has little information about the type and has to perform checks in a very conservative way. In some sense, the type system must assume the worst case scenario for an unconstrained generic. Simply put, by default generic type parameters have no <a href="abilities.html">abilities</a>.</p>
<p>This is where constraints come into play: they offer a way to specify what properties these unknown types have so the type system can allow operations that would otherwise be unsafe.</p>
<p>在上面的例子中，我们已经演示了如何使用类型参数来定义“未知”类型，这些类型可以在稍后被调用者插入。然而，这意味着类型系统几乎没有关于类型的信息，并且必须以非常保守的方式执行检查。从某种意义上说，类型系统必须假设不受约束的泛型时的最坏场景。简单地说，默认情况下泛型类型参数没有<a href="abilities.html">能力</a>。</p>
<p>这就是约束发挥作用的地方：它们提供了一种方法来指定这些未知类型具有哪些属性，因此类型系统可以允许相应的操作，否则会不安全。</p>
<h3 id="声明约束-declaring-constraints"><a class="header" href="#声明约束-declaring-constraints">声明约束 (Declaring Constraints)</a></h3>
<p>Constraints can be imposed on type parameters using the following syntax.</p>
<p>可以使用以下语法对类型参数施加约束。</p>
<pre><code class="language-move">// T is the name of the type parameter
T: &lt;ability&gt; (+ &lt;ability&gt;)*
</code></pre>
<p>The <code>&lt;ability&gt;</code> can be any of the four <a href="abilities.html">abilities</a>, and a type parameter can be constrained with multiple <a href="abilities.html">abilities</a> at once. So all of the following would be valid type parameter declarations</p>
<p><code>&lt;ability&gt;</code> 可以是四种<a href="abilities.html">能力</a>中的任何一种，一个类型参数可以同时被多个能力约束。因此，以下所有内容都是有效的类型参数声明</p>
<pre><code class="language-move">T: copy
T: copy + drop
T: copy + drop + store + key
</code></pre>
<h3 id="验证约束-verifying-constraints"><a class="header" href="#验证约束-verifying-constraints">验证约束 (Verifying Constraints)</a></h3>
<p>Constraints are checked at call sites so the following code won't compile.</p>
<p>在调用的地方会检查约束，因此以下代码无法编译。</p>
<pre><code class="language-move">struct Foo&lt;T: key&gt; { x: T }

struct Bar { x: Foo&lt;u8&gt; }
//                  ^ error! u8 does not have 'key'

struct Baz&lt;T&gt; { x: Foo&lt;T&gt; }
//                     ^ error! T does not have 'key'
</code></pre>
<pre><code class="language-move">struct R {}

fun unsafe_consume&lt;T&gt;(x: T) {
    // error! x does not have 'drop'
}

fun consume&lt;T: drop&gt;(x: T) {
    // valid!
    // x will be dropped automatically
}

fun foo() {
    let r = R {};
    consume&lt;R&gt;(r);
    //      ^ error! R does not have 'drop'
}
</code></pre>
<pre><code class="language-move">struct R {}

fun unsafe_double&lt;T&gt;(x: T) {
    (copy x, x)
    // error! x does not have 'copy'
}

fun double&lt;T: copy&gt;(x: T) {
    (copy x, x) // valid!
}

fun foo(): (R, R) {
    let r = R {};
    double&lt;R&gt;(r)
    //     ^ error! R does not have copy
}
</code></pre>
<p>For more information, see the abilities section on <a href="./abilities.html#conditional-abilities-and-generic-types">conditional abilities and generic types</a></p>
<p>有关更多信息，请参阅有关<a href="abilities.html#conditional-abilities-and-generic-types">条件能力与泛型类型</a></p>
<h2 id="递归的限制-limitations-on-recursions"><a class="header" href="#递归的限制-limitations-on-recursions">递归的限制 (Limitations on Recursions)</a></h2>
<h3 id="递归结构-recursive-structs"><a class="header" href="#递归结构-recursive-structs">递归结构 (Recursive Structs)</a></h3>
<p>Generic structs can not contain fields of the same type, either directly or indirectly, even with different type arguments. All of the following struct definitions are invalid:</p>
<p>泛型结构不能直接或间接包含相同类型的字段，即使使用不同的类型参数也是如此。以下所有结构定义均无效：</p>
<pre><code class="language-move">struct Foo&lt;T&gt; {
    x: Foo&lt;u64&gt; // error! 'Foo' containing 'Foo'
}

struct Bar&lt;T&gt; {
    x: Bar&lt;T&gt; // error! 'Bar' containing 'Bar'
}

// error! 'A' and 'B' forming a cycle, which is not allowed either.
struct A&lt;T&gt; {
    x: B&lt;T, u64&gt;
}

struct B&lt;T1, T2&gt; {
    x: A&lt;T1&gt;
    y: A&lt;T2&gt;
}
</code></pre>
<h3 id="高级主题类型-级别递归-advanced-topic-type-level-recursions"><a class="header" href="#高级主题类型-级别递归-advanced-topic-type-level-recursions">高级主题：类型-级别递归 (Advanced Topic: Type-level Recursions)</a></h3>
<p>Move allows generic functions to be called recursively. However, when used in combination with generic structs, this could create an infinite number of types in certain cases, and allowing this means adding unnecessary complexity to the compiler, vm and other language components. Therefore, such recursions are forbidden.</p>
<p>Move语言允许递归调用泛型函数。但是，当与泛型结构体结合使用时，在某些情况下可能会创建无限数量的类型，这意味着会给编译器、vm 和其他语言组件增加不必要的复杂性。因此，这种递归是被禁止的。</p>
<p>被允许的用法:</p>
<pre><code class="language-move">address 0x2 {
    module m {
        struct A&lt;T&gt; {}

        // Finitely many types -- allowed.
        // foo&lt;T&gt; -&gt; foo&lt;T&gt; -&gt; foo&lt;T&gt; -&gt; ... is valid
        fun foo&lt;T&gt;() {
            foo&lt;T&gt;();
        }

        // Finitely many types -- allowed.
        // foo&lt;T&gt; -&gt; foo&lt;A&lt;u64&gt;&gt; -&gt; foo&lt;A&lt;u64&gt;&gt; -&gt; ... is valid
        fun foo&lt;T&gt;() {
            foo&lt;A&lt;u64&gt;&gt;();
        }
    }
}
</code></pre>
<p>不被允许的用法:</p>
<pre><code class="language-move">address 0x2 {
    module m {
        struct A&lt;T&gt; {}

        // Infinitely many types -- NOT allowed.
        // error!
        // foo&lt;T&gt; -&gt; foo&lt;A&lt;T&gt;&gt; -&gt; foo&lt;A&lt;A&lt;T&gt;&gt;&gt; -&gt; ...
        fun foo&lt;T&gt;() {
            foo&lt;Foo&lt;T&gt;&gt;();
        }
    }
}

address 0x2 {
    module n {
        struct A&lt;T&gt; {}

        // Infinitely many types -- NOT allowed.
        // error!
        // foo&lt;T1, T2&gt; -&gt; bar&lt;T2, T1&gt; -&gt; foo&lt;T2, A&lt;T1&gt;&gt;
        //   -&gt; bar&lt;A&lt;T1&gt;, T2&gt; -&gt; foo&lt;A&lt;T1&gt;, A&lt;T2&gt;&gt;
        //   -&gt; bar&lt;A&lt;T2&gt;, A&lt;T1&gt;&gt; -&gt; foo&lt;A&lt;T2&gt;, A&lt;A&lt;T1&gt;&gt;&gt;
        //   -&gt; ...
        fun foo&lt;T1, T2&gt;() {
            bar&lt;T2, T1&gt;();
        }

        fun bar&lt;T1, T2&gt; {
            foo&lt;T1, A&lt;T2&gt;&gt;();
        }
    }
}
</code></pre>
<p>Note, the check for type level recursions is based on a conservative analysis on the call sites and does NOT take control flow or runtime values into account.</p>
<p>请注意，类型级别递归的检查是基于对调用现场的保守分析，并且不考虑控制流或运行时值。</p>
<pre><code class="language-move">address 0x2 {
    module m {
        struct A&lt;T&gt; {}

        fun foo&lt;T&gt;(n: u64) {
            if (n &gt; 0) {
                foo&lt;A&lt;T&gt;&gt;(n - 1);
            };
        }
    }
}
</code></pre>
<p>The function in the example above will technically terminate for any given input and therefore only creating finitely many types, but it is still considered invalid by Move's type system.</p>
<p>上例中的函数将在技术上给定有限的输入，因此只会创建有限多的类型，但仍然会被 Move 语言的类型系统认为是无效的。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="constants.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="abilities.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="constants.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="abilities.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>

        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->


        <script type="text/javascript">
        var langs = [
            'en',
            'zh'
        ];

        (function langs() {
            var html = document.querySelector('html');
            var langToggleButton = document.getElementById('lang-toggle');
            var langPopup = document.getElementById('lang-list');

            function showLangs() {
                langPopup.style.display = 'block';
                langToggleButton.setAttribute('aria-expanded', true);
            }

            function hideLangs() {
                langPopup.style.display = 'none';
                langToggleButton.setAttribute('aria-expanded', false);
                langToggleButton.focus();
            }

            langToggleButton.addEventListener('click', function () {
                if (langPopup.style.display === 'block') {
                    hideLangs();
                } else {
                    showLangs();
                }
            });

            langPopup.addEventListener('click', function (e) {
                var lang = e.target.id || e.target.parentElement.id;
                window.location.pathname = window.location.pathname
                    .split('/')
                    .map((s, idx) => {
                        return idx == 2 ? lang : s;
                    })
                    .join('/');
            });

            langPopup.addEventListener('focusout', function(e) {
                // e.relatedTarget is null in Safari and Firefox on macOS (see workaround below)
                if (!!e.relatedTarget && !langToggleButton.contains(e.relatedTarget) && !langPopup.contains(e.relatedTarget)) {
                    hideLangs();
                }
            });

            // Should not be needed, but it works around an issue on macOS & iOS: https://github.com/rust-lang-nursery/mdBook/issues/628
            document.addEventListener('click', function(e) {
                if (langPopup.style.display === 'block' && !langToggleButton.contains(e.target) && !langPopup.contains(e.target)) {
                    hideLangs();
                }
            });

        })();
        </script>


    </body>
</html>

